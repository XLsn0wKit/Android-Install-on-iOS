
project art/
diff --git a/art/build/art.go b/art/build/art.go
index 4db8da28e0..62835d8286 100644
--- a/art/build/art.go
+++ b/art/build/art.go
@@ -85,20 +85,20 @@ func globalFlags(ctx android.BaseContext) ([]string, []string) {
 	//       the debug version. So make the gap consistent (and adjust for the worst).
 	if len(ctx.AConfig().SanitizeDevice()) > 0 || len(ctx.AConfig().SanitizeHost()) > 0 {
 		cflags = append(cflags,
-			"-DART_STACK_OVERFLOW_GAP_arm=8192",
-			"-DART_STACK_OVERFLOW_GAP_arm64=8192",
+			"-DART_STACK_OVERFLOW_GAP_arm=16384",
+			"-DART_STACK_OVERFLOW_GAP_arm64=16384",
 			"-DART_STACK_OVERFLOW_GAP_mips=16384",
 			"-DART_STACK_OVERFLOW_GAP_mips64=16384",
 			"-DART_STACK_OVERFLOW_GAP_x86=16384",
-			"-DART_STACK_OVERFLOW_GAP_x86_64=20480")
+			"-DART_STACK_OVERFLOW_GAP_x86_64=32768")
 	} else {
 		cflags = append(cflags,
-			"-DART_STACK_OVERFLOW_GAP_arm=8192",
-			"-DART_STACK_OVERFLOW_GAP_arm64=8192",
+			"-DART_STACK_OVERFLOW_GAP_arm=16384",
+			"-DART_STACK_OVERFLOW_GAP_arm64=16384",
 			"-DART_STACK_OVERFLOW_GAP_mips=16384",
 			"-DART_STACK_OVERFLOW_GAP_mips64=16384",
-			"-DART_STACK_OVERFLOW_GAP_x86=8192",
-			"-DART_STACK_OVERFLOW_GAP_x86_64=8192")
+			"-DART_STACK_OVERFLOW_GAP_x86=16384",
+			"-DART_STACK_OVERFLOW_GAP_x86_64=16384")
 	}
 
 	if envTrue(ctx, "ART_ENABLE_ADDRESS_SANITIZER") {
diff --git a/art/libartbase/base/globals.h b/art/libartbase/base/globals.h
index 97eae635d4..2a764f5704 100644
--- a/art/libartbase/base/globals.h
+++ b/art/libartbase/base/globals.h
@@ -36,7 +36,7 @@ static constexpr size_t kStackAlignment = 16;
 
 // System page size. We check this against sysconf(_SC_PAGE_SIZE) at runtime, but use a simple
 // compile-time constant so the compiler can generate better code.
-static constexpr int kPageSize = 4096;
+static constexpr int kPageSize = 0x4000;
 
 // Clion, clang analyzer, etc can falsely believe that "if (kIsDebugBuild)" always
 // returns the same value. By wrapping into a call to another constexpr function, we force it
diff --git a/art/runtime/monitor_pool.h b/art/runtime/monitor_pool.h
index 4521a22c6f..b881b81a73 100644
--- a/art/runtime/monitor_pool.h
+++ b/art/runtime/monitor_pool.h
@@ -200,7 +200,7 @@ class MonitorPool {
   // should be large enough that we don't run out. We run out of address bits if it's > 512.
   // Currently we set it a bit smaller, to save half a page per process.  We make it tiny in
   // debug builds to catch growth errors. The only value we really expect to tune.
-  static constexpr size_t kInitialChunkStorage = kIsDebugBuild ? 1U : 256U;
+  static constexpr size_t kInitialChunkStorage = 64U;
   static_assert(IsPowerOfTwo(kInitialChunkStorage), "kInitialChunkStorage must be power of 2");
   // The number of lists, each containing pointers to storage chunks.
   static constexpr size_t kMaxChunkLists = 8;  //  Dictated by 3 bit index. Don't increase above 8.
diff --git a/art/runtime/native/sun_misc_Unsafe.cc b/art/runtime/native/sun_misc_Unsafe.cc
index 5014f340cd..259a22c02d 100644
--- a/art/runtime/native/sun_misc_Unsafe.cc
+++ b/art/runtime/native/sun_misc_Unsafe.cc
@@ -224,7 +224,7 @@ static jint Unsafe_addressSize(JNIEnv* env ATTRIBUTE_UNUSED, jobject ob ATTRIBUT
 }
 
 static jint Unsafe_pageSize(JNIEnv* env ATTRIBUTE_UNUSED, jobject ob ATTRIBUTE_UNUSED) {
-  return sysconf(_SC_PAGESIZE);
+  return 0x4000;
 }
 
 static jlong Unsafe_allocateMemory(JNIEnv* env, jobject, jlong bytes) {
diff --git a/art/runtime/runtime.cc b/art/runtime/runtime.cc
index 51a40e78c6..05ecbcc72b 100644
--- a/art/runtime/runtime.cc
+++ b/art/runtime/runtime.cc
@@ -1122,7 +1122,6 @@ bool Runtime::Init(RuntimeArgumentMap&& runtime_options_in) {
   using Opt = RuntimeArgumentMap;
   Opt runtime_options(std::move(runtime_options_in));
   ScopedTrace trace(__FUNCTION__);
-  CHECK_EQ(sysconf(_SC_PAGE_SIZE), kPageSize);
 
   // Early override for logging output.
   if (runtime_options.Exists(Opt::UseStderrLogger)) {
diff --git a/art/runtime/thread_pool.cc b/art/runtime/thread_pool.cc
index e1c756d6a8..8202301e4d 100644
--- a/art/runtime/thread_pool.cc
+++ b/art/runtime/thread_pool.cc
@@ -53,7 +53,6 @@ ThreadPoolWorker::ThreadPoolWorker(ThreadPool* thread_pool, const std::string& n
                                 /*low_4gb=*/ false,
                                 &error_msg);
   CHECK(stack_.IsValid()) << error_msg;
-  CHECK_ALIGNED(stack_.Begin(), kPageSize);
   CheckedCall(mprotect,
               "mprotect bottom page of thread pool worker stack",
               stack_.Begin(),

project bionic/
diff --git a/bionic/libc/bionic/ndk_cruft.cpp b/bionic/libc/bionic/ndk_cruft.cpp
index 2c3299f7b..fb13173f4 100644
--- a/bionic/libc/bionic/ndk_cruft.cpp
+++ b/bionic/libc/bionic/ndk_cruft.cpp
@@ -58,7 +58,7 @@ int __isthreaded = 1;
 // These were accidentally declared in <unistd.h> because we stupidly used to inline
 // getpagesize() and __getpageshift(). Needed for backwards compatibility with old NDK apps.
 unsigned int __page_size = PAGE_SIZE;
-unsigned int __page_shift = 12;
+unsigned int __page_shift = 14;
 
 // TODO: remove this backward compatibility hack (for jb-mr1 strace binaries).
 pid_t __wait4(pid_t pid, int* status, int options, struct rusage* rusage) {
diff --git a/bionic/libc/include/sys/user.h b/bionic/libc/include/sys/user.h
index ed3e10a1f..f2ac796e9 100644
--- a/bionic/libc/include/sys/user.h
+++ b/bionic/libc/include/sys/user.h
@@ -35,7 +35,7 @@
 
 __BEGIN_DECLS
 
-#define PAGE_SIZE 4096
+#define PAGE_SIZE 16384
 #define PAGE_MASK (~(PAGE_SIZE - 1))
 
 #if defined(__i386__)
diff --git a/bionic/libc/kernel/uapi/asm-generic/param.h b/bionic/libc/kernel/uapi/asm-generic/param.h
index 7897799b7..b36802057 100644
--- a/bionic/libc/kernel/uapi/asm-generic/param.h
+++ b/bionic/libc/kernel/uapi/asm-generic/param.h
@@ -22,7 +22,7 @@
 #define HZ 100
 #endif
 #ifndef EXEC_PAGESIZE
-#define EXEC_PAGESIZE 4096
+#define EXEC_PAGESIZE 0x4000
 #endif
 #ifndef NOGROUP
 #define NOGROUP (- 1)

project build/make/
diff --git a/build/make/target/board/generic_arm64/BoardConfig.mk b/build/make/target/board/generic_arm64/BoardConfig.mk
index f07adb721..b7624a785 100644
--- a/build/make/target/board/generic_arm64/BoardConfig.mk
+++ b/build/make/target/board/generic_arm64/BoardConfig.mk
@@ -19,9 +19,11 @@ TARGET_ARCH_VARIANT := armv8-a
 TARGET_CPU_VARIANT := generic
 TARGET_CPU_ABI := arm64-v8a
 
-TARGET_2ND_ARCH := arm
-TARGET_2ND_CPU_ABI := armeabi-v7a
-TARGET_2ND_CPU_ABI2 := armeabi
+AUDIOSERVER_MULTILIB := 64
+
+#TARGET_2ND_ARCH := arm
+#TARGET_2ND_CPU_ABI := armeabi-v7a
+#TARGET_2ND_CPU_ABI2 := armeabi
 
 ifneq ($(TARGET_BUILD_APPS)$(filter cts sdk vts,$(MAKECMDGOALS)),)
 # DO NOT USE
@@ -41,15 +43,15 @@ ifneq ($(TARGET_BUILD_APPS)$(filter cts sdk vts,$(MAKECMDGOALS)),)
 #
 # DO NOT USE
 # DO NOT USE
-TARGET_2ND_ARCH_VARIANT := armv7-a-neon
+#TARGET_2ND_ARCH_VARIANT := armv7-a-neon
 # DO NOT USE
 # DO NOT USE
-TARGET_2ND_CPU_VARIANT := generic
+#TARGET_2ND_CPU_VARIANT := generic
 # DO NOT USE
 # DO NOT USE
 else
-TARGET_2ND_ARCH_VARIANT := armv8-a
-TARGET_2ND_CPU_VARIANT := generic
+#TARGET_2ND_ARCH_VARIANT := armv8-a
+#TARGET_2ND_CPU_VARIANT := generic
 endif
 
 include build/make/target/board/BoardConfigGsiCommon.mk
@@ -70,11 +72,9 @@ BOARD_ROOT_EXTRA_SYMLINKS += /vendor/firmware_mnt:/firmware
 BOARD_SEPOLICY_DIRS += build/target/board/generic_arm64_ab/sepolicy
 
 # Wifi.
-BOARD_WLAN_DEVICE           := emulator
+BOARD_WLAN_DEVICE           := brcmfmac
 BOARD_HOSTAPD_DRIVER        := NL80211
 BOARD_WPA_SUPPLICANT_DRIVER := NL80211
-BOARD_HOSTAPD_PRIVATE_LIB   := lib_driver_cmd_simulated
-BOARD_WPA_SUPPLICANT_PRIVATE_LIB := lib_driver_cmd_simulated
 WPA_SUPPLICANT_VERSION      := VER_0_8_X
 WIFI_DRIVER_FW_PATH_PARAM   := "/dev/null"
 WIFI_DRIVER_FW_PATH_STA     := "/dev/null"
diff --git a/build/make/target/product/AndroidProducts.mk b/build/make/target/product/AndroidProducts.mk
index cfb893082..cfecc417e 100644
--- a/build/make/target/product/AndroidProducts.mk
+++ b/build/make/target/product/AndroidProducts.mk
@@ -67,6 +67,7 @@ PRODUCT_MAKEFILES := \
     $(LOCAL_DIR)/sdk_phone_x86.mk \
     $(LOCAL_DIR)/sdk_x86_64.mk \
     $(LOCAL_DIR)/sdk_x86.mk \
+    $(LOCAL_DIR)/sandcastle_arm64.mk \
 
 endif
 
diff --git a/build/make/target/product/aosp_arm64.mk b/build/make/target/product/aosp_arm64.mk
index 8ef2023e6..96ec3c792 100644
--- a/build/make/target/product/aosp_arm64.mk
+++ b/build/make/target/product/aosp_arm64.mk
@@ -45,6 +45,7 @@ endif
 PRODUCT_ARTIFACT_PATH_REQUIREMENT_WHITELIST += \
     root/init.zygote32_64.rc \
     root/init.zygote64_32.rc \
+    root/init.zygote64.rc \
 
 # Copy different zygote settings for vendor.img to select by setting property
 # ro.zygote=zygote64_32 or ro.zygote=zygote32_64:
diff --git a/build/make/target/product/core_64_bit.mk b/build/make/target/product/core_64_bit.mk
index 76e2a36a3..f01d7438d 100644
--- a/build/make/target/product/core_64_bit.mk
+++ b/build/make/target/product/core_64_bit.mk
@@ -24,10 +24,11 @@
 
 # Copy the 64-bit primary, 32-bit secondary zygote startup script
 PRODUCT_COPY_FILES += system/core/rootdir/init.zygote64_32.rc:root/init.zygote64_32.rc
+PRODUCT_COPY_FILES += system/core/rootdir/init.zygote64.rc:root/init.zygote64.rc
 
 # Set the zygote property to select the 64-bit primary, 32-bit secondary script
 # This line must be parsed before the one in core_minimal.mk
-PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.zygote=zygote64_32
+PRODUCT_DEFAULT_PROPERTY_OVERRIDES += ro.zygote=zygote64
 
-TARGET_SUPPORTS_32_BIT_APPS := true
+TARGET_SUPPORTS_32_BIT_APPS := false
 TARGET_SUPPORTS_64_BIT_APPS := true
diff --git a/build/make/target/product/emulator_vendor.mk b/build/make/target/product/emulator_vendor.mk
index f0a535480..7358dac88 100644
--- a/build/make/target/product/emulator_vendor.mk
+++ b/build/make/target/product/emulator_vendor.mk
@@ -42,7 +42,7 @@ PRODUCT_PACKAGES += \
 
 PRODUCT_PACKAGE_OVERLAYS := device/generic/goldfish/overlay
 
-PRODUCT_CHARACTERISTICS := emulator
+# PRODUCT_CHARACTERISTICS := emulator
 
 PRODUCT_FULL_TREBLE_OVERRIDE := true
 
diff --git a/build/make/target/product/sandcastle_arm64.mk b/build/make/target/product/sandcastle_arm64.mk
new file mode 100644
index 000000000..bc86585f6
--- /dev/null
+++ b/build/make/target/product/sandcastle_arm64.mk
@@ -0,0 +1,27 @@
+#
+# Copyright (C) 2009 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+$(call inherit-product, $(SRC_TARGET_DIR)/product/aosp_arm64.mk)
+
+# Define the host tools and libs that are parts of the SDK.
+$(call inherit-product, sdk/build/product_sdk.mk)
+$(call inherit-product, development/build/product_sdk.mk)
+
+# Overrides
+PRODUCT_BRAND := Android
+PRODUCT_NAME := sandcastle_arm64
+PRODUCT_DEVICE := generic_arm64
+PRODUCT_MODEL := Sandcastle
diff --git a/build/make/tools/releasetools/apex_utils.py b/build/make/tools/releasetools/apex_utils.py
index fb4ca7667..27e178ab9 100644
--- a/build/make/tools/releasetools/apex_utils.py
+++ b/build/make/tools/releasetools/apex_utils.py
@@ -199,7 +199,7 @@ def SignApex(apex_data, payload_key, container_key, container_pw,
 
   # 2. Align the files at page boundary (same as in apexer).
   aligned_apex = common.MakeTempFile(prefix='apex-container-', suffix='.apex')
-  common.RunAndCheckOutput(['zipalign', '-f', '4096', apex_file, aligned_apex])
+  common.RunAndCheckOutput(['zipalign', '-f', '16384', apex_file, aligned_apex])
 
   # 3. Sign the APEX container with container_key.
   signed_apex = common.MakeTempFile(prefix='apex-container-', suffix='.apex')
diff --git a/build/make/tools/signapk/src/com/android/signapk/SignApk.java b/build/make/tools/signapk/src/com/android/signapk/SignApk.java
index 57973ec04..4ba25687f 100644
--- a/build/make/tools/signapk/src/com/android/signapk/SignApk.java
+++ b/build/make/tools/signapk/src/com/android/signapk/SignApk.java
@@ -631,7 +631,7 @@ class SignApk {
         if (entryName.endsWith(".so")) {
             // Align .so contents to memory page boundary to enable memory-mapped
             // execution.
-            return 4096;
+            return 16384;
         } else {
             return defaultAlignment;
         }
diff --git a/build/make/tools/zipalign/ZipAlign.cpp b/build/make/tools/zipalign/ZipAlign.cpp
index eea174997..e13d347b8 100644
--- a/build/make/tools/zipalign/ZipAlign.cpp
+++ b/build/make/tools/zipalign/ZipAlign.cpp
@@ -47,7 +47,9 @@ void usage(void)
 static int getAlignment(bool pageAlignSharedLibs, int defaultAlignment,
     ZipEntry* pEntry) {
 
-    static const int kPageAlignment = 4096;
+    static const int kPageAlignment = 16384;
+    if(defaultAlignment == 4096)
+        defaultAlignment = 16384; /* FREE UPGRADE! */
 
     if (!pageAlignSharedLibs) {
         return defaultAlignment;

project build/soong/
diff --git a/build/soong/cc/config/arm64_device.go b/build/soong/cc/config/arm64_device.go
index 1ca1656d..9c908ea0 100644
--- a/build/soong/cc/config/arm64_device.go
+++ b/build/soong/cc/config/arm64_device.go
@@ -44,7 +44,7 @@ var (
 	}
 
 	arm64Lldflags = append(ClangFilterUnknownLldflags(arm64Ldflags),
-		"-Wl,-z,max-page-size=4096")
+		"-Wl,-z,max-page-size=16384")
 
 	arm64Cppflags = []string{}
 
diff --git a/build/soong/cc/config/arm_device.go b/build/soong/cc/config/arm_device.go
index cd7c4107..9554c876 100644
--- a/build/soong/cc/config/arm_device.go
+++ b/build/soong/cc/config/arm_device.go
@@ -39,7 +39,8 @@ var (
 		"-Wl,-m,armelf",
 	}
 
-	armLldflags = ClangFilterUnknownLldflags(armLdflags)
+	armLldflags = append(ClangFilterUnknownLldflags(armLdflags),
+		"-Wl,-z,max-page-size=16384")
 
 	armArmCflags = []string{
 		"-fstrict-aliasing",

project dalvik/
diff --git a/dalvik/libdex/SysUtil.h b/dalvik/libdex/SysUtil.h
index c02ec6eda..1e50914e7 100644
--- a/dalvik/libdex/SysUtil.h
+++ b/dalvik/libdex/SysUtil.h
@@ -34,7 +34,7 @@
 #ifdef PAGE_SHIFT
 #define SYSTEM_PAGE_SIZE        (1<<PAGE_SHIFT)
 #else
-#define SYSTEM_PAGE_SIZE        4096
+#define SYSTEM_PAGE_SIZE        0x4000
 #endif
 
 /*

project device/generic/goldfish/
diff --git a/device/generic/goldfish/arm64-vendor.mk b/device/generic/goldfish/arm64-vendor.mk
index a05654d..114bccc 100644
--- a/device/generic/goldfish/arm64-vendor.mk
+++ b/device/generic/goldfish/arm64-vendor.mk
@@ -15,6 +15,7 @@ PRODUCT_COPY_FILES += \
     device/generic/goldfish/manifest-arm.xml:$(TARGET_COPY_OUT_VENDOR)/manifest.xml \
     device/generic/goldfish/data/etc/advancedFeatures.ini.arm:advancedFeatures.ini \
     prebuilts/qemu-kernel/arm64/$(PRODUCT_KERNEL_VERSION)/kernel-qemu2:kernel-ranchu \
-    device/generic/goldfish/fstab.ranchu.arm:$(TARGET_COPY_OUT_VENDOR)/etc/fstab.ranchu
+    device/generic/goldfish/fstab.ranchu.arm:$(TARGET_COPY_OUT_VENDOR)/etc/fstab.ranchu \
+    device/generic/goldfish/dummy:$(TARGET_COPY_OUT_ROOT)/apfs/dummy \
+    device/generic/goldfish/dummy:$(TARGET_COPY_OUT_ROOT)/hostfs/dummy
 EMULATOR_VENDOR_NO_GNSS := true
-
diff --git a/device/generic/goldfish/dummy b/device/generic/goldfish/dummy
new file mode 100644
index 0000000..e69de29
diff --git a/device/generic/goldfish/fstab.ranchu.arm b/device/generic/goldfish/fstab.ranchu.arm
index a821e97..c2f57ed 100644
--- a/device/generic/goldfish/fstab.ranchu.arm
+++ b/device/generic/goldfish/fstab.ranchu.arm
@@ -4,5 +4,6 @@
 # specify MF_CHECK, and must come before any filesystems that do specify MF_CHECK
 system   /system     ext4    ro,barrier=1     wait,logical,first_stage_mount
 vendor   /vendor     ext4    ro,barrier=1     wait,logical,first_stage_mount
-/dev/block/vdc  /data    ext4      noatime,nosuid,nodev,nomblk_io_submit,errors=panic   wait,check,quota
-/devices/*/block/vde  auto  auto      defaults voldmanaged=sdcard:auto,encryptable=userdata
+data     /data       tmpfs   noatime,nosuid,nodev   wait,check
+cache    /cache      tmpfs   noatime,nosuid,nodev   wait,check
+metadata /metadata   tmpfs   noatime,nosuid,nodev   wait,check
diff --git a/device/generic/goldfish/hcdpack/Android.bp b/device/generic/goldfish/hcdpack/Android.bp
new file mode 100644
index 0000000..428921c
--- /dev/null
+++ b/device/generic/goldfish/hcdpack/Android.bp
@@ -0,0 +1,11 @@
+cc_binary {
+    name: "hcdpack",
+    proprietary: true,
+    srcs: [
+        "hcdpack.c",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+    ],
+}
diff --git a/device/generic/goldfish/hcdpack/hcdpack.c b/device/generic/goldfish/hcdpack/hcdpack.c
new file mode 100644
index 0000000..f31e1c4
--- /dev/null
+++ b/device/generic/goldfish/hcdpack/hcdpack.c
@@ -0,0 +1,183 @@
+#define _XOPEN_SOURCE   500
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <ctype.h>
+
+#define MAX_IMAGES      128
+
+static uint8_t *buf;
+static size_t size;
+
+static struct {
+    size_t offs, size;
+    char *name;
+} images[MAX_IMAGES];
+static unsigned nimages;
+
+static void process_cfgd(uint8_t *buf, size_t size, char *name)
+{
+    size_t strsz;
+
+    if(size < 11)
+        return;
+    strsz = buf[10];
+    if(strsz > size - 11)
+        return;
+
+    memcpy(name, &buf[11], strsz);
+    name[strsz] = 0;
+}
+
+static size_t process_image(uint8_t *buf, size_t size, char *name)
+{
+    size_t offs, itsz;
+    uint16_t op;
+
+    for(offs=0; offs<=size-3; ) {
+        op = *(uint16_t *)&buf[offs];
+        itsz = buf[offs+2];
+        if(itsz > size - offs - 3)
+            itsz = size - offs - 3;
+        if(op != 0xFC4E && op != 0xFC4C)
+            break;
+        if(offs > 0 && offs <= size - 15 && buf[offs] == 0x4C && buf[offs+1] == 0xFC && !memcmp(&buf[offs+7], "BRCMcfgS", 8))
+            break;
+        if(offs <= size - 15 && buf[offs] == 0x4C && buf[offs+1] == 0xFC && !memcmp(&buf[offs+7], "BRCMcfgD", 8))
+            process_cfgd(&buf[offs+15], itsz - 12, name);
+        offs += itsz + 3;
+        if(op == 0xFC4E)
+            break;
+    }
+
+    return offs;
+}
+
+static void collect_images(int print)
+{
+    size_t offs, imsz;
+    char name[256];
+
+    for(offs=0; offs<=size-15; offs++) {
+        if(buf[offs] != 0x4C || buf[offs+1] != 0xFC)
+            continue;
+        if(memcmp(&buf[offs+7], "BRCMcfgS", 8))
+            continue;
+        name[0] = 0;
+        imsz = process_image(buf + offs, size - offs, name);
+        if(print)
+            printf("Found sig at %ld (%ld): %s\n", offs, imsz, name);
+        if(nimages < MAX_IMAGES) {
+            images[nimages].offs = offs;
+            images[nimages].size = imsz;
+            images[nimages].name = strdup(name);
+            nimages ++;
+        }
+        offs += imsz - 1;
+    }
+}
+
+static void get_tag(const char *str, char id, char *out, size_t outlen)
+{
+    const char *n;
+    size_t l;
+
+    out[0] = 0;
+    while(*str) {
+        if(str[0] == '_') {
+            str ++;
+            continue;
+        }
+        if(str[1] != '-')
+            return;
+        n = strchr(str + 2, '_');
+        if(!n)
+            n = str + strlen(str);
+        if(str[0] == id) {
+            str += 2;
+            l = n - str;
+            if(l + 1 > outlen)
+                l = outlen - 1;
+            memcpy(out, str, l);
+            out[l] = 0;
+            return;
+        }
+        str = n;
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    FILE *f;
+    char chip[8], rev[4], mod[32], vend[4], *vendstr;
+    char chipstr[64], modstr[64];
+    unsigned i;
+
+    if(argc != 2 && argc != 6) {
+        fprintf(stderr, "usage: hcdpack <hcd-pack>\n");
+        fprintf(stderr, "       hcdpack <hcd-pack> <otp-chip> <module> <otp-nvram> <outfile>\n");
+        return 1;
+    }
+
+    f = fopen(argv[1], "rb");
+    if(!f) {
+        fprintf(stderr, "error: failed opening '%s'.\n", argv[1]);
+        return 1;
+    }
+    fseek(f, 0, SEEK_END);
+    size = ftell(f);
+    fseek(f, 0, SEEK_SET);
+    buf = malloc(size);
+    fread(buf, 1, size, f);
+    fclose(f);
+
+    collect_images(argc == 2);
+    if(argc < 6)
+        return 0;
+
+    get_tag(argv[2], 'C', chip, sizeof(chip));
+    get_tag(argv[2], 's', rev, sizeof(rev));
+    strcpy(mod, argv[3]);
+    mod[0] = toupper(mod[0]);
+    get_tag(argv[4], 'V', vend, sizeof(vend));
+    switch(tolower(vend[0])) {
+    case 'm': vendstr = "MUR"; break;
+    case 'u': vendstr = "USI"; break;
+    case 't': vendstr = "TDK"; break;
+    default: vendstr = "UNK";
+    }
+    sprintf(chipstr, "BCM%s%s ", chip, rev);
+    sprintf(modstr, " %s %s", mod, vendstr);
+
+    /* this chip has different names on WLAN and Bluetooth */
+    if(!strcmp(chipstr, "BCM43452A3 ")) {
+        strcpy(chip, "4345");
+        strcpy(rev, "C1");
+        strcpy(chipstr, "BCM4345C1 ");
+    }
+
+    for(i=0; i<nimages; i++) {
+        if(strncmp(images[i].name, chipstr, strlen(chipstr)))
+            continue;
+        if(strstr(images[i].name, modstr))
+            break;
+    }
+    if(i >= nimages) {
+        fprintf(stderr, "Image for %s/%s not found.\n", chipstr, modstr);
+        return 1;
+    }
+
+    f = fopen(argv[5], "wb");
+    if(!f) {
+        fprintf(stderr, "error: failed opening '%s' for write.\n", argv[5]);
+        return 1;
+    }
+    fwrite(buf + images[i].offs, images[i].size, 1, f);
+    fclose(f);
+
+    printf("BCM%s%s.hcd", chip, rev);
+
+    return 0;
+}
diff --git a/device/generic/goldfish/hx-touch/Android.bp b/device/generic/goldfish/hx-touch/Android.bp
new file mode 100644
index 0000000..8050fc1
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/Android.bp
@@ -0,0 +1,31 @@
+cc_binary {
+    name: "hx-touchd",
+    init_rc: ["hx-touchd.rc"],
+    proprietary: true,
+    relative_install_path: "hw",
+    srcs: [
+        "hx-touchd.c",
+        "mxml-3.1/mxml-attr.c",
+        "mxml-3.1/mxml-entity.c",
+        "mxml-3.1/mxml-file.c",
+        "mxml-3.1/mxml-get.c",
+        "mxml-3.1/mxml-index.c",
+        "mxml-3.1/mxml-node.c",
+        "mxml-3.1/mxml-private.c",
+        "mxml-3.1/mxml-search.c",
+        "mxml-3.1/mxml-set.c",
+        "mxml-3.1/mxml-string.c",
+        "mtfw/eplist.c",
+        "mtfw/mtfw.c",
+        "mtfw/qdict.c",
+        "mtfw/syscfg.c",
+    ],
+    local_include_dirs: [
+        "mxml-3.1",
+        "mtfw",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+    ],
+}
diff --git a/device/generic/goldfish/hx-touch/D10.mtprops b/device/generic/goldfish/hx-touch/D10.mtprops
new file mode 100644
index 0000000..0d3b5ed
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/D10.mtprops
@@ -0,0 +1,18 @@
+<plist version="1.0">
+<dict>
+	<key>C1F5D,2</key>
+	<dict>
+		<key>Constructed Firmware</key>
+		<array>
+		</array>
+		<key>Firmware Config</key>
+		<data>
+		PGRpY3Q+PGtleT5DYWxpYnJhdGlvbiBTZXF1ZW5jZTwva2V5PjxhcnJheS8+PGtleT5Cb290IFNl
+		cXVlbmNlPC9rZXk+PGFycmF5PjxkaWN0PjxrZXk+TWFzazwva2V5PjxpbnRlZ2VyIHNpemU9IjY0
+		Ij4weGZmZmZmZmZmPC9pbnRlZ2VyPjxrZXk+QWRkcmVzczwva2V5PjxpbnRlZ2VyIHNpemU9IjY0
+		Ij4weDEwMDAzNDAwPC9pbnRlZ2VyPjxrZXk+VmFsdWU8L2tleT48aW50ZWdlciBzaXplPSI2NCI+
+		MHgxPC9pbnRlZ2VyPiA8L2RpY3Q+PC9hcnJheT48L2RpY3Q+AAo=
+		</data>
+	</dict>
+</dict>
+</plist>
diff --git a/device/generic/goldfish/hx-touch/hx-touch.fwlist b/device/generic/goldfish/hx-touch/hx-touch.fwlist
new file mode 100644
index 0000000..aabf313
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/hx-touch.fwlist
@@ -0,0 +1,3 @@
+C1F5D,2 /hostfs/usr/share/firmware/multitouch/D10.mtprops
+C1F5E,2 /hostfs/usr/share/firmware/multitouch/D11.mtprops
+C1F58,1 /hostfs/usr/share/firmware/multitouch/N112.mtprops
diff --git a/device/generic/goldfish/hx-touch/hx-touchd.c b/device/generic/goldfish/hx-touch/hx-touchd.c
new file mode 100644
index 0000000..2f7604d
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/hx-touchd.c
@@ -0,0 +1,542 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2018-20 Corellium LLC
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <unistd.h>
+
+#include "mtfw.h"
+
+struct hxt_metrics {
+    int left, right;
+    int top, bottom;
+};
+
+#define HXT_IOC_MAGIC           'h'
+#define HXT_IOC_SET_CS          _IOW(HXT_IOC_MAGIC, 1, uint32_t)
+#define HXT_IOC_RESET           _IO(HXT_IOC_MAGIC, 2)
+#define HXT_IOC_READY           _IO(HXT_IOC_MAGIC, 3)
+#define HXT_IOC_SETUP_IRQ       _IO(HXT_IOC_MAGIC, 4)
+#define HXT_IOC_WAIT_IRQ        _IOW(HXT_IOC_MAGIC, 5, uint32_t)
+#define HXT_IOC_METRICS         _IOW(HXT_IOC_MAGIC, 6, struct hxt_metrics)
+
+#define MAX_DATA_CHUNK          16384
+
+#define MT_CMD_LAST             0xE1
+#define MT_DEV_INFO             0xE2
+#define MT_REP_INFO             0xE3
+#define MT_CTRL_WRITE_SHORT     0xE4
+#define MT_CTRL_WRITE_LONG      0xE5
+#define MT_CTRL_READ_SHORT      0xE6
+#define MT_CTRL_READ_LONG       0xE7
+#define MT_READ_FRAME_LEN       0xEA
+#define MT_READ_LEN             0xEB
+#define MT_SPI_Z2_WAKE_CMD      0xEE
+
+#define MAX_CTRL_CONN           4
+
+static mtfw_item_t *mt_firmware;
+static unsigned mt_type;
+
+static int bootload(int fd)
+{
+    int i, sz;
+    unsigned char buf[16], rdbuf[MAX_DATA_CHUNK];
+    mtfw_item_t *iter;
+
+    if(ioctl(fd, HXT_IOC_RESET)) {
+        perror("failed resetting controller");
+        return 1;
+    }
+
+    memset(buf, 0, sizeof(buf));
+
+    if(write(fd, buf, 4) != 4) {
+        perror("failed writing command");
+        return 1;
+    }
+    if(read(fd, buf, 4) != 4) {
+        perror("failed reading result");
+        return 1;
+    }
+    usleep(1000);
+
+    if(ioctl(fd, HXT_IOC_SETUP_IRQ)) {
+        perror("failed enabling IRQ");
+        return 1;
+    }
+
+    if(ioctl(fd, HXT_IOC_RESET)) {
+        perror("failed resetting controller");
+        return 1;
+    }
+
+    if(ioctl(fd, HXT_IOC_WAIT_IRQ, 500))
+        perror("failed waiting for boot IRQ");
+
+    memset(buf, 0, sizeof(buf));
+
+    if(ioctl(fd, HXT_IOC_SET_CS, 1)) {
+        perror("failed asserting CS#");
+        return 1;
+    }
+    usleep(1000);
+
+    if(write(fd, buf, 4) != 4) {
+        perror("failed writing command");
+        return 1;
+    }
+    if(read(fd, buf, 4) != 4) {
+        perror("failed reading result");
+        return 1;
+    }
+
+    if(ioctl(fd, HXT_IOC_SET_CS, 0)) {
+        perror("failed deasserting CS#");
+        return 1;
+    }
+
+    for(iter=mt_firmware; iter; iter=iter->next) {
+        switch(iter->type) {
+        case MTFW_SET_TYPE:
+            mt_type = 0;
+            memcpy(&mt_type, iter->data, iter->size);
+            break;
+
+        case MTFW_WRITE:
+        case MTFW_WRITE_ACK:
+            if(ioctl(fd, HXT_IOC_SET_CS, 1)) {
+                perror("failed asserting CS#");
+                return 1;
+            }
+            usleep(1000);
+            for(i=0; i<iter->size; i+=MAX_DATA_CHUNK) {
+                sz = iter->size - i;
+                if(sz > MAX_DATA_CHUNK)
+                    sz = MAX_DATA_CHUNK;
+
+                if(write(fd, iter->data + i, sz) != sz) {
+                    perror("failed writing data block");
+                    return 1;
+                }
+                if(read(fd, rdbuf, sz) != sz) {
+                    perror("failed reading result");
+                    return 1;
+                }
+            }
+            if(ioctl(fd, HXT_IOC_SET_CS, 0)) {
+                perror("failed deasserting CS#");
+                return 1;
+            }
+
+            if(iter->type == MTFW_WRITE_ACK) {
+                buf[0] = 0x1A;
+                buf[1] = 0xA1;
+                if(ioctl(fd, HXT_IOC_SET_CS, 1)) {
+                    perror("failed asserting CS#");
+                    return 1;
+                }
+                usleep(1000);
+                if(write(fd, buf, 2) != 2) {
+                    perror("failed writing data block");
+                    return 1;
+                }
+                if(read(fd, buf, 2) != 2) {
+                    perror("failed reading result");
+                    return 1;
+                }
+                if(ioctl(fd, HXT_IOC_SET_CS, 0)) {
+                    perror("failed deasserting CS#");
+                    return 1;
+                }
+                usleep(1000);
+            }
+
+            break;
+        }
+    }
+
+    usleep(50000);
+    return 0;
+}
+
+static unsigned get16le(unsigned char *buf)
+{
+    return ((unsigned)buf[1] << 8) | buf[0];
+}
+
+static void put16le(unsigned char *buf, unsigned val)
+{
+    buf[0] = val;
+    buf[1] = val >> 8;
+}
+
+static int send_z2(int fd, unsigned char *cmd, unsigned char *rsp)
+{
+    unsigned char buf[16] = { 0 };
+    unsigned i, csum = 0;
+
+    if(!cmd)
+        cmd = buf;
+    if(!rsp)
+        rsp = buf;
+
+    for(i=0; i<14; i++)
+        csum += cmd[i];
+    put16le(cmd + 14, csum);
+
+    if(ioctl(fd, HXT_IOC_SET_CS, 1)) {
+        perror("failed asserting CS#");
+        return 1;
+    }
+    usleep(1000);
+
+    if(write(fd, cmd, 16) != 16) {
+        perror("failed writing command");
+        return 1;
+    }
+    if(read(fd, rsp, 16) != 16) {
+        perror("failed reading result");
+        return 1;
+    }
+
+    if(ioctl(fd, HXT_IOC_SET_CS, 0)) {
+        perror("failed deasserting CS#");
+        return 1;
+    }
+    usleep(1000);
+
+    return 0;
+}
+
+static int send_wake(int fd)
+{
+    unsigned char cmd[16] = { MT_SPI_Z2_WAKE_CMD };;
+    return send_z2(fd, cmd, NULL);
+}
+
+static unsigned bytesum(const unsigned char *ptr, unsigned num)
+{
+    unsigned sum = 0;
+    while(num --)
+        sum += *(ptr ++);
+    return sum;
+}
+
+static int read_report(int fd, unsigned char rpt, unsigned char *buf, unsigned *plen)
+{
+    unsigned char cmd[16] = { MT_REP_INFO, rpt };
+    unsigned char rsp[16], *pbuf;
+    unsigned len, rlen;
+    if(send_z2(fd, cmd, NULL))
+        return 1;
+    if(send_z2(fd, cmd, rsp))
+        return 1;
+    if(rsp[2])
+        return 2;
+    len = get16le(rsp + 3);
+    rlen = len < *plen ? len : *plen;
+    *plen = len;
+    if(rlen <= 11) {
+        cmd[0] = MT_CTRL_READ_SHORT;
+        if(send_z2(fd, cmd, NULL))
+            return 1;
+        cmd[0] = MT_CMD_LAST;
+        cmd[1] = 0;
+        if(send_z2(fd, cmd, rsp))
+            return 1;
+        memcpy(buf, rsp + 3, rlen);
+        return 0;
+    }
+    cmd[0] = MT_CTRL_READ_LONG;
+    put16le(cmd + 3, rlen);
+    if(send_z2(fd, cmd, NULL))
+        return 1;
+    pbuf = malloc(rlen + 5);
+    if(!pbuf)
+        return 1;
+    if(mt_type == 1) {
+        memset(pbuf, 0, rlen + 5);
+        pbuf[0] = MT_CTRL_READ_LONG;
+        pbuf[1] = rpt;
+        pbuf[2] = 1;
+        put16le(pbuf + 3, rlen);
+        put16le(pbuf + rlen + 3, bytesum(pbuf, rlen + 3));
+    } else
+        memset(pbuf, 0xA5, rlen + 5);
+    if(ioctl(fd, HXT_IOC_SET_CS, 1)) {
+        free(pbuf);
+        perror("failed asserting CS#");
+        return 1;
+    }
+    usleep(1000);
+    if(write(fd, pbuf, rlen + 5) != rlen + 5) {
+        free(pbuf);
+        perror("failed writing command");
+        return 1;
+    }
+    if(read(fd, pbuf, rlen + 5) != rlen + 5) {
+        free(pbuf);
+        perror("failed reading result");
+        return 1;
+    }
+    if(ioctl(fd, HXT_IOC_SET_CS, 0)) {
+        free(pbuf);
+        perror("failed deasserting CS#");
+        return 1;
+    }
+    usleep(1000);
+    memcpy(buf, pbuf + 3, rlen);
+    free(pbuf);
+    return 0;
+}
+
+static int write_report(int fd, unsigned char rpt, const unsigned char *buf, unsigned len)
+{
+    unsigned char cmd[16] = { MT_CTRL_WRITE_SHORT, rpt, len };
+    memcpy(cmd + 3, buf, len);
+    if(send_z2(fd, cmd, NULL))
+        return 1;
+    cmd[0] = MT_CMD_LAST;
+    cmd[1] = cmd[2] = 0;
+    return send_z2(fd, cmd, NULL);
+}
+
+#if 0
+static int dump_report(int fd, unsigned char rpt, unsigned maxl)
+{
+    unsigned char *pbuf = malloc(maxl);
+    unsigned len = maxl, i;
+    int res;
+    if(!pbuf)
+        return 1;
+    res = read_report(fd, rpt, pbuf, &len);
+    if(res == 0) {
+        fprintf(stderr, "rpt %02x:", rpt);
+        for(i=0; i<len && i<maxl; i++)
+            fprintf(stderr, " %02x", pbuf[i]);
+        fprintf(stderr, " [%d]\n", len);
+    } else if(res == 2)
+        fprintf(stderr, "rpt %02x: unsupported\n", rpt);
+    free(pbuf);
+    return res;
+}
+#endif
+
+#define ANDROID_SOCKET_ENV_PREFIX "ANDROID_SOCKET_"
+static int init_get_control_socket(const char *name)
+{
+    char key[64] = ANDROID_SOCKET_ENV_PREFIX;
+    const char *val;
+    int fd;
+    strncpy(key + sizeof(ANDROID_SOCKET_ENV_PREFIX) - 1, name,  sizeof(key) - sizeof(ANDROID_SOCKET_ENV_PREFIX));
+    key[sizeof(key)-1] = '\0';
+    val = getenv(key);
+    if(!val)
+        return -1;
+    errno = 0;
+    fd = strtol(val, NULL, 10);
+    if(errno)
+        return -1;
+    return fd;
+}
+
+static void await_control(int ctrlfd, int *ctrlconn, int goal)
+{
+    fd_set rfds, wfds;
+    unsigned idx;
+    int nfds, fd, n, state = !goal;
+    char rd;
+
+    while(state != goal) {
+        FD_ZERO(&rfds);
+        FD_ZERO(&wfds);
+        FD_SET(ctrlfd, &rfds);
+        nfds = ctrlfd + 1;
+        for(idx=0; idx<MAX_CTRL_CONN; idx++) {
+            if(ctrlconn[idx] < 0)
+                continue;
+            FD_SET(ctrlconn[idx], &rfds);
+            if(ctrlconn[idx] >= nfds)
+                nfds = ctrlconn[idx] + 1;
+        }
+
+        select(nfds, &rfds, &wfds, NULL, NULL);
+
+        if(FD_ISSET(ctrlfd, &rfds)) {
+            fd = accept(ctrlfd, NULL, NULL);
+            if(fd >= 0) {
+                if(fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK) < 0) {
+                    close(fd);
+                    continue;
+                }
+                for(idx=0; idx<MAX_CTRL_CONN; idx++)
+                    if(ctrlconn[idx] < 0)
+                        break;
+                if(idx >= MAX_CTRL_CONN) {
+                    close(fd);
+                    continue;
+                }
+                ctrlconn[idx] = fd;
+            }
+        }
+
+        for(idx=0; idx<MAX_CTRL_CONN; idx++) {
+            if(ctrlconn[idx] < 0)
+                continue;
+            if(!FD_ISSET(ctrlconn[idx], &rfds))
+                continue;
+
+            while(1) {
+                n = read(ctrlconn[idx], &rd, 1);
+                if(n <= 0) {
+                    if(errno != EAGAIN || !n) {
+                        close(ctrlconn[idx]);
+                        ctrlconn[idx] = -1;
+                        break;
+                    } else
+                        n = 0;
+                }
+                if(n == 0)
+                    break;
+                if(rd == '0' || rd == '1')
+                    state = rd - '0';
+            }
+        }
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    int fd, ctrlfd, ctrlconn[MAX_CTRL_CONN];
+    unsigned char d9[16];
+    struct hxt_metrics hxtm;
+    unsigned len;
+    unsigned retries = 3;
+    FILE *flist;
+    char llist[256], *sep;
+    struct stat statbuf;
+
+    for(len=0; len<MAX_CTRL_CONN; len++)
+        ctrlconn[len] = -1;
+
+    if(argc != 3 && argc != 4) {
+        fprintf(stderr, "usage: hx-touchd <personality> <fwimage> <syscfg>\n"
+                        "       <personality> = C1F5D,2\n"
+                        "       <fwimage> = D10.mtprops\n"
+                        "       <syscfg> = /dev/block/nvme0n3\n"
+                        "   or: hx-touchd <fwlist> <syscfg>\n"
+                        "       <fwlist> = file with <personality> <fwimage> pairs\n");
+        return 1;
+    }
+
+    if(argc == 4) {
+        mt_firmware = mtfw_load_firmware(argv[1], argv[2], argv[3]);
+    } else {
+        flist = fopen(argv[1], "r");
+        if(!flist) {
+            fprintf(stderr, "failed opening firmware list\n");
+            return 1;
+        }
+        while(fgets(llist, sizeof(llist), flist)) {
+            sep = strpbrk(llist, "#\n\r");
+            if(sep)
+                *sep = 0;
+            sep = strpbrk(llist, " \t");
+            if(!sep)
+                continue;
+            *sep = 0;
+            sep ++;
+            while(*sep == ' ' || *sep == '\t')
+                sep ++;
+
+            if(stat(sep, &statbuf))
+                continue;
+            mt_firmware = mtfw_load_firmware(llist, sep, argv[2]);
+            if(mt_firmware)
+                break;
+        }
+        fclose(flist);
+    }
+    if(!mt_firmware) {
+        fprintf(stderr, "failed loading firmware\n");
+        return 1;
+    }
+
+    ctrlfd = init_get_control_socket("hx_touchd_ctrl");
+    if(ctrlfd >= 0) {
+        if(listen(ctrlfd, 3) < 0) {
+            perror("failed to listen on control socket, will not be able to turn off");
+            close(ctrlfd);
+            ctrlfd = -1;
+        }
+        if(fcntl(ctrlfd, F_SETFL, fcntl(ctrlfd, F_GETFL, 0) | O_NONBLOCK) < 0) {
+            perror("failed to set control socket nonblocking, will not be able to turn off");
+            close(ctrlfd);
+            ctrlfd = -1;
+        }
+    } else
+        fprintf(stderr, "control socket not available, will not be able to turn off");
+
+    while(1) {
+retry:
+        fd = open("/dev/hx-touch", O_RDWR);
+        if(fd < 0) {
+            perror("failed opening /dev/hx-touch");
+            return 1;
+        }
+
+        if(bootload(fd))
+            return 1;
+
+        send_wake(fd);
+
+        len = 16;
+        if(read_report(fd, 0xD9, d9, &len)) {
+            if(!retries) {
+                fprintf(stderr, "touch controller did not come up correctly\n");
+                return 1;
+            }
+            retries --;
+            close(fd);
+            sleep(1);
+            goto retry;
+        }
+
+        hxtm.left = (short)get16le(d9 + 8);
+        hxtm.right = (short)get16le(d9 + 12);
+        hxtm.top = (short)get16le(d9 + 14);
+        hxtm.bottom = (short)get16le(d9 + 10);
+        ioctl(fd, HXT_IOC_METRICS, &hxtm);
+
+        switch(mt_type) {
+        case 1:
+            write_report(fd, 0x9D, (unsigned char *)"\x01\x00\x00\x00\x00\x00\x00\x00", 8);
+            write_report(fd, 0xBF, (unsigned char *)"\x9D\x81\x09\x00", 4);
+            write_report(fd, 0xAF, (unsigned char *)"\x00", 1);
+            break;
+        case 2:
+            write_report(fd, 0xAF, (unsigned char *)"\x00", 1);
+            break;
+        }
+
+        ioctl(fd, HXT_IOC_READY);
+
+        await_control(ctrlfd, ctrlconn, 0);
+
+        close(fd);
+
+        await_control(ctrlfd, ctrlconn, 1);
+    }
+
+    return 0;
+}
diff --git a/device/generic/goldfish/hx-touch/hx-touchd.rc b/device/generic/goldfish/hx-touch/hx-touchd.rc
new file mode 100644
index 0000000..7d4e634
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/hx-touchd.rc
@@ -0,0 +1,8 @@
+service hx-touchd /vendor/bin/hw/hx-touchd /vendor/etc/hw/hx-touch.fwlist /dev/block/nvme0n3
+    socket hx-touchd-ctrl stream 0666 0 0 u:object_r:graphics_device:s0
+    class hal
+    user root
+    group root
+
+on boot
+    start hx-touchd
diff --git a/device/generic/goldfish/hx-touch/mtfw/eplist.c b/device/generic/goldfish/hx-touch/mtfw/eplist.c
new file mode 100644
index 0000000..b9a0c56
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/eplist.c
@@ -0,0 +1,290 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Corellium LLC
+ */
+
+#include <mxml.h>
+#include "qdict.h"
+#include "eplist.h"
+
+struct eplist_s {
+    mxml_node_t *xml;
+    qdict *ids;
+};
+
+eplist_t eplist_load(int srctype, void *src)
+{
+    eplist_t epl = calloc(1, sizeof(struct eplist_s));
+    mxml_node_t *xn, **pxn;
+    const char *id;
+
+    if(!epl)
+        return NULL;
+    epl->ids = qdict_new(sizeof(mxml_node_t *));
+    if(!epl->ids) {
+        free(epl);
+        return NULL;
+    }
+
+    switch(srctype) {
+    case EPLIST_LOAD_FILE:
+        epl->xml = mxmlLoadFile(NULL, src, MXML_OPAQUE_CALLBACK);
+        break;
+    case EPLIST_LOAD_STRING:
+        epl->xml = mxmlLoadString(NULL, src, MXML_OPAQUE_CALLBACK);
+        break;
+    default:
+        qdict_free(epl->ids);
+        free(epl);
+        return NULL;
+    }
+
+    if(!epl->xml) {
+        qdict_free(epl->ids);
+        free(epl);
+        return NULL;
+    }
+
+    for(xn=epl->xml; xn; xn=mxmlWalkNext(xn, epl->xml, MXML_DESCEND)) {
+        id = mxmlElementGetAttr(xn, "ID");
+        if(id) {
+            pxn = qdict_find(epl->ids, id, QDICT_ADD);
+            if(pxn)
+                *pxn = xn;
+        }
+    }
+
+    for(xn=epl->xml; xn; xn=mxmlWalkNext(xn, epl->xml, MXML_DESCEND)) {
+        id = mxmlElementGetAttr(xn, "IDREF");
+        if(id) {
+            pxn = qdict_find(epl->ids, id, QDICT_FIND);
+            if(pxn)
+                mxmlSetUserData(xn, *pxn);
+        }
+    }
+
+    return epl;
+}
+
+void eplist_free(eplist_t epl)
+{
+    if(!epl)
+        return;
+    qdict_free(epl->ids);
+    mxmlDelete(epl->xml);
+    free(epl);
+}
+
+int eplist_type(epelem_t ee)
+{
+    mxml_node_t *xn = ee;
+    const char *type;
+    if(!ee)
+        return 0;
+    type = mxmlGetElement(xn);
+    if(!type)
+        return 0;
+    if(!strcmp(type, "array"))
+        return EPLIST_ARRAY;
+    if(!strcmp(type, "dict"))
+        return EPLIST_DICT;
+    if(!strcmp(type, "integer"))
+        return EPLIST_INTEGER;
+    if(!strcmp(type, "string"))
+        return EPLIST_STRING;
+    if(!strcmp(type, "true") || !strcmp(type, "false"))
+        return EPLIST_BOOL;
+    if(!strcmp(type, "data"))
+        return EPLIST_DATA;
+    return 0;
+}
+
+epelem_t eplist_root(eplist_t epl)
+{
+    int type;
+    mxml_node_t *xn = epl->xml;
+    while(xn) {
+        type = eplist_type(xn);
+        if(type)
+            return xn;
+        xn = mxmlWalkNext(xn, epl->xml, MXML_DESCEND);
+    }
+    return NULL;
+}
+
+epelem_t eplist_next(epelem_t ee)
+{
+    mxml_node_t *xn = ee;
+    const char *type;
+    while(xn) {
+        xn = mxmlGetNextSibling(xn);
+        if(!xn)
+            break;
+        type = mxmlGetElement(xn);
+        if(type && strcmp(type, "key"))
+            return xn;
+    }
+    return xn;
+}
+
+epelem_t eplist_dict_find(epelem_t ee, const char *key, int expect_type)
+{
+    int et = eplist_type(ee);
+    mxml_node_t *xn = ee;
+    const char *type, *text;
+    if(et != EPLIST_DICT)
+        return NULL;
+    xn = mxmlGetFirstChild(xn);
+    while(xn) {
+        type = mxmlGetElement(xn);
+        if(!type) {
+            xn = mxmlGetNextSibling(xn);
+            continue;
+        }
+        if(strcmp(type, "key"))
+            return NULL;
+        text = mxmlGetOpaque(xn);
+        xn = eplist_next(xn);
+        if(!xn)
+            return NULL;
+        if(!strcmp(text, key)) {
+            if(expect_type) {
+                et = eplist_type(xn);
+                if(et != expect_type)
+                    return NULL;
+            }
+            return xn;
+        }
+        xn = mxmlGetNextSibling(xn);
+    }
+    return NULL;
+}
+
+epelem_t eplist_array_first(epelem_t ee)
+{
+    int et = eplist_type(ee);
+    mxml_node_t *xn = ee;
+    const char *type;
+    if(et != EPLIST_ARRAY)
+        return NULL;
+    xn = mxmlGetFirstChild(xn);
+    while(xn) {
+        type = mxmlGetElement(xn);
+        if(type)
+            break;
+        xn = mxmlGetNextSibling(xn);
+    }
+    return xn;
+}
+
+static epelem_t eplist_deref(epelem_t ee)
+{
+    mxml_node_t *xn;
+    if(!ee)
+        return NULL;
+    xn = mxmlGetUserData(ee);
+    if(xn)
+        return xn;
+    return ee;
+}
+
+const char *eplist_get_string(epelem_t ee)
+{
+    int et = eplist_type(ee);
+    if(et != EPLIST_STRING)
+        return NULL;
+    return mxmlGetOpaque(eplist_deref(ee));
+}
+
+long long eplist_get_integer(epelem_t ee)
+{
+    int et = eplist_type(ee);
+    const char *text;
+    if(et != EPLIST_INTEGER)
+        return -1ll;
+    text = mxmlGetOpaque(eplist_deref(ee));
+    if(!text)
+        return -1ll;
+    return strtoull(text, NULL, 0);
+}
+
+int eplist_get_bool(epelem_t ee)
+{
+    const char *type;
+    if(!ee)
+        return -1;
+    type = mxmlGetElement(ee);
+    if(!type)
+        return -1;
+    if(!strcmp(type, "false"))
+        return 0;
+    if(!strcmp(type, "true"))
+        return 1;
+    return -1;
+}
+
+static const unsigned char eplist_b64[] = {
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3e, 0xff, 0xff, 0xff, 0x3f,
+    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0xff, 0xff, 0xff, 0x40, 0xff, 0xff,
+    0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
+    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
+    0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+
+void *eplist_get_data(epelem_t ee, unsigned long *psize)
+{
+    int et = eplist_type(ee);
+    unsigned i, ch, b;
+    unsigned long size, nc = 0, np = 0;
+    const unsigned char *text;
+    unsigned char *out;
+    if(et != EPLIST_DATA)
+        return NULL;
+    text = (const unsigned char *)mxmlGetOpaque(eplist_deref(ee));
+    if(!text)
+        return NULL;
+    for(i=0; text[i]; i++) {
+        ch = eplist_b64[text[i]];
+        if(ch < 64) {
+            if(np)
+                return NULL;
+            nc ++;
+        }
+        if(ch == 64)
+            np ++;
+    }
+    if((nc + np) & 3)
+        return NULL;
+    size = (nc * 6) >> 3;
+    out = malloc(size + 1);
+    if(!out)
+        return NULL;
+    nc = np = 0;
+    b = 0;
+    for(i=0; text[i]; i++) {
+        ch = eplist_b64[text[i]];
+        if(ch < 64) {
+            nc += 6;
+            b |= ch << (32 - nc);
+            if(nc >= 8) {
+                out[np ++] = b >> 24;
+                b <<= 8;
+                nc -= 8;
+            }
+        }
+    }
+    out[np] = 0;
+    if(psize)
+        *psize = size;
+    return out;
+}
diff --git a/device/generic/goldfish/hx-touch/mtfw/eplist.h b/device/generic/goldfish/hx-touch/mtfw/eplist.h
new file mode 100644
index 0000000..1d0619d
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/eplist.h
@@ -0,0 +1,35 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Corellium LLC
+ */
+
+#ifndef _EPLIST_H
+#define _EPLIST_H
+
+typedef struct eplist_s *eplist_t;
+typedef void *epelem_t;
+
+#define EPLIST_LOAD_FILE        1
+#define EPLIST_LOAD_STRING      2
+
+eplist_t eplist_load(int srctype, void *src);
+void eplist_free(eplist_t epl);
+
+#define EPLIST_ARRAY            1
+#define EPLIST_DICT             2
+#define EPLIST_STRING           3
+#define EPLIST_INTEGER          4
+#define EPLIST_BOOL             5
+#define EPLIST_DATA             6
+
+int eplist_type(epelem_t ee);
+epelem_t eplist_root(eplist_t epl);
+epelem_t eplist_next(epelem_t ee);
+epelem_t eplist_dict_find(epelem_t ee, const char *key, int expect_type);
+epelem_t eplist_array_first(epelem_t ee);
+const char *eplist_get_string(epelem_t ee);
+long long eplist_get_integer(epelem_t ee);
+int eplist_get_bool(epelem_t ee);
+void *eplist_get_data(epelem_t ee, unsigned long *size);
+
+#endif
diff --git a/device/generic/goldfish/hx-touch/mtfw/mtfw.c b/device/generic/goldfish/hx-touch/mtfw/mtfw.c
new file mode 100644
index 0000000..8cd940c
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/mtfw.c
@@ -0,0 +1,350 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Corellium LLC
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "eplist.h"
+#include "syscfg.h"
+#include "mtfw.h"
+
+#define GEN_1   1
+#define GEN_2   2
+
+static const struct {
+    const char *provider;
+    const char *syscfg;
+} mtfw_providers[] = {
+    { "multi-touch-calibration", "MtCl" },
+    { "orb-gap-cal", "OrbG" },
+    { "orb-force-cal", "OFCl" },
+    { "shape-dynamic-accel-cal", "SDAC" },
+    { "prox-calibration", "PxCl" },
+    { "multi-touch-calibration", "MtCl" } };
+
+static mtfw_item_t *mtfw_item_add(mtfw_item_t ***pptail, unsigned type, void *data, unsigned size, int copy)
+{
+    mtfw_item_t *item = calloc(1, sizeof(mtfw_item_t));
+    if(!item)
+        return NULL;
+    item->type = type;
+    if(copy) {
+        item->data = malloc(size);
+        if(!item->data) {
+            free(item);
+            return NULL;
+        }
+        if(data)
+            memcpy(item->data, data, size);
+        else
+            memset(item->data, 0, size);
+    } else
+        item->data = data;
+    item->size = size;
+    **pptail = item;
+    *pptail = &(item->next);
+    return item;
+}
+
+static inline void mtfw_put16be(uint8_t *buf, uint16_t val)
+{
+    buf[0] = val >> 8;
+    buf[1] = val;
+}
+
+static inline void mtfw_put32xe(uint8_t *buf, uint32_t val)
+{
+    buf[0] = val >> 8;
+    buf[1] = val;
+    buf[2] = val >> 24;
+    buf[3] = val >> 16;
+}
+
+static uint32_t mtfw_sum(uint8_t *buf, unsigned size)
+{
+    uint32_t sum = 0;
+    while(size --) {
+        sum += *buf;
+        buf ++;
+    }
+    return sum;
+}
+
+static mtfw_item_t *mtfw_item_add_regwr(mtfw_item_t ***pptail, uint32_t addr, uint32_t mask, uint32_t val)
+{
+    uint8_t buf[16];
+    mtfw_put16be(&buf[0], 0x1E33);
+    mtfw_put32xe(&buf[2], addr);
+    mtfw_put32xe(&buf[6], mask);
+    mtfw_put32xe(&buf[10], val);
+    mtfw_put16be(&buf[14], mtfw_sum(&buf[2], 12));
+    return mtfw_item_add(pptail, MTFW_WRITE_ACK, buf, sizeof(buf), 1);
+}
+
+static void mtfw_copy16be(uint8_t *dst, uint8_t *src, unsigned len)
+{
+    unsigned i;
+    for(i=0; i<len; i++)
+        dst[i^1] = src[i];
+}
+
+static mtfw_item_t *mtfw_item_add_calload(mtfw_item_t ***pptail, uint32_t addr, void *data, unsigned len)
+{
+    mtfw_item_t *mtfw = mtfw_item_add(pptail, MTFW_WRITE_ACK, NULL, 16 + ((len + 3) & -4), 1);
+    uint8_t *buf;
+
+    if(!mtfw) {
+        free(data);
+        return NULL;
+    }
+    buf = (uint8_t *)mtfw->data;
+
+    mtfw_put32xe(&buf[0], 0x300118E1);
+    mtfw_put16be(&buf[4], (len + 3) >> 2);
+    mtfw_put32xe(&buf[6], addr);
+    mtfw_put16be(&buf[10], mtfw_sum(&buf[4], 6));
+    mtfw_copy16be(&buf[12], data, len);
+    mtfw_put32xe(&buf[12 + ((len + 3) & -4)], mtfw_sum(data, len));
+
+    return mtfw;
+}
+
+static void *mtfw_request_cal(const char *syscfg, const char *name, unsigned long *len)
+{
+    unsigned i;
+    for(i=0; i<sizeof(mtfw_providers)/sizeof(mtfw_providers[0]); i++)
+        if(!strcmp(mtfw_providers[i].provider, name))
+            return syscfg_get(syscfg, mtfw_providers[i].syscfg, len);
+    return NULL;
+}
+
+mtfw_item_t *mtfw_load_firmware(const char *pers, const char *fname, const char *syscfg)
+{
+    mtfw_item_t *head = NULL, **ptail = &head;
+    FILE *f;
+    eplist_t epl = NULL;
+    epelem_t root, fw, fwcfg, seq, seql, act;
+    void *bits, *fwcfgbits = NULL;
+    unsigned long len;
+    unsigned long long addr, mask, val;
+    const char *acts;
+    int mode, i;
+
+    f = fopen(fname, "r");
+    if(!f) {
+        fprintf(stderr, "Failed to open input file.\n");
+        goto fail;
+    }
+    epl = eplist_load(EPLIST_LOAD_FILE, f);
+    fclose(f);
+
+    if(!epl) {
+        fprintf(stderr, "Failed to load input file.\n");
+        goto fail;
+    }
+
+    root = eplist_root(epl);
+    fw = eplist_dict_find(root, pers, EPLIST_DICT);
+    if(!fw) {
+        fprintf(stderr, "Firmware for the specified personality (%s) not found.\n", pers);
+        goto fail;
+    }
+
+    seq = eplist_dict_find(fw, "Constructed Firmware", EPLIST_ARRAY);
+    if(!seq) {
+        seq = eplist_dict_find(fw, "Constructed Firmware", EPLIST_DATA);
+        if(!seq) {
+            fprintf(stderr, "Firmware does not contain preconstructed blobs.\n");
+            goto fail;
+        }
+        mode = GEN_1;
+    } else
+        mode = GEN_2;
+
+    if(!mtfw_item_add(&ptail, MTFW_SET_TYPE, &mode, 4, 1))
+        goto fail;
+
+    switch(mode) {
+    case GEN_1:
+
+        if(!mtfw_item_add(&ptail, MTFW_WRITE, "\x19\xC1", 2, 1))
+            goto fail;
+        for(i=0; i<3; i++)
+            if(!mtfw_item_add(&ptail, MTFW_WRITE, "\x1A\xA1\x18\xE1\x18\xE1\x18\xE1\x18\xE1\x18\xE1\x18\xE1\x18\xE1", 16, 1))
+                goto fail;
+
+        bits = mtfw_request_cal(syscfg, "prox-calibration", &len);
+        if(bits)
+            if(!mtfw_item_add_calload(&ptail, 0x10009600, bits, len))
+                goto fail;
+
+        bits = mtfw_request_cal(syscfg, "multi-touch-calibration", &len);
+        if(!bits) {
+            fprintf(stderr, "Calibration sequence provider unavailable (%s).\n", "multi-touc-calibration");
+            goto fail;
+        }
+        if(!mtfw_item_add_calload(&ptail, 0x10009000, bits, len))
+            goto fail;
+
+        bits = eplist_get_data(seq, &len);
+        if(!bits) {
+            fprintf(stderr, "Preconstructed blob item did not decode correctly.\n");
+            goto fail;
+        }
+        if(!mtfw_item_add(&ptail, MTFW_WRITE_ACK, bits, len, 0)) {
+            free(bits);
+            goto fail;
+        }
+
+        if(!mtfw_item_add_regwr(&ptail, 0x10003060, -1u, 6099))
+            goto fail;
+        if(!mtfw_item_add_regwr(&ptail, 0x1000305c, -1u, 2))
+            goto fail;
+        if(!mtfw_item_add_regwr(&ptail, 0x10003058, -1u, 6))
+            goto fail;
+        if(!mtfw_item_add_regwr(&ptail, 0x10003000, -1u, 3))
+            goto fail;
+        if(!mtfw_item_add_regwr(&ptail, 0x10003518, -1u, 1))
+            goto fail;
+
+        if(!mtfw_item_add(&ptail, MTFW_WRITE_ACK, "\x1F\x01", 2, 1))
+            goto fail;
+        if(!mtfw_item_add(&ptail, MTFW_WRITE, "\x1D\x53\x34\x00\x10\x00\x00\x01\x00\x00\x00\x45", 12, 1))
+            goto fail;
+
+        break;
+
+    case GEN_2:
+        if(!mtfw_item_add(&ptail, MTFW_WRITE, "\x1A\xA1\x18\xE1", 4, 1))
+            goto fail;
+
+        seql = eplist_array_first(seq);
+        while(seql) {
+            if(eplist_type(seql) != EPLIST_DATA) {
+                fprintf(stderr, "Non-data item in preconstructed blob array.\n");
+                goto fail;
+            }
+            bits = eplist_get_data(seql, &len);
+            if(!bits) {
+                fprintf(stderr, "Preconstructed blob item did not decode correctly.\n");
+                goto fail;
+            }
+            if(!mtfw_item_add(&ptail, MTFW_WRITE_ACK, bits, len, 0)) {
+                free(bits);
+                goto fail;
+            }
+            seql = eplist_next(seql);
+        }
+
+        fwcfg = eplist_dict_find(fw, "Firmware Config", EPLIST_DATA);
+        if(!fwcfg) {
+            fprintf(stderr, "Firmware does not contain configuration blob.\n");
+            goto fail;
+        }
+
+        fwcfgbits = eplist_get_data(fwcfg, &len);
+        if(!fwcfgbits) {
+            fprintf(stderr, "Configuration blob did not decode correctly.\n");
+            goto fail;
+        }
+
+        eplist_free(epl);
+
+        epl = eplist_load(EPLIST_LOAD_STRING, fwcfgbits);
+        if(!epl) {
+            fprintf(stderr, "Failed to load configuration blob.\n");
+            goto fail;
+        }
+
+        root = eplist_root(epl);
+
+        seq = eplist_dict_find(root, "Calibration Sequence", EPLIST_ARRAY);
+        if(!seq) {
+            fprintf(stderr, "Failed to find calibration sequence.\n");
+            goto fail;
+        }
+
+        seql = eplist_array_first(seq);
+        while(seql) {
+            if(eplist_type(seql) != EPLIST_DICT) {
+                fprintf(stderr, "Non-dictionary item in calibration sequence array.\n");
+                goto fail;
+            }
+            fw = eplist_dict_find(seql, "Address", EPLIST_INTEGER);
+            if(!fw) {
+                fprintf(stderr, "Incomplete item in calibration sequence array (no address).\n");
+                goto fail;
+            }
+            addr = eplist_get_integer(fw);
+            acts = eplist_get_string(eplist_dict_find(seql, "Provider", EPLIST_STRING));
+            if(!acts) {
+                fprintf(stderr, "Incomplete item in calibration sequence array (no provider).\n");
+                goto fail;
+            }
+            bits = mtfw_request_cal(syscfg, acts, &len);
+            if(!bits) {
+                fprintf(stderr, "Calibration sequence provider unavailable (%s).\n", acts);
+                goto fail;
+            }
+            if(!mtfw_item_add_calload(&ptail, addr, bits, len))
+                goto fail;
+            seql = eplist_next(seql);
+        }
+
+        seq = eplist_dict_find(root, "Boot Sequence", EPLIST_ARRAY);
+        if(!seq) {
+            fprintf(stderr, "Failed to find boot sequence.\n");
+            goto fail;
+        }
+
+        seql = eplist_array_first(seq);
+        while(seql) {
+            if(eplist_type(seql) != EPLIST_DICT) {
+                fprintf(stderr, "Non-dictionary item in boot sequence array.\n");
+                goto fail;
+            }
+            act = eplist_dict_find(seql, "Action", EPLIST_STRING);
+            acts = eplist_get_string(act);
+            if(acts) {
+                if(!strcmp(acts, "RequestCalibration")) {
+                    if(!mtfw_item_add(&ptail, MTFW_WRITE_ACK, "\x1F\x01", 2, 1))
+                        goto fail;
+                } else {
+                    fprintf(stderr, "Unexpected action item (%s) in boot sequence array.\n", acts);
+                    goto fail;
+                }
+            } else {
+                fw = eplist_dict_find(seql, "Address", EPLIST_INTEGER);
+                if(!fw) {
+                    fprintf(stderr, "Unexpected non-action item in boot sequence array.\n");
+                    goto fail;
+                }
+                addr = eplist_get_integer(fw);
+                mask = eplist_get_integer(eplist_dict_find(seql, "Mask", EPLIST_INTEGER));
+                val = eplist_get_integer(eplist_dict_find(seql, "Value", EPLIST_INTEGER));
+                if(!mtfw_item_add_regwr(&ptail, addr, mask, val))
+                    goto fail;
+            }
+            seql = eplist_next(seql);
+        }
+
+        if(!mtfw_item_add(&ptail, MTFW_WAIT_IRQ, NULL, 0, 0))
+            goto fail;
+
+        break;
+    }
+
+    eplist_free(epl);
+    free(fwcfgbits);
+
+    return head;
+
+fail:
+    eplist_free(epl);
+    free(fwcfgbits);
+    return NULL;
+}
diff --git a/device/generic/goldfish/hx-touch/mtfw/mtfw.h b/device/generic/goldfish/hx-touch/mtfw/mtfw.h
new file mode 100644
index 0000000..d28b43a
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/mtfw.h
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Corellium LLC
+ */
+
+#ifndef _MTFW_H
+#define _MTFW_H
+
+#define MTFW_WRITE      1
+#define MTFW_WRITE_ACK  2
+#define MTFW_WAIT_IRQ   3
+#define MTFW_SET_TYPE   4
+
+typedef struct mtfw_item {
+    unsigned type;
+    unsigned char *data;
+    unsigned size;
+    struct mtfw_item *next;
+} mtfw_item_t;
+
+mtfw_item_t *mtfw_load_firmware(const char *pers, const char *fname, const char *syscfg);
+
+#endif
diff --git a/device/generic/goldfish/hx-touch/mtfw/qdict.c b/device/generic/goldfish/hx-touch/mtfw/qdict.c
new file mode 100644
index 0000000..dbeb1d7
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/qdict.c
@@ -0,0 +1,191 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017-20 Corellium LLC
+ */
+
+#define _POSIX_C_SOURCE 200809L
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "qdict.h"
+
+typedef struct qelem_s {
+    unsigned depth;
+    struct qelem_s *left, *right, *parent, **up;
+    char *str;
+} qelem;
+
+struct qdict_s {
+    int size;
+    qelem *root;
+};
+
+qdict *qdict_new(int size)
+{
+    qdict *dict = calloc(1, sizeof(qdict));
+    if(!dict)
+        return dict;
+    dict->size = size;
+    return dict;
+}
+
+static int qdict_delta(qelem *elem)
+{
+    int res = 0;
+    if(elem->left)
+        res -= elem->left->depth + 1;
+    if(elem->right)
+        res += elem->right->depth + 1;
+    return res;
+}
+
+static void qdict_update(qelem *elem)
+{
+    elem->depth = 0;
+    if(elem->left)
+        elem->depth = elem->left->depth + 1;
+    if(elem->right && elem->depth < elem->right->depth + 1)
+        elem->depth = elem->right->depth + 1;
+}
+
+static void qdict_pivot(qelem *root, qelem *pivot)
+{
+    pivot->parent = root->parent;
+    pivot->up = root->up;
+    *(pivot->up) = pivot;
+
+    if(pivot == root->left) {
+        root->left = pivot->right;
+        if(root->left) {
+            root->left->parent = root;
+            root->left->up = &(root->left);
+        }
+
+        root->parent = pivot;
+        root->up = &(pivot->right);
+        pivot->right = root;
+    } else {
+        root->right = pivot->left;
+        if(root->right) {
+            root->right->parent = root;
+            root->right->up = &(root->right);
+        }
+
+        root->parent = pivot;
+        root->up = &(pivot->left);
+        pivot->left = root;
+    }
+
+    qdict_update(root);
+    qdict_update(pivot);
+}
+
+static void qdict_rebalance(qelem *elem)
+{
+    int delta;
+
+    qdict_update(elem);
+
+    for(; elem; elem=elem->parent) {
+        delta = qdict_delta(elem);
+        if(delta < -1 || delta > 1) {
+            if(delta < -2 || delta > 2)
+                return;
+
+            if(delta < -1) {
+                if(qdict_delta(elem->left) > 0)
+                    qdict_pivot(elem->left, elem->left->right);
+                qdict_pivot(elem, elem->left);
+            } else {
+                if(qdict_delta(elem->right) < 0)
+                    qdict_pivot(elem->right, elem->right->left);
+                qdict_pivot(elem, elem->right);
+            }
+            elem = elem->parent;
+        }
+
+        if(!elem || !elem->parent)
+            break;
+
+        qdict_update(elem->parent);
+    }
+}
+
+void *qdict_find(qdict *_dict, const char *str, unsigned mode)
+{
+    qdict *dict = _dict;
+    qelem **pelem = &(dict->root), *parent = NULL;
+    int cmp;
+
+    while(*pelem) {
+        cmp = strcmp(str, (*pelem)->str);
+        if(!cmp) {
+            if(!(mode & QDICT_FIND))
+                return NULL;
+            return (*pelem) + 1;
+        }
+
+        parent = *pelem;
+        if(cmp < 0)
+            pelem = &(*pelem)->left;
+        else
+            pelem = &(*pelem)->right;
+    }
+
+    if(!(mode & QDICT_ADD))
+        return NULL;
+
+    (*pelem) = calloc(1, sizeof(qelem) + dict->size);
+    if(!*pelem)
+        return NULL;
+
+    (*pelem)->str = strdup(str);
+    (*pelem)->up = pelem;
+    (*pelem)->parent = parent;
+
+    parent = *pelem;
+    qdict_rebalance(*pelem);
+
+    return parent + 1;
+}
+
+static void qdict_iter_recurse(qelem *elem, void(*func)(void *param, const char *str, void *elem), void *param)
+{
+    if(elem->left)
+        qdict_iter_recurse(elem->left, func, param);
+    func(param, elem->str, elem + 1);
+    if(elem->right)
+        qdict_iter_recurse(elem->right, func, param);
+}
+
+void qdict_iter(qdict *_dict, void(*func)(void *param, const char *str, void *elem), void *param)
+{
+    qdict *dict = _dict;
+    if(dict->root)
+        qdict_iter_recurse(dict->root, func, param);
+}
+
+const char *qdict_str(void *_elem)
+{
+    qelem *elem = _elem;
+    return elem[-1].str;
+}
+
+static void qdict_free_recurse(qelem *elem)
+{
+    if(elem->left)
+        qdict_free_recurse(elem->left);
+    if(elem->right)
+        qdict_free_recurse(elem->right);
+    free(elem->str);
+    free(elem);
+}
+
+void qdict_free(qdict *_dict)
+{
+    qdict *dict = _dict;
+    if(dict->root)
+        qdict_free_recurse(dict->root);
+    free(dict);
+}
diff --git a/device/generic/goldfish/hx-touch/mtfw/qdict.h b/device/generic/goldfish/hx-touch/mtfw/qdict.h
new file mode 100644
index 0000000..0398a81
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/qdict.h
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017-20 Corellium LLC
+ */
+
+#ifndef _QDICT_H
+#define _QDICT_H
+
+typedef struct qdict_s qdict;
+
+#define QDICT_ADD       1
+#define QDICT_FIND      2
+#define QDICT_ANY       3
+
+qdict *qdict_new(int size);
+void *qdict_find(qdict *dict, const char *str, unsigned mode);
+void qdict_iter(qdict *dict, void(*func)(void *param, const char *str, void *elem), void *param);
+const char *qdict_str(void *elem);
+void qdict_free(qdict *dict);
+
+#endif
diff --git a/device/generic/goldfish/hx-touch/mtfw/syscfg.c b/device/generic/goldfish/hx-touch/mtfw/syscfg.c
new file mode 100644
index 0000000..f03bca5
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/syscfg.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2018-20 Corellium LLC
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define DEFAULT_SIZE 131072
+#define MAX_SIZE 8192
+
+struct syscfg_hdr {
+    char magic[4];
+    uint32_t unk_0; /* 0x7C */
+    uint32_t size;
+    uint32_t version;
+    uint32_t unk_1; /* 0 */
+    uint32_t nkeys;
+};
+
+struct syscfg_key {
+    char name[4];
+    union {
+        uint8_t value[16];
+        struct {
+            char name[4];
+            uint32_t size;
+            uint32_t offset;
+            uint32_t rsvd; /* -1 */
+        } jumbo;
+    };
+};
+
+static void flip4(char *out, char *in)
+{
+    unsigned i;
+    for(i=0; i<4; i++)
+        out[i] = in[3-i];
+}
+
+void *syscfg_get(const char *fname, const char *elem, unsigned long *plen)
+{
+    FILE *f = fopen(fname, "rb");
+    unsigned size, elen = 0;
+    uint8_t *buf;
+    struct syscfg_hdr *hdr;
+    struct syscfg_key *key;
+    unsigned idx;
+    char name[5];
+    void *eval = NULL, *res = NULL;
+
+    if(!f) {
+        fprintf(stderr, "Could not open file '%s'.\n", fname);
+        return NULL;
+    }
+    fseek(f, 0, SEEK_END);
+    size = ftell(f);
+    fseek(f, 0, SEEK_SET);
+
+    if(!size)
+        size = DEFAULT_SIZE;
+
+    buf = malloc(size);
+    if(!buf) {
+        fclose(f);
+        fprintf(stderr, "Could not allocate memory.\n");
+        return NULL;
+    }
+    size = fread(buf, 1, size, f);
+    fclose(f);
+
+    if(size < sizeof(struct syscfg_hdr)) {
+        fprintf(stderr, "SysCfg too small for header.\n");
+        free(buf);
+        return NULL;
+    }
+
+    hdr = (void *)buf;
+    if(memcmp(hdr->magic, "gfCS", 4)) {
+        fprintf(stderr, "SysCfg header magic value incorrect.\n");
+        free(buf);
+        return NULL;
+    }
+    if(hdr->size > size) {
+        fprintf(stderr, "SysCfg header declares %d bytes, but only %d in file.\n", hdr->size, size);
+        free(buf);
+        return NULL;
+    }
+    if(hdr->nkeys * sizeof(struct syscfg_key) + sizeof(struct syscfg_hdr) > hdr->size) {
+        fprintf(stderr, "SysCfg header declares %d entries, does not fit in %d bytes.\n", hdr->nkeys, hdr->size);
+        free(buf);
+        return NULL;
+    }
+
+    key = (void *)(hdr + 1);
+    name[4] = 0;
+    for(idx=0; idx<hdr->nkeys; idx++)
+        if(memcmp(key[idx].name, "BTNC", 4)) {
+            flip4(name, key[idx].name);
+            if(!strcmp(name, elem)) {
+                eval = key[idx].value;
+                elen = sizeof(key[idx].value);
+                break;
+            }
+        } else {
+            flip4(name, key[idx].jumbo.name);
+            if(!strcmp(name, elem)) {
+                if(key[idx].jumbo.offset > hdr->size || key[idx].jumbo.offset + key[idx].jumbo.size > hdr->size) {
+                    fprintf(stderr, "SysCfg jumbo key '%s' does not fit in %d bytes (%d+%d).\n", name, hdr->size, key[idx].jumbo.offset, key[idx].jumbo.size);
+                    free(buf);
+                    return NULL;
+                }
+                eval = buf + key[idx].jumbo.offset;
+                elen = key[idx].jumbo.size;
+                break;
+            }
+        }
+
+    if(eval) {
+        res = malloc(elen);
+        if(!res) {
+            free(buf);
+            fprintf(stderr, "Could not allocate memory.\n");
+            return NULL;
+        }
+
+        memcpy(res, eval, elen);
+    }
+
+    free(buf);
+    if(plen)
+        *plen = elen;
+    return res;
+}
diff --git a/device/generic/goldfish/hx-touch/mtfw/syscfg.h b/device/generic/goldfish/hx-touch/mtfw/syscfg.h
new file mode 100644
index 0000000..9de3e2c
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/syscfg.h
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2018-20 Corellium LLC
+ */
+
+#ifndef _SYSCFG_H
+#define _SYSCFG_H
+
+void *syscfg_get(const char *fname, const char *elem, unsigned long *plen);
+
+#endif
diff --git a/device/generic/goldfish/hx-touch/mtfw/testload.c b/device/generic/goldfish/hx-touch/mtfw/testload.c
new file mode 100644
index 0000000..efdcef7
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mtfw/testload.c
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2020 Corellium LLC
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "mtfw.h"
+
+static const char *type_names[] = { "-", "WRITE", "WRITE_ACK", "WAIT_IRQ" };
+
+int main(void)
+{
+    mtfw_item_t *mtfw, *iter;
+    unsigned i;
+
+    mtfw = mtfw_load_firmware("C1F5D,2", "../D10.mtprops", "../syscfg.bin");
+
+    for(iter=mtfw; iter; iter=iter->next) {
+        printf("%-10s", type_names[iter->type]);
+        if(iter->type == MTFW_WRITE || iter->type == MTFW_WRITE_ACK) {
+            printf("%6d ", iter->size);
+            for(i=0; i<iter->size && i<48; i++)
+                printf(" %02x", iter->data[i]);
+            if(iter->size > i)
+                printf(" ...");
+        }
+        printf("\n");
+    }
+
+    return 0;
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/config.h b/device/generic/goldfish/hx-touch/mxml-3.1/config.h
new file mode 100644
index 0000000..dc8c5e1
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/config.h
@@ -0,0 +1,102 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/*
+ * Configuration file for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#define _GNU_SOURCE
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+#include <ctype.h>
+
+
+/*
+ * Version number...
+ */
+
+#define MXML_VERSION "Mini-XML v3.1"
+
+
+/*
+ * Inline function support...
+ */
+
+#define inline
+
+
+/*
+ * Long long support...
+ */
+
+#define HAVE_LONG_LONG 1
+
+
+/*
+ * Do we have the *printf() functions?
+ */
+
+#define HAVE_SNPRINTF 1
+#define HAVE_VASPRINTF 1
+#define HAVE_VSNPRINTF 1
+
+
+/*
+ * Do we have the strXXX() functions?
+ */
+
+#define HAVE_STRDUP 1
+/* #undef HAVE_STRLCAT */
+/* #undef HAVE_STRLCPY */
+
+
+/*
+ * Do we have threading support?
+ */
+
+#define HAVE_PTHREAD_H 1
+
+
+/*
+ * Define prototypes for string functions as needed...
+ */
+
+#  ifndef HAVE_STRDUP
+extern char	*_mxml_strdup(const char *);
+#    define strdup _mxml_strdup
+#  endif /* !HAVE_STRDUP */
+
+#  ifndef HAVE_STRLCAT
+extern size_t	_mxml_strlcat(char *, const char *, size_t);
+#    define strlcat _mxml_strlcat
+#  endif /* !HAVE_STRLCAT */
+
+#  ifndef HAVE_STRLCPY
+extern size_t	_mxml_strlcpy(char *, const char *, size_t);
+#    define strlcpy _mxml_strlcpy
+#  endif /* !HAVE_STRLCPY */
+
+extern char	*_mxml_strdupf(const char *, ...);
+extern char	*_mxml_vstrdupf(const char *, va_list);
+
+#  ifndef HAVE_SNPRINTF
+extern int	_mxml_snprintf(char *, size_t, const char *, ...);
+#    define snprintf _mxml_snprintf
+#  endif /* !HAVE_SNPRINTF */
+
+#  ifndef HAVE_VSNPRINTF
+extern int	_mxml_vsnprintf(char *, size_t, const char *, va_list);
+#    define vsnprintf _mxml_vsnprintf
+#  endif /* !HAVE_VSNPRINTF */
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-attr.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-attr.c
new file mode 100644
index 0000000..d8a8da4
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-attr.c
@@ -0,0 +1,345 @@
+/*
+ * Attribute support code for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml-private.h"
+
+
+/*
+ * Local functions...
+ */
+
+static int	mxml_set_attr(mxml_node_t *node, const char *name, char *value);
+
+
+/*
+ * 'mxmlElementDeleteAttr()' - Delete an attribute.
+ *
+ * @since Mini-XML 2.4@
+ */
+
+void
+mxmlElementDeleteAttr(mxml_node_t *node,/* I - Element */
+                      const char  *name)/* I - Attribute name */
+{
+  int		i;			/* Looping var */
+  _mxml_attr_t	*attr;			/* Cirrent attribute */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlElementDeleteAttr(node=%p, name=\"%s\")\n",
+          node, name ? name : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return;
+
+ /*
+  * Look for the attribute...
+  */
+
+  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+       i > 0;
+       i --, attr ++)
+  {
+#ifdef DEBUG
+    printf("    %s=\"%s\"\n", attr->name, attr->value);
+#endif /* DEBUG */
+
+    if (!strcmp(attr->name, name))
+    {
+     /*
+      * Delete this attribute...
+      */
+
+      free(attr->name);
+      free(attr->value);
+
+      i --;
+      if (i > 0)
+        memmove(attr, attr + 1, i * sizeof(_mxml_attr_t));
+
+      node->value.element.num_attrs --;
+
+      if (node->value.element.num_attrs == 0)
+        free(node->value.element.attrs);
+      return;
+    }
+  }
+}
+
+
+/*
+ * 'mxmlElementGetAttr()' - Get an attribute.
+ *
+ * This function returns @code NULL@ if the node is not an element or the
+ * named attribute does not exist.
+ */
+
+const char *				/* O - Attribute value or @code NULL@ */
+mxmlElementGetAttr(mxml_node_t *node,	/* I - Element node */
+                   const char  *name)	/* I - Name of attribute */
+{
+  int		i;			/* Looping var */
+  _mxml_attr_t	*attr;			/* Cirrent attribute */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlElementGetAttr(node=%p, name=\"%s\")\n",
+          node, name ? name : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return (NULL);
+
+ /*
+  * Look for the attribute...
+  */
+
+  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+       i > 0;
+       i --, attr ++)
+  {
+#ifdef DEBUG
+    printf("    %s=\"%s\"\n", attr->name, attr->value);
+#endif /* DEBUG */
+
+    if (!strcmp(attr->name, name))
+    {
+#ifdef DEBUG
+      printf("    Returning \"%s\"!\n", attr->value);
+#endif /* DEBUG */
+      return (attr->value);
+    }
+  }
+
+ /*
+  * Didn't find attribute, so return NULL...
+  */
+
+#ifdef DEBUG
+  puts("    Returning NULL!\n");
+#endif /* DEBUG */
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxmlElementGetAttrByIndex()' - Get an element attribute by index.
+ *
+ * The index ("idx") is 0-based.  @code NULL@ is returned if the specified index
+ * is out of range.
+ *
+ * @since Mini-XML 2.11@
+ */
+
+const char *                            /* O - Attribute value */
+mxmlElementGetAttrByIndex(
+    mxml_node_t *node,                  /* I - Node */
+    int         idx,                    /* I - Attribute index, starting at 0 */
+    const char  **name)                 /* O - Attribute name */
+{
+  if (!node || node->type != MXML_ELEMENT || idx < 0 || idx >= node->value.element.num_attrs)
+    return (NULL);
+
+  if (name)
+    *name = node->value.element.attrs[idx].name;
+
+  return (node->value.element.attrs[idx].value);
+}
+
+
+/*
+ * 'mxmlElementGetAttrCount()' - Get the number of element attributes.
+ *
+ * @since Mini-XML 2.11@
+ */
+
+int                                     /* O - Number of attributes */
+mxmlElementGetAttrCount(
+    mxml_node_t *node)                  /* I - Node */
+{
+  if (node && node->type == MXML_ELEMENT)
+    return (node->value.element.num_attrs);
+  else
+    return (0);
+}
+
+
+/*
+ * 'mxmlElementSetAttr()' - Set an attribute.
+ *
+ * If the named attribute already exists, the value of the attribute
+ * is replaced by the new string value. The string value is copied
+ * into the element node. This function does nothing if the node is
+ * not an element.
+ */
+
+void
+mxmlElementSetAttr(mxml_node_t *node,	/* I - Element node */
+                   const char  *name,	/* I - Name of attribute */
+                   const char  *value)	/* I - Attribute value */
+{
+  char	*valuec;			/* Copy of value */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlElementSetAttr(node=%p, name=\"%s\", value=\"%s\")\n",
+          node, name ? name : "(null)", value ? value : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return;
+
+  if (value)
+    valuec = strdup(value);
+  else
+    valuec = NULL;
+
+  if (mxml_set_attr(node, name, valuec))
+    free(valuec);
+}
+
+
+/*
+ * 'mxmlElementSetAttrf()' - Set an attribute with a formatted value.
+ *
+ * If the named attribute already exists, the value of the attribute
+ * is replaced by the new formatted string. The formatted string value is
+ * copied into the element node. This function does nothing if the node
+ * is not an element.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+void
+mxmlElementSetAttrf(mxml_node_t *node,	/* I - Element node */
+                    const char  *name,	/* I - Name of attribute */
+                    const char  *format,/* I - Printf-style attribute value */
+		    ...)		/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Argument pointer */
+  char		*value;			/* Value */
+
+
+#ifdef DEBUG
+  fprintf(stderr,
+          "mxmlElementSetAttrf(node=%p, name=\"%s\", format=\"%s\", ...)\n",
+          node, name ? name : "(null)", format ? format : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name || !format)
+    return;
+
+ /*
+  * Format the value...
+  */
+
+  va_start(ap, format);
+  value = _mxml_vstrdupf(format, ap);
+  va_end(ap);
+
+  if (!value)
+    mxml_error("Unable to allocate memory for attribute '%s' in element %s!",
+               name, node->value.element.name);
+  else if (mxml_set_attr(node, name, value))
+    free(value);
+}
+
+
+/*
+ * 'mxml_set_attr()' - Set or add an attribute name/value pair.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_set_attr(mxml_node_t *node,	/* I - Element node */
+              const char  *name,	/* I - Attribute name */
+              char        *value)	/* I - Attribute value */
+{
+  int		i;			/* Looping var */
+  _mxml_attr_t	*attr;			/* New attribute */
+
+
+ /*
+  * Look for the attribute...
+  */
+
+  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+       i > 0;
+       i --, attr ++)
+    if (!strcmp(attr->name, name))
+    {
+     /*
+      * Free the old value as needed...
+      */
+
+      if (attr->value)
+        free(attr->value);
+
+      attr->value = value;
+
+      return (0);
+    }
+
+ /*
+  * Add a new attribute...
+  */
+
+  if (node->value.element.num_attrs == 0)
+    attr = malloc(sizeof(_mxml_attr_t));
+  else
+    attr = realloc(node->value.element.attrs,
+                   (node->value.element.num_attrs + 1) * sizeof(_mxml_attr_t));
+
+  if (!attr)
+  {
+    mxml_error("Unable to allocate memory for attribute '%s' in element %s!",
+               name, node->value.element.name);
+    return (-1);
+  }
+
+  node->value.element.attrs = attr;
+  attr += node->value.element.num_attrs;
+
+  if ((attr->name = strdup(name)) == NULL)
+  {
+    mxml_error("Unable to allocate memory for attribute '%s' in element %s!",
+               name, node->value.element.name);
+    return (-1);
+  }
+
+  attr->value = value;
+
+  node->value.element.num_attrs ++;
+
+  return (0);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-entity.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-entity.c
new file mode 100644
index 0000000..3b17d1e
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-entity.c
@@ -0,0 +1,438 @@
+/*
+ * Character entity support code for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "mxml-private.h"
+
+
+/*
+ * 'mxmlEntityAddCallback()' - Add a callback to convert entities to Unicode.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlEntityAddCallback(
+    mxml_entity_cb_t cb)		/* I - Callback function to add */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  if (global->num_entity_cbs < (int)(sizeof(global->entity_cbs) / sizeof(global->entity_cbs[0])))
+  {
+    global->entity_cbs[global->num_entity_cbs] = cb;
+    global->num_entity_cbs ++;
+
+    return (0);
+  }
+  else
+  {
+    mxml_error("Unable to add entity callback!");
+
+    return (-1);
+  }
+}
+
+
+/*
+ * 'mxmlEntityGetName()' - Get the name that corresponds to the character value.
+ *
+ * If val does not need to be represented by a named entity, @code NULL@ is returned.
+ */
+
+const char *				/* O - Entity name or @code NULL@ */
+mxmlEntityGetName(int val)		/* I - Character value */
+{
+  switch (val)
+  {
+    case '&' :
+        return ("amp");
+
+    case '<' :
+        return ("lt");
+
+    case '>' :
+        return ("gt");
+
+    case '\"' :
+        return ("quot");
+
+    default :
+        return (NULL);
+  }
+}
+
+
+/*
+ * 'mxmlEntityGetValue()' - Get the character corresponding to a named entity.
+ *
+ * The entity name can also be a numeric constant. -1 is returned if the
+ * name is not known.
+ */
+
+int					/* O - Character value or -1 on error */
+mxmlEntityGetValue(const char *name)	/* I - Entity name */
+{
+  int		i;			/* Looping var */
+  int		ch;			/* Character value */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  for (i = 0; i < global->num_entity_cbs; i ++)
+    if ((ch = (global->entity_cbs[i])(name)) >= 0)
+      return (ch);
+
+  return (-1);
+}
+
+
+/*
+ * 'mxmlEntityRemoveCallback()' - Remove a callback.
+ */
+
+void
+mxmlEntityRemoveCallback(
+    mxml_entity_cb_t cb)		/* I - Callback function to remove */
+{
+  int		i;			/* Looping var */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  for (i = 0; i < global->num_entity_cbs; i ++)
+    if (cb == global->entity_cbs[i])
+    {
+     /*
+      * Remove the callback...
+      */
+
+      global->num_entity_cbs --;
+
+      if (i < global->num_entity_cbs)
+        memmove(global->entity_cbs + i, global->entity_cbs + i + 1,
+	        (global->num_entity_cbs - i) * sizeof(global->entity_cbs[0]));
+
+      return;
+    }
+}
+
+
+/*
+ * '_mxml_entity_cb()' - Lookup standard (X)HTML entities.
+ */
+
+int					/* O - Unicode value or -1 */
+_mxml_entity_cb(const char *name)	/* I - Entity name */
+{
+  int	diff,				/* Difference between names */
+	current,			/* Current entity in search */
+	first,				/* First entity in search */
+	last;				/* Last entity in search */
+  static const struct
+  {
+    const char	*name;			/* Entity name */
+    int		val;			/* Character value */
+  }	entities[] =
+  {
+    { "AElig",		198 },
+    { "Aacute",		193 },
+    { "Acirc",		194 },
+    { "Agrave",		192 },
+    { "Alpha",		913 },
+    { "Aring",		197 },
+    { "Atilde",		195 },
+    { "Auml",		196 },
+    { "Beta",		914 },
+    { "Ccedil",		199 },
+    { "Chi",		935 },
+    { "Dagger",		8225 },
+    { "Delta",		916 },
+    { "Dstrok",		208 },
+    { "ETH",		208 },
+    { "Eacute",		201 },
+    { "Ecirc",		202 },
+    { "Egrave",		200 },
+    { "Epsilon",	917 },
+    { "Eta",		919 },
+    { "Euml",		203 },
+    { "Gamma",		915 },
+    { "Iacute",		205 },
+    { "Icirc",		206 },
+    { "Igrave",		204 },
+    { "Iota",		921 },
+    { "Iuml",		207 },
+    { "Kappa",		922 },
+    { "Lambda",		923 },
+    { "Mu",		924 },
+    { "Ntilde",		209 },
+    { "Nu",		925 },
+    { "OElig",		338 },
+    { "Oacute",		211 },
+    { "Ocirc",		212 },
+    { "Ograve",		210 },
+    { "Omega",		937 },
+    { "Omicron",	927 },
+    { "Oslash",		216 },
+    { "Otilde",		213 },
+    { "Ouml",		214 },
+    { "Phi",		934 },
+    { "Pi",		928 },
+    { "Prime",		8243 },
+    { "Psi",		936 },
+    { "Rho",		929 },
+    { "Scaron",		352 },
+    { "Sigma",		931 },
+    { "THORN",		222 },
+    { "Tau",		932 },
+    { "Theta",		920 },
+    { "Uacute",		218 },
+    { "Ucirc",		219 },
+    { "Ugrave",		217 },
+    { "Upsilon",	933 },
+    { "Uuml",		220 },
+    { "Xi",		926 },
+    { "Yacute",		221 },
+    { "Yuml",		376 },
+    { "Zeta",		918 },
+    { "aacute",		225 },
+    { "acirc",		226 },
+    { "acute",		180 },
+    { "aelig",		230 },
+    { "agrave",		224 },
+    { "alefsym",	8501 },
+    { "alpha",		945 },
+    { "amp",		'&' },
+    { "and",		8743 },
+    { "ang",		8736 },
+    { "apos",           '\'' },
+    { "aring",		229 },
+    { "asymp",		8776 },
+    { "atilde",		227 },
+    { "auml",		228 },
+    { "bdquo",		8222 },
+    { "beta",		946 },
+    { "brkbar",		166 },
+    { "brvbar",		166 },
+    { "bull",		8226 },
+    { "cap",		8745 },
+    { "ccedil",		231 },
+    { "cedil",		184 },
+    { "cent",		162 },
+    { "chi",		967 },
+    { "circ",		710 },
+    { "clubs",		9827 },
+    { "cong",		8773 },
+    { "copy",		169 },
+    { "crarr",		8629 },
+    { "cup",		8746 },
+    { "curren",		164 },
+    { "dArr",		8659 },
+    { "dagger",		8224 },
+    { "darr",		8595 },
+    { "deg",		176 },
+    { "delta",		948 },
+    { "diams",		9830 },
+    { "die",		168 },
+    { "divide",		247 },
+    { "eacute",		233 },
+    { "ecirc",		234 },
+    { "egrave",		232 },
+    { "empty",		8709 },
+    { "emsp",		8195 },
+    { "ensp",		8194 },
+    { "epsilon",	949 },
+    { "equiv",		8801 },
+    { "eta",		951 },
+    { "eth",		240 },
+    { "euml",		235 },
+    { "euro",		8364 },
+    { "exist",		8707 },
+    { "fnof",		402 },
+    { "forall",		8704 },
+    { "frac12",		189 },
+    { "frac14",		188 },
+    { "frac34",		190 },
+    { "frasl",		8260 },
+    { "gamma",		947 },
+    { "ge",		8805 },
+    { "gt",		'>' },
+    { "hArr",		8660 },
+    { "harr",		8596 },
+    { "hearts",		9829 },
+    { "hellip",		8230 },
+    { "hibar",		175 },
+    { "iacute",		237 },
+    { "icirc",		238 },
+    { "iexcl",		161 },
+    { "igrave",		236 },
+    { "image",		8465 },
+    { "infin",		8734 },
+    { "int",		8747 },
+    { "iota",		953 },
+    { "iquest",		191 },
+    { "isin",		8712 },
+    { "iuml",		239 },
+    { "kappa",		954 },
+    { "lArr",		8656 },
+    { "lambda",		955 },
+    { "lang",		9001 },
+    { "laquo",		171 },
+    { "larr",		8592 },
+    { "lceil",		8968 },
+    { "ldquo",		8220 },
+    { "le",		8804 },
+    { "lfloor",		8970 },
+    { "lowast",		8727 },
+    { "loz",		9674 },
+    { "lrm",		8206 },
+    { "lsaquo",		8249 },
+    { "lsquo",		8216 },
+    { "lt",		'<' },
+    { "macr",		175 },
+    { "mdash",		8212 },
+    { "micro",		181 },
+    { "middot",		183 },
+    { "minus",		8722 },
+    { "mu",		956 },
+    { "nabla",		8711 },
+    { "nbsp",		160 },
+    { "ndash",		8211 },
+    { "ne",		8800 },
+    { "ni",		8715 },
+    { "not",		172 },
+    { "notin",		8713 },
+    { "nsub",		8836 },
+    { "ntilde",		241 },
+    { "nu",		957 },
+    { "oacute",		243 },
+    { "ocirc",		244 },
+    { "oelig",		339 },
+    { "ograve",		242 },
+    { "oline",		8254 },
+    { "omega",		969 },
+    { "omicron",	959 },
+    { "oplus",		8853 },
+    { "or",		8744 },
+    { "ordf",		170 },
+    { "ordm",		186 },
+    { "oslash",		248 },
+    { "otilde",		245 },
+    { "otimes",		8855 },
+    { "ouml",		246 },
+    { "para",		182 },
+    { "part",		8706 },
+    { "permil",		8240 },
+    { "perp",		8869 },
+    { "phi",		966 },
+    { "pi",		960 },
+    { "piv",		982 },
+    { "plusmn",		177 },
+    { "pound",		163 },
+    { "prime",		8242 },
+    { "prod",		8719 },
+    { "prop",		8733 },
+    { "psi",		968 },
+    { "quot",		'\"' },
+    { "rArr",		8658 },
+    { "radic",		8730 },
+    { "rang",		9002 },
+    { "raquo",		187 },
+    { "rarr",		8594 },
+    { "rceil",		8969 },
+    { "rdquo",		8221 },
+    { "real",		8476 },
+    { "reg",		174 },
+    { "rfloor",		8971 },
+    { "rho",		961 },
+    { "rlm",		8207 },
+    { "rsaquo",		8250 },
+    { "rsquo",		8217 },
+    { "sbquo",		8218 },
+    { "scaron",		353 },
+    { "sdot",		8901 },
+    { "sect",		167 },
+    { "shy",		173 },
+    { "sigma",		963 },
+    { "sigmaf",		962 },
+    { "sim",		8764 },
+    { "spades",		9824 },
+    { "sub",		8834 },
+    { "sube",		8838 },
+    { "sum",		8721 },
+    { "sup",		8835 },
+    { "sup1",		185 },
+    { "sup2",		178 },
+    { "sup3",		179 },
+    { "supe",		8839 },
+    { "szlig",		223 },
+    { "tau",		964 },
+    { "there4",		8756 },
+    { "theta",		952 },
+    { "thetasym",	977 },
+    { "thinsp",		8201 },
+    { "thorn",		254 },
+    { "tilde",		732 },
+    { "times",		215 },
+    { "trade",		8482 },
+    { "uArr",		8657 },
+    { "uacute",		250 },
+    { "uarr",		8593 },
+    { "ucirc",		251 },
+    { "ugrave",		249 },
+    { "uml",		168 },
+    { "upsih",		978 },
+    { "upsilon",	965 },
+    { "uuml",		252 },
+    { "weierp",		8472 },
+    { "xi",		958 },
+    { "yacute",		253 },
+    { "yen",		165 },
+    { "yuml",		255 },
+    { "zeta",		950 },
+    { "zwj",		8205 },
+    { "zwnj",		8204 }
+  };
+
+
+ /*
+  * Do a binary search for the named entity...
+  */
+
+  first = 0;
+  last  = (int)(sizeof(entities) / sizeof(entities[0]) - 1);
+
+  while ((last - first) > 1)
+  {
+    current = (first + last) / 2;
+
+    if ((diff = strcmp(name, entities[current].name)) == 0)
+      return (entities[current].val);
+    else if (diff < 0)
+      last = current;
+    else
+      first = current;
+  }
+
+ /*
+  * If we get here, there is a small chance that there is still
+  * a match; check first and last...
+  */
+
+  if (!strcmp(name, entities[first].name))
+    return (entities[first].val);
+  else if (!strcmp(name, entities[last].name))
+    return (entities[last].val);
+  else
+    return (-1);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-file.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-file.c
new file mode 100644
index 0000000..91250d5
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-file.c
@@ -0,0 +1,3151 @@
+/*
+ * File loading code for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#ifndef _WIN32
+#  include <unistd.h>
+#endif /* !_WIN32 */
+#include "mxml-private.h"
+
+
+/*
+ * Character encoding...
+ */
+
+#define ENCODE_UTF8	0		/* UTF-8 */
+#define ENCODE_UTF16BE	1		/* UTF-16 Big-Endian */
+#define ENCODE_UTF16LE	2		/* UTF-16 Little-Endian */
+
+
+/*
+ * Macro to test for a bad XML character...
+ */
+
+#define mxml_bad_char(ch) ((ch) < ' ' && (ch) != '\n' && (ch) != '\r' && (ch) != '\t')
+
+
+/*
+ * Types and structures...
+ */
+
+typedef int (*_mxml_getc_cb_t)(void *, int *);
+typedef int (*_mxml_putc_cb_t)(int, void *);
+
+typedef struct _mxml_fdbuf_s		/**** File descriptor buffer ****/
+{
+  int		fd;			/* File descriptor */
+  unsigned char	*current,		/* Current position in buffer */
+		*end,			/* End of buffer */
+		buffer[8192];		/* Character buffer */
+} _mxml_fdbuf_t;
+
+
+/*
+ * Local functions...
+ */
+
+static int		mxml_add_char(int ch, char **ptr, char **buffer, int *bufsize);
+static int		mxml_fd_getc(void *p, int *encoding);
+static int		mxml_fd_putc(int ch, void *p);
+static int		mxml_fd_read(_mxml_fdbuf_t *buf);
+static int		mxml_fd_write(_mxml_fdbuf_t *buf);
+static int		mxml_file_getc(void *p, int *encoding);
+static int		mxml_file_putc(int ch, void *p);
+static int		mxml_get_entity(mxml_node_t *parent, void *p, int *encoding, _mxml_getc_cb_t getc_cb, int *line);
+static inline int	mxml_isspace(int ch)
+			{
+			  return (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n');
+			}
+static mxml_node_t	*mxml_load_data(mxml_node_t *top, void *p, mxml_load_cb_t cb, _mxml_getc_cb_t getc_cb, mxml_sax_cb_t sax_cb, void *sax_data);
+static int		mxml_parse_element(mxml_node_t *node, void *p, int *encoding, _mxml_getc_cb_t getc_cb, int *line);
+static int		mxml_string_getc(void *p, int *encoding);
+static int		mxml_string_putc(int ch, void *p);
+static int		mxml_write_name(const char *s, void *p, _mxml_putc_cb_t putc_cb);
+static int		mxml_write_node(mxml_node_t *node, void *p, mxml_save_cb_t cb, int col, _mxml_putc_cb_t putc_cb, _mxml_global_t *global);
+static int		mxml_write_string(const char *s, void *p, _mxml_putc_cb_t putc_cb);
+static int		mxml_write_ws(mxml_node_t *node, void *p, mxml_save_cb_t cb, int ws, int col, _mxml_putc_cb_t putc_cb);
+
+
+/*
+ * 'mxmlLoadFd()' - Load a file descriptor into an XML node tree.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * The constants @code MXML_INTEGER_CALLBACK@, @code MXML_OPAQUE_CALLBACK@,
+ * @code MXML_REAL_CALLBACK@, and @code MXML_TEXT_CALLBACK@ are defined for
+ * loading child (data) nodes of the specified type.
+ *
+ * Note: The most common programming error when using the Mini-XML library is
+ * to load an XML file using the @code MXML_TEXT_CALLBACK@, which returns inline
+ * text as a series of whitespace-delimited words, instead of using the
+ * @code MXML_OPAQUE_CALLBACK@ which returns the inline text as a single string
+ * (including whitespace).
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if the file could not be read. */
+mxmlLoadFd(mxml_node_t    *top,		/* I - Top node */
+           int            fd,		/* I - File descriptor to read from */
+           mxml_load_cb_t cb)		/* I - Callback function or constant */
+{
+  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
+
+
+ /*
+  * Initialize the file descriptor buffer...
+  */
+
+  buf.fd      = fd;
+  buf.current = buf.buffer;
+  buf.end     = buf.buffer;
+
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, MXML_NO_CALLBACK, NULL));
+}
+
+
+/*
+ * 'mxmlLoadFile()' - Load a file into an XML node tree.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * The constants @code MXML_INTEGER_CALLBACK@, @code MXML_OPAQUE_CALLBACK@,
+ * @code MXML_REAL_CALLBACK@, and @code MXML_TEXT_CALLBACK@ are defined for
+ * loading child (data) nodes of the specified type.
+ *
+ * Note: The most common programming error when using the Mini-XML library is
+ * to load an XML file using the @code MXML_TEXT_CALLBACK@, which returns inline
+ * text as a series of whitespace-delimited words, instead of using the
+ * @code MXML_OPAQUE_CALLBACK@ which returns the inline text as a single string
+ * (including whitespace).
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if the file could not be read. */
+mxmlLoadFile(mxml_node_t    *top,	/* I - Top node */
+             FILE           *fp,	/* I - File to read from */
+             mxml_load_cb_t cb)		/* I - Callback function or constant */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, fp, cb, mxml_file_getc, MXML_NO_CALLBACK, NULL));
+}
+
+
+/*
+ * 'mxmlLoadString()' - Load a string into an XML node tree.
+ *
+ * The nodes in the specified string are added to the specified top node.
+ * If no top node is provided, the XML string MUST be well-formed with a
+ * single parent node like <?xml> for the entire string. The callback
+ * function returns the value type that should be used for child nodes.
+ * The constants @code MXML_INTEGER_CALLBACK@, @code MXML_OPAQUE_CALLBACK@,
+ * @code MXML_REAL_CALLBACK@, and @code MXML_TEXT_CALLBACK@ are defined for
+ * loading child (data) nodes of the specified type.
+ *
+ * Note: The most common programming error when using the Mini-XML library is
+ * to load an XML file using the @code MXML_TEXT_CALLBACK@, which returns inline
+ * text as a series of whitespace-delimited words, instead of using the
+ * @code MXML_OPAQUE_CALLBACK@ which returns the inline text as a single string
+ * (including whitespace).
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if the string has errors. */
+mxmlLoadString(mxml_node_t    *top,	/* I - Top node */
+               const char     *s,	/* I - String to load */
+               mxml_load_cb_t cb)	/* I - Callback function or constant */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, MXML_NO_CALLBACK,
+                         NULL));
+}
+
+
+/*
+ * 'mxmlSaveAllocString()' - Save an XML tree to an allocated string.
+ *
+ * This function returns a pointer to a string containing the textual
+ * representation of the XML node tree.  The string should be freed
+ * using the free() function when you are done with it.  @code NULL@ is returned
+ * if the node would produce an empty string or if the string cannot be
+ * allocated.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element.  If @code MXML_NO_CALLBACK@
+ * is specified, whitespace will only be added before @code MXML_TEXT@ nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+char *					/* O - Allocated string or @code NULL@ */
+mxmlSaveAllocString(
+    mxml_node_t    *node,		/* I - Node to write */
+    mxml_save_cb_t cb)			/* I - Whitespace callback or @code MXML_NO_CALLBACK@ */
+{
+  int	bytes;				/* Required bytes */
+  char	buffer[8192];			/* Temporary buffer */
+  char	*s;				/* Allocated string */
+
+
+ /*
+  * Write the node to the temporary buffer...
+  */
+
+  bytes = mxmlSaveString(node, buffer, sizeof(buffer), cb);
+
+  if (bytes <= 0)
+    return (NULL);
+
+  if (bytes < (int)(sizeof(buffer) - 1))
+  {
+   /*
+    * Node fit inside the buffer, so just duplicate that string and
+    * return...
+    */
+
+    return (strdup(buffer));
+  }
+
+ /*
+  * Allocate a buffer of the required size and save the node to the
+  * new buffer...
+  */
+
+  if ((s = malloc(bytes + 1)) == NULL)
+    return (NULL);
+
+  mxmlSaveString(node, s, bytes + 1, cb);
+
+ /*
+  * Return the allocated string...
+  */
+
+  return (s);
+}
+
+
+/*
+ * 'mxmlSaveFd()' - Save an XML tree to a file descriptor.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If @code MXML_NO_CALLBACK@
+ * is specified, whitespace will only be added before @code MXML_TEXT@ nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+int					/* O - 0 on success, -1 on error. */
+mxmlSaveFd(mxml_node_t    *node,	/* I - Node to write */
+           int            fd,		/* I - File descriptor to write to */
+	   mxml_save_cb_t cb)		/* I - Whitespace callback or @code MXML_NO_CALLBACK@ */
+{
+  int		col;			/* Final column */
+  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Initialize the file descriptor buffer...
+  */
+
+  buf.fd      = fd;
+  buf.current = buf.buffer;
+  buf.end     = buf.buffer + sizeof(buf.buffer);
+
+ /*
+  * Write the node...
+  */
+
+  if ((col = mxml_write_node(node, &buf, cb, 0, mxml_fd_putc, global)) < 0)
+    return (-1);
+
+  if (col > 0)
+    if (mxml_fd_putc('\n', &buf) < 0)
+      return (-1);
+
+ /*
+  * Flush and return...
+  */
+
+  return (mxml_fd_write(&buf));
+}
+
+
+/*
+ * 'mxmlSaveFile()' - Save an XML tree to a file.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If @code MXML_NO_CALLBACK@
+ * is specified, whitespace will only be added before @code MXML_TEXT@ nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+int					/* O - 0 on success, -1 on error. */
+mxmlSaveFile(mxml_node_t    *node,	/* I - Node to write */
+             FILE           *fp,	/* I - File to write to */
+	     mxml_save_cb_t cb)		/* I - Whitespace callback or @code MXML_NO_CALLBACK@ */
+{
+  int	col;				/* Final column */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Write the node...
+  */
+
+  if ((col = mxml_write_node(node, fp, cb, 0, mxml_file_putc, global)) < 0)
+    return (-1);
+
+  if (col > 0)
+    if (putc('\n', fp) < 0)
+      return (-1);
+
+ /*
+  * Return 0 (success)...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSaveString()' - Save an XML node tree to a string.
+ *
+ * This function returns the total number of bytes that would be
+ * required for the string but only copies (bufsize - 1) characters
+ * into the specified buffer.
+ *
+ * The callback argument specifies a function that returns a whitespace
+ * string or NULL before and after each element. If @code MXML_NO_CALLBACK@
+ * is specified, whitespace will only be added before @code MXML_TEXT@ nodes
+ * with leading whitespace and before attribute names inside opening
+ * element tags.
+ */
+
+int					/* O - Size of string */
+mxmlSaveString(mxml_node_t    *node,	/* I - Node to write */
+               char           *buffer,	/* I - String buffer */
+               int            bufsize,	/* I - Size of string buffer */
+               mxml_save_cb_t cb)	/* I - Whitespace callback or @code MXML_NO_CALLBACK@ */
+{
+  int	col;				/* Final column */
+  char	*ptr[2];			/* Pointers for putc_cb */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Write the node...
+  */
+
+  ptr[0] = buffer;
+  ptr[1] = buffer + bufsize;
+
+  if ((col = mxml_write_node(node, ptr, cb, 0, mxml_string_putc, global)) < 0)
+    return (-1);
+
+  if (col > 0)
+    mxml_string_putc('\n', ptr);
+
+ /*
+  * Nul-terminate the buffer...
+  */
+
+  if (ptr[0] >= ptr[1])
+    buffer[bufsize - 1] = '\0';
+  else
+    ptr[0][0] = '\0';
+
+ /*
+  * Return the number of characters...
+  */
+
+  return ((int)(ptr[0] - buffer));
+}
+
+
+/*
+ * 'mxmlSAXLoadFd()' - Load a file descriptor into an XML node tree
+ *                     using a SAX callback.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * The constants @code MXML_INTEGER_CALLBACK@, @code MXML_OPAQUE_CALLBACK@,
+ * @code MXML_REAL_CALLBACK@, and @code MXML_TEXT_CALLBACK@ are defined for
+ * loading child nodes of the specified type.
+ *
+ * The SAX callback must call @link mxmlRetain@ for any nodes that need to
+ * be kept for later use. Otherwise, nodes are deleted when the parent
+ * node is closed or after each data, comment, CDATA, or directive node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if the file could not be read. */
+mxmlSAXLoadFd(mxml_node_t    *top,	/* I - Top node */
+              int            fd,	/* I - File descriptor to read from */
+              mxml_load_cb_t cb,	/* I - Callback function or constant */
+              mxml_sax_cb_t  sax_cb,	/* I - SAX callback or @code MXML_NO_CALLBACK@ */
+              void           *sax_data)	/* I - SAX user data */
+{
+  _mxml_fdbuf_t	buf;			/* File descriptor buffer */
+
+
+ /*
+  * Initialize the file descriptor buffer...
+  */
+
+  buf.fd      = fd;
+  buf.current = buf.buffer;
+  buf.end     = buf.buffer;
+
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, &buf, cb, mxml_fd_getc, sax_cb, sax_data));
+}
+
+
+/*
+ * 'mxmlSAXLoadFile()' - Load a file into an XML node tree
+ *                       using a SAX callback.
+ *
+ * The nodes in the specified file are added to the specified top node.
+ * If no top node is provided, the XML file MUST be well-formed with a
+ * single parent node like <?xml> for the entire file. The callback
+ * function returns the value type that should be used for child nodes.
+ * The constants @code MXML_INTEGER_CALLBACK@, @code MXML_OPAQUE_CALLBACK@,
+ * @code MXML_REAL_CALLBACK@, and @code MXML_TEXT_CALLBACK@ are defined for
+ * loading child nodes of the specified type.
+ *
+ * The SAX callback must call @link mxmlRetain@ for any nodes that need to
+ * be kept for later use. Otherwise, nodes are deleted when the parent
+ * node is closed or after each data, comment, CDATA, or directive node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if the file could not be read. */
+mxmlSAXLoadFile(
+    mxml_node_t    *top,		/* I - Top node */
+    FILE           *fp,			/* I - File to read from */
+    mxml_load_cb_t cb,			/* I - Callback function or constant */
+    mxml_sax_cb_t  sax_cb,		/* I - SAX callback or @code MXML_NO_CALLBACK@ */
+    void           *sax_data)		/* I - SAX user data */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, fp, cb, mxml_file_getc, sax_cb, sax_data));
+}
+
+
+/*
+ * 'mxmlSAXLoadString()' - Load a string into an XML node tree
+ *                         using a SAX callback.
+ *
+ * The nodes in the specified string are added to the specified top node.
+ * If no top node is provided, the XML string MUST be well-formed with a
+ * single parent node like <?xml> for the entire string. The callback
+ * function returns the value type that should be used for child nodes.
+ * The constants @code MXML_INTEGER_CALLBACK@, @code MXML_OPAQUE_CALLBACK@,
+ * @code MXML_REAL_CALLBACK@, and @code MXML_TEXT_CALLBACK@ are defined for
+ * loading child nodes of the specified type.
+ *
+ * The SAX callback must call @link mxmlRetain@ for any nodes that need to
+ * be kept for later use. Otherwise, nodes are deleted when the parent
+ * node is closed or after each data, comment, CDATA, or directive node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if the string has errors. */
+mxmlSAXLoadString(
+    mxml_node_t    *top,		/* I - Top node */
+    const char     *s,			/* I - String to load */
+    mxml_load_cb_t cb,			/* I - Callback function or constant */
+    mxml_sax_cb_t  sax_cb,		/* I - SAX callback or @code MXML_NO_CALLBACK@ */
+    void           *sax_data)		/* I - SAX user data */
+{
+ /*
+  * Read the XML data...
+  */
+
+  return (mxml_load_data(top, (void *)&s, cb, mxml_string_getc, sax_cb, sax_data));
+}
+
+
+/*
+ * 'mxmlSetCustomHandlers()' - Set the handling functions for custom data.
+ *
+ * The load function accepts a node pointer and a data string and must
+ * return 0 on success and non-zero on error.
+ *
+ * The save function accepts a node pointer and must return a malloc'd
+ * string on success and @code NULL@ on error.
+ *
+ */
+
+void
+mxmlSetCustomHandlers(
+    mxml_custom_load_cb_t load,		/* I - Load function */
+    mxml_custom_save_cb_t save)		/* I - Save function */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  global->custom_load_cb = load;
+  global->custom_save_cb = save;
+}
+
+
+/*
+ * 'mxmlSetErrorCallback()' - Set the error message callback.
+ */
+
+void
+mxmlSetErrorCallback(mxml_error_cb_t cb)/* I - Error callback function */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  global->error_cb = cb;
+}
+
+
+/*
+ * 'mxmlSetWrapMargin()' - Set the wrap margin when saving XML data.
+ *
+ * Wrapping is disabled when "column" is 0.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+void
+mxmlSetWrapMargin(int column)		/* I - Column for wrapping, 0 to disable wrapping */
+{
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+  global->wrap = column;
+}
+
+
+/*
+ * 'mxml_add_char()' - Add a character to a buffer, expanding as needed.
+ */
+
+static int				/* O  - 0 on success, -1 on error */
+mxml_add_char(int  ch,			/* I  - Character to add */
+              char **bufptr,		/* IO - Current position in buffer */
+	      char **buffer,		/* IO - Current buffer */
+	      int  *bufsize)		/* IO - Current buffer size */
+{
+  char	*newbuffer;			/* New buffer value */
+
+
+  if (*bufptr >= (*buffer + *bufsize - 4))
+  {
+   /*
+    * Increase the size of the buffer...
+    */
+
+    if (*bufsize < 1024)
+      (*bufsize) *= 2;
+    else
+      (*bufsize) += 1024;
+
+    if ((newbuffer = realloc(*buffer, *bufsize)) == NULL)
+    {
+      free(*buffer);
+
+      mxml_error("Unable to expand string buffer to %d bytes!", *bufsize);
+
+      return (-1);
+    }
+
+    *bufptr = newbuffer + (*bufptr - *buffer);
+    *buffer = newbuffer;
+  }
+
+  if (ch < 0x80)
+  {
+   /*
+    * Single byte ASCII...
+    */
+
+    *(*bufptr)++ = ch;
+  }
+  else if (ch < 0x800)
+  {
+   /*
+    * Two-byte UTF-8...
+    */
+
+    *(*bufptr)++ = 0xc0 | (ch >> 6);
+    *(*bufptr)++ = 0x80 | (ch & 0x3f);
+  }
+  else if (ch < 0x10000)
+  {
+   /*
+    * Three-byte UTF-8...
+    */
+
+    *(*bufptr)++ = 0xe0 | (ch >> 12);
+    *(*bufptr)++ = 0x80 | ((ch >> 6) & 0x3f);
+    *(*bufptr)++ = 0x80 | (ch & 0x3f);
+  }
+  else
+  {
+   /*
+    * Four-byte UTF-8...
+    */
+
+    *(*bufptr)++ = 0xf0 | (ch >> 18);
+    *(*bufptr)++ = 0x80 | ((ch >> 12) & 0x3f);
+    *(*bufptr)++ = 0x80 | ((ch >> 6) & 0x3f);
+    *(*bufptr)++ = 0x80 | (ch & 0x3f);
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_fd_getc()' - Read a character from a file descriptor.
+ */
+
+static int				/* O  - Character or EOF */
+mxml_fd_getc(void *p,			/* I  - File descriptor buffer */
+             int  *encoding)		/* IO - Encoding */
+{
+  _mxml_fdbuf_t	*buf;			/* File descriptor buffer */
+  int		ch,			/* Current character */
+		temp;			/* Temporary character */
+
+
+ /*
+  * Grab the next character in the buffer...
+  */
+
+  buf = (_mxml_fdbuf_t *)p;
+
+  if (buf->current >= buf->end)
+    if (mxml_fd_read(buf) < 0)
+      return (EOF);
+
+  ch = *(buf->current)++;
+
+  switch (*encoding)
+  {
+    case ENCODE_UTF8 :
+       /*
+	* Got a UTF-8 character; convert UTF-8 to Unicode and return...
+	*/
+
+	if (!(ch & 0x80))
+	{
+#if DEBUG > 1
+          printf("mxml_fd_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+
+	  return (ch);
+        }
+	else if (ch == 0xfe)
+	{
+	 /*
+	  * UTF-16 big-endian BOM?
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  ch = *(buf->current)++;
+
+	  if (ch != 0xff)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16BE;
+
+	  return (mxml_fd_getc(p, encoding));
+	}
+	else if (ch == 0xff)
+	{
+	 /*
+	  * UTF-16 little-endian BOM?
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  ch = *(buf->current)++;
+
+	  if (ch != 0xfe)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16LE;
+
+	  return (mxml_fd_getc(p, encoding));
+	}
+	else if ((ch & 0xe0) == 0xc0)
+	{
+	 /*
+	  * Two-byte value...
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x1f) << 6) | (temp & 0x3f);
+
+	  if (ch < 0x80)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else if ((ch & 0xf0) == 0xe0)
+	{
+	 /*
+	  * Three-byte value...
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x800)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+
+         /*
+	  * Ignore (strip) Byte Order Mark (BOM)...
+	  */
+
+	  if (ch == 0xfeff)
+	    return (mxml_fd_getc(p, encoding));
+	}
+	else if ((ch & 0xf8) == 0xf0)
+	{
+	 /*
+	  * Four-byte value...
+	  */
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  if ((temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x10000)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else
+	  return (EOF);
+	break;
+
+    case ENCODE_UTF16BE :
+       /*
+        * Read UTF-16 big-endian char...
+	*/
+
+	if (buf->current >= buf->end)
+	  if (mxml_fd_read(buf) < 0)
+	    return (EOF);
+
+	temp = *(buf->current)++;
+
+	ch = (ch << 8) | temp;
+
+	if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  lch = *(buf->current)++;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  lch = (lch << 8) | temp;
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+
+    case ENCODE_UTF16LE :
+       /*
+        * Read UTF-16 little-endian char...
+	*/
+
+	if (buf->current >= buf->end)
+	  if (mxml_fd_read(buf) < 0)
+	    return (EOF);
+
+	temp = *(buf->current)++;
+
+	ch |= (temp << 8);
+
+        if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  lch = *(buf->current)++;
+
+	  if (buf->current >= buf->end)
+	    if (mxml_fd_read(buf) < 0)
+	      return (EOF);
+
+	  temp = *(buf->current)++;
+
+	  lch |= (temp << 8);
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+  }
+
+#if DEBUG > 1
+  printf("mxml_fd_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+  return (ch);
+}
+
+
+/*
+ * 'mxml_fd_putc()' - Write a character to a file descriptor.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+mxml_fd_putc(int  ch,			/* I - Character */
+             void *p)			/* I - File descriptor buffer */
+{
+  _mxml_fdbuf_t	*buf;			/* File descriptor buffer */
+
+
+ /*
+  * Flush the write buffer as needed...
+  */
+
+  buf = (_mxml_fdbuf_t *)p;
+
+  if (buf->current >= buf->end)
+    if (mxml_fd_write(buf) < 0)
+      return (-1);
+
+  *(buf->current)++ = ch;
+
+ /*
+  * Return successfully...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_fd_read()' - Read a buffer of data from a file descriptor.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+mxml_fd_read(_mxml_fdbuf_t *buf)		/* I - File descriptor buffer */
+{
+  int	bytes;				/* Bytes read... */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!buf)
+    return (-1);
+
+ /*
+  * Read from the file descriptor...
+  */
+
+  while ((bytes = (int)read(buf->fd, buf->buffer, sizeof(buf->buffer))) < 0)
+#ifdef EINTR
+    if (errno != EAGAIN && errno != EINTR)
+#else
+    if (errno != EAGAIN)
+#endif /* EINTR */
+      return (-1);
+
+  if (bytes == 0)
+    return (-1);
+
+ /*
+  * Update the pointers and return success...
+  */
+
+  buf->current = buf->buffer;
+  buf->end     = buf->buffer + bytes;
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_fd_write()' - Write a buffer of data to a file descriptor.
+ */
+
+static int				/* O - 0 on success, -1 on error */
+mxml_fd_write(_mxml_fdbuf_t *buf)	/* I - File descriptor buffer */
+{
+  int		bytes;			/* Bytes written */
+  unsigned char	*ptr;			/* Pointer into buffer */
+
+
+ /*
+  * Range check...
+  */
+
+  if (!buf)
+    return (-1);
+
+ /*
+  * Return 0 if there is nothing to write...
+  */
+
+  if (buf->current == buf->buffer)
+    return (0);
+
+ /*
+  * Loop until we have written everything...
+  */
+
+  for (ptr = buf->buffer; ptr < buf->current; ptr += bytes)
+    if ((bytes = (int)write(buf->fd, ptr, buf->current - ptr)) < 0)
+      return (-1);
+
+ /*
+  * All done, reset pointers and return success...
+  */
+
+  buf->current = buf->buffer;
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_file_getc()' - Get a character from a file.
+ */
+
+static int				/* O  - Character or EOF */
+mxml_file_getc(void *p,			/* I  - Pointer to file */
+               int  *encoding)		/* IO - Encoding */
+{
+  int	ch,				/* Character from file */
+	temp;				/* Temporary character */
+  FILE	*fp;				/* Pointer to file */
+
+
+ /*
+  * Read a character from the file and see if it is EOF or ASCII...
+  */
+
+  fp = (FILE *)p;
+  ch = getc(fp);
+
+  if (ch == EOF)
+    return (EOF);
+
+  switch (*encoding)
+  {
+    case ENCODE_UTF8 :
+       /*
+	* Got a UTF-8 character; convert UTF-8 to Unicode and return...
+	*/
+
+	if (!(ch & 0x80))
+	{
+	  if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+
+#if DEBUG > 1
+          printf("mxml_file_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  return (ch);
+        }
+	else if (ch == 0xfe)
+	{
+	 /*
+	  * UTF-16 big-endian BOM?
+	  */
+
+          ch = getc(fp);
+	  if (ch != 0xff)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16BE;
+
+	  return (mxml_file_getc(p, encoding));
+	}
+	else if (ch == 0xff)
+	{
+	 /*
+	  * UTF-16 little-endian BOM?
+	  */
+
+          ch = getc(fp);
+	  if (ch != 0xfe)
+	    return (EOF);
+
+	  *encoding = ENCODE_UTF16LE;
+
+	  return (mxml_file_getc(p, encoding));
+	}
+	else if ((ch & 0xe0) == 0xc0)
+	{
+	 /*
+	  * Two-byte value...
+	  */
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x1f) << 6) | (temp & 0x3f);
+
+	  if (ch < 0x80)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else if ((ch & 0xf0) == 0xe0)
+	{
+	 /*
+	  * Three-byte value...
+	  */
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x0f) << 6) | (temp & 0x3f);
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x800)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+
+         /*
+	  * Ignore (strip) Byte Order Mark (BOM)...
+	  */
+
+	  if (ch == 0xfeff)
+	    return (mxml_file_getc(p, encoding));
+	}
+	else if ((ch & 0xf8) == 0xf0)
+	{
+	 /*
+	  * Four-byte value...
+	  */
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = ((ch & 0x07) << 6) | (temp & 0x3f);
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if ((temp = getc(fp)) == EOF || (temp & 0xc0) != 0x80)
+	    return (EOF);
+
+	  ch = (ch << 6) | (temp & 0x3f);
+
+	  if (ch < 0x10000)
+	  {
+	    mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	    return (EOF);
+	  }
+	}
+	else
+	  return (EOF);
+	break;
+
+    case ENCODE_UTF16BE :
+       /*
+        * Read UTF-16 big-endian char...
+	*/
+
+	ch = (ch << 8) | getc(fp);
+
+	if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch = getc(fp);
+          lch = (lch << 8) | getc(fp);
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+
+    case ENCODE_UTF16LE :
+       /*
+        * Read UTF-16 little-endian char...
+	*/
+
+	ch |= (getc(fp) << 8);
+
+        if (mxml_bad_char(ch))
+	{
+	  mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	     ch);
+	  return (EOF);
+	}
+        else if (ch >= 0xd800 && ch <= 0xdbff)
+	{
+	 /*
+	  * Multi-word UTF-16 char...
+	  */
+
+          int lch = getc(fp);
+          lch |= (getc(fp) << 8);
+
+          if (lch < 0xdc00 || lch >= 0xdfff)
+	    return (EOF);
+
+          ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	}
+	break;
+  }
+
+#if DEBUG > 1
+  printf("mxml_file_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+  return (ch);
+}
+
+
+/*
+ * 'mxml_file_putc()' - Write a character to a file.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_file_putc(int  ch,			/* I - Character to write */
+               void *p)			/* I - Pointer to file */
+{
+  return (putc(ch, (FILE *)p) == EOF ? -1 : 0);
+}
+
+
+/*
+ * 'mxml_get_entity()' - Get the character corresponding to an entity...
+ */
+
+static int				/* O  - Character value or EOF on error */
+mxml_get_entity(mxml_node_t *parent,	/* I  - Parent node */
+		void        *p,		/* I  - Pointer to source */
+		int         *encoding,	/* IO - Character encoding */
+                int         (*getc_cb)(void *, int *),
+					/* I  - Get character function */
+                int         *line)	/* IO - Current line number */
+{
+  int	ch;				/* Current character */
+  char	entity[64],			/* Entity string */
+	*entptr;			/* Pointer into entity */
+
+
+  entptr = entity;
+
+  while ((ch = (*getc_cb)(p, encoding)) != EOF)
+  {
+    if (ch > 126 || (!isalnum(ch) && ch != '#'))
+      break;
+    else if (entptr < (entity + sizeof(entity) - 1))
+      *entptr++ = ch;
+    else
+    {
+      mxml_error("Entity name too long under parent <%s> on line %d.", parent ? parent->value.element.name : "null", *line);
+      break;
+    }
+  }
+
+  *entptr = '\0';
+
+  if (ch != ';')
+  {
+    mxml_error("Character entity '%s' not terminated under parent <%s> on line %d.", entity, parent ? parent->value.element.name : "null", *line);
+
+    if (ch == '\n')
+      (*line)++;
+
+    return (EOF);
+  }
+
+  if (entity[0] == '#')
+  {
+    if (entity[1] == 'x')
+      ch = (int)strtol(entity + 2, NULL, 16);
+    else
+      ch = (int)strtol(entity + 1, NULL, 10);
+  }
+  else if ((ch = mxmlEntityGetValue(entity)) < 0)
+    mxml_error("Entity name '%s;' not supported under parent <%s> on line %d.", entity, parent ? parent->value.element.name : "null", *line);
+
+  if (mxml_bad_char(ch))
+  {
+    mxml_error("Bad control character 0x%02x under parent <%s> on line %d not allowed by XML standard.", ch, parent ? parent->value.element.name : "null", *line);
+    return (EOF);
+  }
+
+  return (ch);
+}
+
+
+/*
+ * 'mxml_load_data()' - Load data into an XML node tree.
+ */
+
+static mxml_node_t *			/* O - First node or NULL if the file could not be read. */
+mxml_load_data(
+    mxml_node_t     *top,		/* I - Top node */
+    void            *p,			/* I - Pointer to data */
+    mxml_load_cb_t  cb,			/* I - Callback function or MXML_NO_CALLBACK */
+    _mxml_getc_cb_t getc_cb,		/* I - Read function */
+    mxml_sax_cb_t   sax_cb,		/* I - SAX callback or MXML_NO_CALLBACK */
+    void            *sax_data)		/* I - SAX user data */
+{
+  mxml_node_t	*node,			/* Current node */
+		*first,			/* First node added */
+		*parent;		/* Current parent node */
+  int		line = 1,		/* Current line number */
+		ch,			/* Character from file */
+		whitespace;		/* Non-zero if whitespace seen */
+  char		*buffer,		/* String buffer */
+		*bufptr;		/* Pointer into buffer */
+  int		bufsize;		/* Size of buffer */
+  mxml_type_t	type;			/* Current node type */
+  int		encoding;		/* Character encoding */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+  static const char * const types[] =	/* Type strings... */
+		{
+		  "MXML_ELEMENT",	/* XML element with attributes */
+		  "MXML_INTEGER",	/* Integer value */
+		  "MXML_OPAQUE",	/* Opaque string */
+		  "MXML_REAL",		/* Real value */
+		  "MXML_TEXT",		/* Text fragment */
+		  "MXML_CUSTOM"		/* Custom data */
+		};
+
+
+ /*
+  * Read elements and other nodes from the file...
+  */
+
+  if ((buffer = malloc(64)) == NULL)
+  {
+    mxml_error("Unable to allocate string buffer!");
+    return (NULL);
+  }
+
+  bufsize    = 64;
+  bufptr     = buffer;
+  parent     = top;
+  first      = NULL;
+  whitespace = 0;
+  encoding   = ENCODE_UTF8;
+
+  if (cb && parent)
+    type = (*cb)(parent);
+  else if (parent)
+    type = MXML_TEXT;
+  else
+    type = MXML_IGNORE;
+
+  if ((ch = (*getc_cb)(p, &encoding)) == EOF)
+  {
+    free(buffer);
+    return (NULL);
+  }
+  else if (ch != '<' && !top)
+  {
+    free(buffer);
+    mxml_error("XML does not start with '<' (saw '%c').", ch);
+    return (NULL);
+  }
+
+  do
+  {
+    if ((ch == '<' ||
+         (mxml_isspace(ch) && type != MXML_OPAQUE && type != MXML_CUSTOM)) &&
+        bufptr > buffer)
+    {
+     /*
+      * Add a new value node...
+      */
+
+      *bufptr = '\0';
+
+      switch (type)
+      {
+	case MXML_INTEGER :
+            node = mxmlNewInteger(parent, (int)strtol(buffer, &bufptr, 0));
+	    break;
+
+	case MXML_OPAQUE :
+            node = mxmlNewOpaque(parent, buffer);
+	    break;
+
+	case MXML_REAL :
+            node = mxmlNewReal(parent, strtod(buffer, &bufptr));
+	    break;
+
+	case MXML_TEXT :
+            node = mxmlNewText(parent, whitespace, buffer);
+	    break;
+
+	case MXML_CUSTOM :
+	    if (global->custom_load_cb)
+	    {
+	     /*
+	      * Use the callback to fill in the custom data...
+	      */
+
+              node = mxmlNewCustom(parent, NULL, NULL);
+
+	      if ((*global->custom_load_cb)(node, buffer))
+	      {
+	        mxml_error("Bad custom value '%s' in parent <%s> on line %d.", buffer, parent ? parent->value.element.name : "null", line);
+		mxmlDelete(node);
+		node = NULL;
+	      }
+	      break;
+	    }
+
+        default : /* Ignore... */
+	    node = NULL;
+	    break;
+      }
+
+      if (*bufptr)
+      {
+       /*
+        * Bad integer/real number value...
+	*/
+
+        mxml_error("Bad %s value '%s' in parent <%s> on line %d.", type == MXML_INTEGER ? "integer" : "real", buffer, parent ? parent->value.element.name : "null", line);
+	break;
+      }
+
+      bufptr     = buffer;
+      whitespace = mxml_isspace(ch) && type == MXML_TEXT;
+
+      if (!node && type != MXML_IGNORE)
+      {
+       /*
+	* Print error and return...
+	*/
+
+	mxml_error("Unable to add value node of type %s to parent <%s> on line %d.", types[type], parent ? parent->value.element.name : "null", line);
+	goto error;
+      }
+
+      if (sax_cb)
+      {
+        (*sax_cb)(node, MXML_SAX_DATA, sax_data);
+
+        if (!mxmlRelease(node))
+          node = NULL;
+      }
+
+      if (!first && node)
+        first = node;
+    }
+    else if (mxml_isspace(ch) && type == MXML_TEXT)
+      whitespace = 1;
+
+    if (ch == '\n')
+      line ++;
+
+   /*
+    * Add lone whitespace node if we have an element and existing
+    * whitespace...
+    */
+
+    if (ch == '<' && whitespace && type == MXML_TEXT)
+    {
+      if (parent)
+      {
+	node = mxmlNewText(parent, whitespace, "");
+
+	if (sax_cb)
+	{
+	  (*sax_cb)(node, MXML_SAX_DATA, sax_data);
+
+	  if (!mxmlRelease(node))
+	    node = NULL;
+	}
+
+	if (!first && node)
+	  first = node;
+      }
+
+      whitespace = 0;
+    }
+
+    if (ch == '<')
+    {
+     /*
+      * Start of open/close tag...
+      */
+
+      bufptr = buffer;
+
+      while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+      {
+        if (mxml_isspace(ch) || ch == '>' || (ch == '/' && bufptr > buffer))
+	  break;
+	else if (ch == '<')
+	{
+	  mxml_error("Bare < in element!");
+	  goto error;
+	}
+	else if (ch == '&')
+	{
+	  if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb, &line)) == EOF)
+	    goto error;
+
+	  if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+	}
+	else if (ch < '0' && ch != '!' && ch != '-' && ch != '.' && ch != '/')
+	  goto error;
+	else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	  goto error;
+	else if (((bufptr - buffer) == 1 && buffer[0] == '?') ||
+	         ((bufptr - buffer) == 3 && !strncmp(buffer, "!--", 3)) ||
+	         ((bufptr - buffer) == 8 && !strncmp(buffer, "![CDATA[", 8)))
+	  break;
+
+	if (ch == '\n')
+	  line ++;
+      }
+
+      *bufptr = '\0';
+
+      if (!strcmp(buffer, "!--"))
+      {
+       /*
+        * Gather rest of comment...
+	*/
+
+	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+	{
+	  if (ch == '>' && bufptr > (buffer + 4) &&
+	      bufptr[-3] != '-' && bufptr[-2] == '-' && bufptr[-1] == '-')
+	    break;
+	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+
+	  if (ch == '\n')
+	    line ++;
+	}
+
+       /*
+        * Error out if we didn't get the whole comment...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in comment node on line %d.", line);
+	  goto error;
+	}
+
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+        if (!parent && first)
+	{
+	 /*
+	  * There can only be one root element!
+	  */
+
+	  mxml_error("<%s> cannot be a second root node after <%s> on line %d.", buffer, first->value.element.name, line);
+          goto error;
+	}
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Just print error for now...
+	  */
+
+	  mxml_error("Unable to add comment node to parent <%s> on line %d.", parent ? parent->value.element.name : "null", line);
+	  break;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_COMMENT, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+	if (node && !first)
+	  first = node;
+      }
+      else if (!strcmp(buffer, "![CDATA["))
+      {
+       /*
+        * Gather CDATA section...
+	*/
+
+	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+	{
+	  if (ch == '>' && !strncmp(bufptr - 2, "]]", 2))
+	  {
+	   /*
+	    * Drop terminator from CDATA string...
+	    */
+
+	    bufptr[-2] = '\0';
+	    break;
+	  }
+	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+
+	  if (ch == '\n')
+	    line ++;
+	}
+
+       /*
+        * Error out if we didn't get the whole comment...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in CDATA node on line %d.", line);
+	  goto error;
+	}
+
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+        if (!parent && first)
+	{
+	 /*
+	  * There can only be one root element!
+	  */
+
+	  mxml_error("<%s> cannot be a second root node after <%s> on line %d.", buffer, first->value.element.name, line);
+          goto error;
+	}
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Unable to add CDATA node to parent <%s> on line %d.", parent ? parent->value.element.name : "null", line);
+	  goto error;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_CDATA, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+	if (node && !first)
+	  first = node;
+      }
+      else if (buffer[0] == '?')
+      {
+       /*
+        * Gather rest of processing instruction...
+	*/
+
+	while ((ch = (*getc_cb)(p, &encoding)) != EOF)
+	{
+	  if (ch == '>' && bufptr > buffer && bufptr[-1] == '?')
+	    break;
+	  else if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	    goto error;
+
+	  if (ch == '\n')
+	    line ++;
+	}
+
+       /*
+        * Error out if we didn't get the whole processing instruction...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in processing instruction node on line %d.", line);
+	  goto error;
+	}
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+        if (!parent && first)
+	{
+	 /*
+	  * There can only be one root element!
+	  */
+
+	  mxml_error("<%s> cannot be a second root node after <%s> on line %d.", buffer, first->value.element.name, line);
+          goto error;
+	}
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Unable to add processing instruction node to parent <%s> on line %d.", parent ? parent->value.element.name : "null", line);
+	  goto error;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_DIRECTIVE, sax_data);
+
+          if (strncmp(node->value.element.name, "?xml ", 5) && !mxmlRelease(node))
+            node = NULL;
+        }
+
+        if (node)
+	{
+	  if (!first)
+            first = node;
+
+	  if (!parent)
+	  {
+	    parent = node;
+
+	    if (cb)
+	      type = (*cb)(parent);
+	    else
+	      type = MXML_TEXT;
+	  }
+	}
+      }
+      else if (buffer[0] == '!')
+      {
+       /*
+        * Gather rest of declaration...
+	*/
+
+	do
+	{
+	  if (ch == '>')
+	    break;
+	  else
+	  {
+            if (ch == '&')
+            {
+	      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb, &line)) == EOF)
+		goto error;
+            }
+
+	    if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	      goto error;
+	  }
+
+	  if (ch == '\n')
+	    line ++;
+	}
+        while ((ch = (*getc_cb)(p, &encoding)) != EOF);
+
+       /*
+        * Error out if we didn't get the whole declaration...
+	*/
+
+        if (ch != '>')
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Early EOF in declaration node on line %d.", line);
+	  goto error;
+	}
+
+       /*
+        * Otherwise add this as an element under the current parent...
+	*/
+
+	*bufptr = '\0';
+
+        if (!parent && first)
+	{
+	 /*
+	  * There can only be one root element!
+	  */
+
+	  mxml_error("<%s> cannot be a second root node after <%s> on line %d.", buffer, first->value.element.name, line);
+          goto error;
+	}
+
+	if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Print error and return...
+	  */
+
+	  mxml_error("Unable to add declaration node to parent <%s> on line %d.", parent ? parent->value.element.name : "null", line);
+	  goto error;
+	}
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_DIRECTIVE, sax_data);
+
+          if (!mxmlRelease(node))
+            node = NULL;
+        }
+
+        if (node)
+	{
+	  if (!first)
+            first = node;
+
+	  if (!parent)
+	  {
+	    parent = node;
+
+	    if (cb)
+	      type = (*cb)(parent);
+	    else
+	      type = MXML_TEXT;
+	  }
+	}
+      }
+      else if (buffer[0] == '/')
+      {
+       /*
+        * Handle close tag...
+	*/
+
+        if (!parent || strcmp(buffer + 1, parent->value.element.name))
+	{
+	 /*
+	  * Close tag doesn't match tree; print an error for now...
+	  */
+
+	  mxml_error("Mismatched close tag <%s> under parent <%s> on line %d.", buffer, parent ? parent->value.element.name : "(null)", line);
+          goto error;
+	}
+
+       /*
+        * Keep reading until we see >...
+	*/
+
+        while (ch != '>' && ch != EOF)
+	  ch = (*getc_cb)(p, &encoding);
+
+        node   = parent;
+        parent = parent->parent;
+
+        if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_ELEMENT_CLOSE, sax_data);
+
+          if (!mxmlRelease(node) && first == node)
+	    first = NULL;
+        }
+
+       /*
+	* Ascend into the parent and set the value type as needed...
+	*/
+
+	if (cb && parent)
+	  type = (*cb)(parent);
+      }
+      else
+      {
+       /*
+        * Handle open tag...
+	*/
+
+        if (!parent && first)
+	{
+	 /*
+	  * There can only be one root element!
+	  */
+
+	  mxml_error("<%s> cannot be a second root node after <%s> on line %d.", buffer, first->value.element.name, line);
+          goto error;
+	}
+
+        if ((node = mxmlNewElement(parent, buffer)) == NULL)
+	{
+	 /*
+	  * Just print error for now...
+	  */
+
+	  mxml_error("Unable to add element node to parent <%s> on line %d.", parent ? parent->value.element.name : "null", line);
+	  goto error;
+	}
+
+        if (mxml_isspace(ch))
+        {
+	  if ((ch = mxml_parse_element(node, p, &encoding, getc_cb, &line)) == EOF)
+	    goto error;
+        }
+        else if (ch == '/')
+	{
+	  if ((ch = (*getc_cb)(p, &encoding)) != '>')
+	  {
+	    mxml_error("Expected > but got '%c' instead for element <%s/> on line %d.", ch, buffer, line);
+            mxmlDelete(node);
+            goto error;
+	  }
+
+	  ch = '/';
+	}
+
+        if (sax_cb)
+          (*sax_cb)(node, MXML_SAX_ELEMENT_OPEN, sax_data);
+
+        if (!first)
+	  first = node;
+
+	if (ch == EOF)
+	  break;
+
+        if (ch != '/')
+	{
+	 /*
+	  * Descend into this node, setting the value type as needed...
+	  */
+
+	  parent = node;
+
+	  if (cb && parent)
+	    type = (*cb)(parent);
+	  else
+	    type = MXML_TEXT;
+	}
+        else if (sax_cb)
+        {
+          (*sax_cb)(node, MXML_SAX_ELEMENT_CLOSE, sax_data);
+
+          if (!mxmlRelease(node) && first == node)
+            first = NULL;
+        }
+      }
+
+      bufptr  = buffer;
+    }
+    else if (ch == '&')
+    {
+     /*
+      * Add character entity to current buffer...
+      */
+
+      if ((ch = mxml_get_entity(parent, p, &encoding, getc_cb, &line)) == EOF)
+	goto error;
+
+      if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	goto error;
+    }
+    else if (type == MXML_OPAQUE || type == MXML_CUSTOM || !mxml_isspace(ch))
+    {
+     /*
+      * Add character to current buffer...
+      */
+
+      if (mxml_add_char(ch, &bufptr, &buffer, &bufsize))
+	goto error;
+    }
+  }
+  while ((ch = (*getc_cb)(p, &encoding)) != EOF);
+
+ /*
+  * Free the string buffer - we don't need it anymore...
+  */
+
+  free(buffer);
+
+ /*
+  * Find the top element and return it...
+  */
+
+  if (parent)
+  {
+    node = parent;
+
+    while (parent != top && parent->parent)
+      parent = parent->parent;
+
+    if (node != parent)
+    {
+      mxml_error("Missing close tag </%s> under parent <%s> on line %d.", node->value.element.name, node->parent ? node->parent->value.element.name : "(null)", line);
+
+      mxmlDelete(first);
+
+      return (NULL);
+    }
+  }
+
+  if (parent)
+    return (parent);
+  else
+    return (first);
+
+ /*
+  * Common error return...
+  */
+
+  error:
+
+  mxmlDelete(first);
+
+  free(buffer);
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxml_parse_element()' - Parse an element for any attributes...
+ */
+
+static int				/* O  - Terminating character */
+mxml_parse_element(
+    mxml_node_t     *node,		/* I  - Element node */
+    void            *p,			/* I  - Data to read from */
+    int             *encoding,		/* IO - Encoding */
+    _mxml_getc_cb_t getc_cb,		/* I  - Data callback */
+    int             *line)		/* IO - Current line number */
+{
+  int	ch,				/* Current character in file */
+	quote;				/* Quoting character */
+  char	*name,				/* Attribute name */
+	*value,				/* Attribute value */
+	*ptr;				/* Pointer into name/value */
+  int	namesize,			/* Size of name string */
+	valsize;			/* Size of value string */
+
+
+ /*
+  * Initialize the name and value buffers...
+  */
+
+  if ((name = malloc(64)) == NULL)
+  {
+    mxml_error("Unable to allocate memory for name!");
+    return (EOF);
+  }
+
+  namesize = 64;
+
+  if ((value = malloc(64)) == NULL)
+  {
+    free(name);
+    mxml_error("Unable to allocate memory for value!");
+    return (EOF);
+  }
+
+  valsize = 64;
+
+ /*
+  * Loop until we hit a >, /, ?, or EOF...
+  */
+
+  while ((ch = (*getc_cb)(p, encoding)) != EOF)
+  {
+#if DEBUG > 1
+    fprintf(stderr, "parse_element: ch='%c'\n", ch);
+#endif /* DEBUG > 1 */
+
+   /*
+    * Skip leading whitespace...
+    */
+
+    if (mxml_isspace(ch))
+    {
+      if (ch == '\n')
+        (*line)++;
+
+      continue;
+    }
+
+   /*
+    * Stop at /, ?, or >...
+    */
+
+    if (ch == '/' || ch == '?')
+    {
+     /*
+      * Grab the > character and print an error if it isn't there...
+      */
+
+      quote = (*getc_cb)(p, encoding);
+
+      if (quote != '>')
+      {
+        mxml_error("Expected '>' after '%c' for element %s, but got '%c' on line %d.", ch, node->value.element.name, quote, *line);
+        goto error;
+      }
+
+      break;
+    }
+    else if (ch == '<')
+    {
+      mxml_error("Bare < in element %s on line %d.", node->value.element.name, *line);
+      goto error;
+    }
+    else if (ch == '>')
+      break;
+
+   /*
+    * Read the attribute name...
+    */
+
+    name[0] = ch;
+    ptr     = name + 1;
+
+    if (ch == '\"' || ch == '\'')
+    {
+     /*
+      * Name is in quotes, so get a quoted string...
+      */
+
+      quote = ch;
+
+      while ((ch = (*getc_cb)(p, encoding)) != EOF)
+      {
+        if (ch == '&')
+        {
+	  if ((ch = mxml_get_entity(node, p, encoding, getc_cb, line)) == EOF)
+	    goto error;
+	}
+	else if (ch == '\n')
+	  (*line)++;
+
+	if (mxml_add_char(ch, &ptr, &name, &namesize))
+	  goto error;
+
+	if (ch == quote)
+          break;
+      }
+    }
+    else
+    {
+     /*
+      * Grab an normal, non-quoted name...
+      */
+
+      while ((ch = (*getc_cb)(p, encoding)) != EOF)
+      {
+	if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>' ||
+	    ch == '?')
+	{
+	  if (ch == '\n')
+	    (*line)++;
+          break;
+        }
+	else
+	{
+          if (ch == '&')
+          {
+	    if ((ch = mxml_get_entity(node, p, encoding, getc_cb, line)) == EOF)
+	      goto error;
+          }
+
+	  if (mxml_add_char(ch, &ptr, &name, &namesize))
+	    goto error;
+	}
+      }
+    }
+
+    *ptr = '\0';
+
+    if (mxmlElementGetAttr(node, name))
+    {
+      mxml_error("Duplicate attribute '%s' in element %s on line %d.", name, node->value.element.name, name, *line);
+      goto error;
+    }
+
+    while (ch != EOF && mxml_isspace(ch))
+    {
+      ch = (*getc_cb)(p, encoding);
+
+      if (ch == '\n')
+        (*line)++;
+    }
+
+    if (ch == '=')
+    {
+     /*
+      * Read the attribute value...
+      */
+
+      while ((ch = (*getc_cb)(p, encoding)) != EOF && mxml_isspace(ch))
+      {
+        if (ch == '\n')
+          (*line)++;
+      }
+
+      if (ch == EOF)
+      {
+        mxml_error("Missing value for attribute '%s' in element %s on line %d.", name, node->value.element.name, *line);
+        goto error;
+      }
+
+      if (ch == '\'' || ch == '\"')
+      {
+       /*
+        * Read quoted value...
+	*/
+
+        quote = ch;
+	ptr   = value;
+
+        while ((ch = (*getc_cb)(p, encoding)) != EOF)
+        {
+	  if (ch == quote)
+	  {
+	    break;
+	  }
+	  else
+	  {
+	    if (ch == '&')
+	    {
+	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb, line)) == EOF)
+	        goto error;
+	    }
+	    else if (ch == '\n')
+	      (*line)++;
+
+	    if (mxml_add_char(ch, &ptr, &value, &valsize))
+	      goto error;
+	  }
+	}
+
+        *ptr = '\0';
+      }
+      else
+      {
+       /*
+        * Read unquoted value...
+	*/
+
+	value[0] = ch;
+	ptr      = value + 1;
+
+	while ((ch = (*getc_cb)(p, encoding)) != EOF)
+	{
+	  if (mxml_isspace(ch) || ch == '=' || ch == '/' || ch == '>')
+	  {
+	    if (ch == '\n')
+	      (*line)++;
+
+            break;
+          }
+	  else
+	  {
+	    if (ch == '&')
+	    {
+	      if ((ch = mxml_get_entity(node, p, encoding, getc_cb, line)) == EOF)
+	        goto error;
+	    }
+
+	    if (mxml_add_char(ch, &ptr, &value, &valsize))
+	      goto error;
+	  }
+	}
+
+        *ptr = '\0';
+      }
+
+     /*
+      * Set the attribute with the given string value...
+      */
+
+      mxmlElementSetAttr(node, name, value);
+    }
+    else
+    {
+      mxml_error("Missing value for attribute '%s' in element %s on line %d.", name, node->value.element.name, *line);
+      goto error;
+    }
+
+   /*
+    * Check the end character...
+    */
+
+    if (ch == '/' || ch == '?')
+    {
+     /*
+      * Grab the > character and print an error if it isn't there...
+      */
+
+      quote = (*getc_cb)(p, encoding);
+
+      if (quote != '>')
+      {
+        mxml_error("Expected '>' after '%c' for element %s, but got '%c' on line %d.", ch, node->value.element.name, quote, *line);
+        ch = EOF;
+      }
+
+      break;
+    }
+    else if (ch == '>')
+      break;
+  }
+
+ /*
+  * Free the name and value buffers and return...
+  */
+
+  free(name);
+  free(value);
+
+  return (ch);
+
+ /*
+  * Common error return point...
+  */
+
+  error:
+
+  free(name);
+  free(value);
+
+  return (EOF);
+}
+
+
+/*
+ * 'mxml_string_getc()' - Get a character from a string.
+ */
+
+static int				/* O  - Character or EOF */
+mxml_string_getc(void *p,		/* I  - Pointer to file */
+                 int  *encoding)	/* IO - Encoding */
+{
+  int		ch;			/* Character */
+  const char	**s;			/* Pointer to string pointer */
+
+
+  s = (const char **)p;
+
+  if ((ch = (*s)[0] & 255) != 0 || *encoding == ENCODE_UTF16LE)
+  {
+   /*
+    * Got character; convert UTF-8 to integer and return...
+    */
+
+    (*s)++;
+
+    switch (*encoding)
+    {
+      case ENCODE_UTF8 :
+	  if (!(ch & 0x80))
+	  {
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    if (mxml_bad_char(ch))
+	    {
+	      mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        		 ch);
+	      return (EOF);
+	    }
+
+	    return (ch);
+          }
+	  else if (ch == 0xfe)
+	  {
+	   /*
+	    * UTF-16 big-endian BOM?
+	    */
+
+            if (((*s)[0] & 255) != 0xff)
+	      return (EOF);
+
+	    *encoding = ENCODE_UTF16BE;
+	    (*s)++;
+
+	    return (mxml_string_getc(p, encoding));
+	  }
+	  else if (ch == 0xff)
+	  {
+	   /*
+	    * UTF-16 little-endian BOM?
+	    */
+
+            if (((*s)[0] & 255) != 0xfe)
+	      return (EOF);
+
+	    *encoding = ENCODE_UTF16LE;
+	    (*s)++;
+
+	    return (mxml_string_getc(p, encoding));
+	  }
+	  else if ((ch & 0xe0) == 0xc0)
+	  {
+	   /*
+	    * Two-byte value...
+	    */
+
+	    if (((*s)[0] & 0xc0) != 0x80)
+              return (EOF);
+
+	    ch = ((ch & 0x1f) << 6) | ((*s)[0] & 0x3f);
+
+	    (*s)++;
+
+	    if (ch < 0x80)
+	    {
+	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	      return (EOF);
+	    }
+
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    return (ch);
+	  }
+	  else if ((ch & 0xf0) == 0xe0)
+	  {
+	   /*
+	    * Three-byte value...
+	    */
+
+	    if (((*s)[0] & 0xc0) != 0x80 ||
+        	((*s)[1] & 0xc0) != 0x80)
+              return (EOF);
+
+	    ch = ((((ch & 0x0f) << 6) | ((*s)[0] & 0x3f)) << 6) | ((*s)[1] & 0x3f);
+
+	    (*s) += 2;
+
+	    if (ch < 0x800)
+	    {
+	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	      return (EOF);
+	    }
+
+	   /*
+	    * Ignore (strip) Byte Order Mark (BOM)...
+	    */
+
+	    if (ch == 0xfeff)
+	      return (mxml_string_getc(p, encoding));
+
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    return (ch);
+	  }
+	  else if ((ch & 0xf8) == 0xf0)
+	  {
+	   /*
+	    * Four-byte value...
+	    */
+
+	    if (((*s)[0] & 0xc0) != 0x80 ||
+        	((*s)[1] & 0xc0) != 0x80 ||
+        	((*s)[2] & 0xc0) != 0x80)
+              return (EOF);
+
+	    ch = ((((((ch & 0x07) << 6) | ((*s)[0] & 0x3f)) << 6) |
+        	   ((*s)[1] & 0x3f)) << 6) | ((*s)[2] & 0x3f);
+
+	    (*s) += 3;
+
+	    if (ch < 0x10000)
+	    {
+	      mxml_error("Invalid UTF-8 sequence for character 0x%04x!", ch);
+	      return (EOF);
+	    }
+
+#if DEBUG > 1
+            printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	    return (ch);
+	  }
+	  else
+	    return (EOF);
+
+      case ENCODE_UTF16BE :
+	 /*
+          * Read UTF-16 big-endian char...
+	  */
+
+	  ch = (ch << 8) | ((*s)[0] & 255);
+	  (*s) ++;
+
+          if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+          else if (ch >= 0xd800 && ch <= 0xdbff)
+	  {
+	   /*
+	    * Multi-word UTF-16 char...
+	    */
+
+            int lch;			/* Lower word */
+
+
+            if (!(*s)[0])
+	      return (EOF);
+
+            lch = (((*s)[0] & 255) << 8) | ((*s)[1] & 255);
+	    (*s) += 2;
+
+            if (lch < 0xdc00 || lch >= 0xdfff)
+	      return (EOF);
+
+            ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	  }
+
+#if DEBUG > 1
+          printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  return (ch);
+
+      case ENCODE_UTF16LE :
+	 /*
+          * Read UTF-16 little-endian char...
+	  */
+
+	  ch = ch | (((*s)[0] & 255) << 8);
+
+	  if (!ch)
+	  {
+	    (*s) --;
+	    return (EOF);
+	  }
+
+	  (*s) ++;
+
+          if (mxml_bad_char(ch))
+	  {
+	    mxml_error("Bad control character 0x%02x not allowed by XML standard!",
+        	       ch);
+	    return (EOF);
+	  }
+          else if (ch >= 0xd800 && ch <= 0xdbff)
+	  {
+	   /*
+	    * Multi-word UTF-16 char...
+	    */
+
+            int lch;			/* Lower word */
+
+
+            if (!(*s)[1])
+	      return (EOF);
+
+            lch = (((*s)[1] & 255) << 8) | ((*s)[0] & 255);
+	    (*s) += 2;
+
+            if (lch < 0xdc00 || lch >= 0xdfff)
+	      return (EOF);
+
+            ch = (((ch & 0x3ff) << 10) | (lch & 0x3ff)) + 0x10000;
+	  }
+
+#if DEBUG > 1
+          printf("mxml_string_getc: %c (0x%04x)\n", ch < ' ' ? '.' : ch, ch);
+#endif /* DEBUG > 1 */
+
+	  return (ch);
+    }
+  }
+
+  return (EOF);
+}
+
+
+/*
+ * 'mxml_string_putc()' - Write a character to a string.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_string_putc(int  ch,		/* I - Character to write */
+                 void *p)		/* I - Pointer to string pointers */
+{
+  char	**pp;				/* Pointer to string pointers */
+
+
+  pp = (char **)p;
+
+  if (pp[0] < pp[1])
+    pp[0][0] = ch;
+
+  pp[0] ++;
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_write_name()' - Write a name string.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_write_name(const char *s,		/* I - Name to write */
+                void       *p,		/* I - Write pointer */
+		int        (*putc_cb)(int, void *))
+					/* I - Write callback */
+{
+  char		quote;			/* Quote character */
+  const char	*name;			/* Entity name */
+
+
+  if (*s == '\"' || *s == '\'')
+  {
+   /*
+    * Write a quoted name string...
+    */
+
+    if ((*putc_cb)(*s, p) < 0)
+      return (-1);
+
+    quote = *s++;
+
+    while (*s && *s != quote)
+    {
+      if ((name = mxmlEntityGetName(*s)) != NULL)
+      {
+	if ((*putc_cb)('&', p) < 0)
+          return (-1);
+
+        while (*name)
+	{
+	  if ((*putc_cb)(*name, p) < 0)
+            return (-1);
+
+          name ++;
+	}
+
+	if ((*putc_cb)(';', p) < 0)
+          return (-1);
+      }
+      else if ((*putc_cb)(*s, p) < 0)
+	return (-1);
+
+      s ++;
+    }
+
+   /*
+    * Write the end quote...
+    */
+
+    if ((*putc_cb)(quote, p) < 0)
+      return (-1);
+  }
+  else
+  {
+   /*
+    * Write a non-quoted name string...
+    */
+
+    while (*s)
+    {
+      if ((*putc_cb)(*s, p) < 0)
+	return (-1);
+
+      s ++;
+    }
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_write_node()' - Save an XML node to a file.
+ */
+
+static int				/* O - Column or -1 on error */
+mxml_write_node(mxml_node_t     *node,	/* I - Node to write */
+                void            *p,	/* I - File to write to */
+	        mxml_save_cb_t  cb,	/* I - Whitespace callback */
+		int             col,	/* I - Current column */
+		_mxml_putc_cb_t putc_cb,/* I - Output callback */
+		_mxml_global_t  *global)/* I - Global data */
+{
+  mxml_node_t	*current,		/* Current node */
+		*next;			/* Next node */
+  int		i,			/* Looping var */
+		width;			/* Width of attr + value */
+  _mxml_attr_t	*attr;			/* Current attribute */
+  char		s[255];			/* Temporary string */
+
+
+ /*
+  * Loop through this node and all of its children...
+  */
+
+  for (current = node; current; current = next)
+  {
+   /*
+    * Print the node value...
+    */
+
+    switch (current->type)
+    {
+      case MXML_ELEMENT :
+	  col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);
+
+	  if ((*putc_cb)('<', p) < 0)
+	    return (-1);
+	  if (current->value.element.name[0] == '?' ||
+	      !strncmp(current->value.element.name, "!--", 3))
+	  {
+	   /*
+	    * Comments and processing instructions do not use character
+	    * entities.
+	    */
+
+	    const char	*ptr;		/* Pointer into name */
+
+	    for (ptr = current->value.element.name; *ptr; ptr ++)
+	      if ((*putc_cb)(*ptr, p) < 0)
+		return (-1);
+	  }
+	  else if (!strncmp(current->value.element.name, "![CDATA[", 8))
+	  {
+	   /*
+	    * CDATA elements do not use character entities, but also need the
+	    * "]]" terminator added at the end.
+	    */
+
+	    const char	*ptr;		/* Pointer into name */
+
+	    for (ptr = current->value.element.name; *ptr; ptr ++)
+	      if ((*putc_cb)(*ptr, p) < 0)
+		return (-1);
+
+            if ((*putc_cb)(']', p) < 0)
+              return (-1);
+            if ((*putc_cb)(']', p) < 0)
+              return (-1);
+	  }
+	  else if (mxml_write_name(current->value.element.name, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(current->value.element.name) + 1;
+
+	  for (i = current->value.element.num_attrs, attr = current->value.element.attrs;
+	       i > 0;
+	       i --, attr ++)
+	  {
+	    width = (int)strlen(attr->name);
+
+	    if (attr->value)
+	      width += strlen(attr->value) + 3;
+
+	    if (global->wrap > 0 && (col + width) > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+		return (-1);
+
+	      col = 0;
+	    }
+	    else
+	    {
+	      if ((*putc_cb)(' ', p) < 0)
+		return (-1);
+
+	      col ++;
+	    }
+
+	    if (mxml_write_name(attr->name, p, putc_cb) < 0)
+	      return (-1);
+
+	    if (attr->value)
+	    {
+	      if ((*putc_cb)('=', p) < 0)
+		return (-1);
+	      if ((*putc_cb)('\"', p) < 0)
+		return (-1);
+	      if (mxml_write_string(attr->value, p, putc_cb) < 0)
+		return (-1);
+	      if ((*putc_cb)('\"', p) < 0)
+		return (-1);
+	    }
+
+	    col += width;
+	  }
+
+	  if (current->child)
+	  {
+	   /*
+	    * Write children...
+	    */
+
+	    if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+
+	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+	  }
+	  else if (current->value.element.name[0] == '!' ||
+		   current->value.element.name[0] == '?')
+	  {
+	   /*
+	    * The ? and ! elements are special-cases...
+	    */
+
+	    if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+
+	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+	  }
+	  else
+	  {
+	    if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    if ((*putc_cb)('/', p) < 0)
+	      return (-1);
+	    if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+
+	    col += 3;
+
+	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+	  }
+	  break;
+
+      case MXML_INTEGER :
+	  if (current->prev)
+	  {
+	    if (global->wrap > 0 && col > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+		return (-1);
+
+	      col = 0;
+	    }
+	    else if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+	  }
+
+	  snprintf(s, sizeof(s), "%d", current->value.integer);
+	  if (mxml_write_string(s, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(s);
+	  break;
+
+      case MXML_OPAQUE :
+	  if (mxml_write_string(current->value.opaque, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(current->value.opaque);
+	  break;
+
+      case MXML_REAL :
+	  if (current->prev)
+	  {
+	    if (global->wrap > 0 && col > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+		return (-1);
+
+	      col = 0;
+	    }
+	    else if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+	  }
+
+	  snprintf(s, sizeof(s), "%f", current->value.real);
+	  if (mxml_write_string(s, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(s);
+	  break;
+
+      case MXML_TEXT :
+	  if (current->value.text.whitespace && col > 0)
+	  {
+	    if (global->wrap > 0 && col > global->wrap)
+	    {
+	      if ((*putc_cb)('\n', p) < 0)
+		return (-1);
+
+	      col = 0;
+	    }
+	    else if ((*putc_cb)(' ', p) < 0)
+	      return (-1);
+	    else
+	      col ++;
+	  }
+
+	  if (mxml_write_string(current->value.text.string, p, putc_cb) < 0)
+	    return (-1);
+
+	  col += strlen(current->value.text.string);
+	  break;
+
+      case MXML_CUSTOM :
+	  if (global->custom_save_cb)
+	  {
+	    char	*data;		/* Custom data string */
+	    const char	*newline;	/* Last newline in string */
+
+
+	    if ((data = (*global->custom_save_cb)(current)) == NULL)
+	      return (-1);
+
+	    if (mxml_write_string(data, p, putc_cb) < 0)
+	      return (-1);
+
+	    if ((newline = strrchr(data, '\n')) == NULL)
+	      col += strlen(data);
+	    else
+	      col = (int)strlen(newline);
+
+	    free(data);
+	    break;
+	  }
+
+      default : /* Should never happen */
+	  return (-1);
+    }
+
+   /*
+    * Figure out the next node...
+    */
+
+    if ((next = current->child) == NULL)
+    {
+      if (current == node)
+      {
+       /*
+        * Don't traverse to sibling node if we are at the "root" node...
+        */
+
+        next = NULL;
+      }
+      else
+      {
+       /*
+        * Try the next sibling, and continue traversing upwards as needed...
+        */
+
+	while ((next = current->next) == NULL)
+	{
+	  if (current == node || !current->parent)
+	    break;
+
+	 /*
+	  * The ? and ! elements are special-cases and have no end tags...
+	  */
+
+	  current = current->parent;
+
+	  if (current->value.element.name[0] != '!' &&
+	      current->value.element.name[0] != '?')
+	  {
+	    col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
+
+	    if ((*putc_cb)('<', p) < 0)
+	      return (-1);
+	    if ((*putc_cb)('/', p) < 0)
+	      return (-1);
+	    if (mxml_write_string(current->value.element.name, p, putc_cb) < 0)
+	      return (-1);
+	    if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+
+	    col += strlen(current->value.element.name) + 3;
+
+	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
+	  }
+
+	  if (current == node)
+	    break;
+	}
+      }
+    }
+  }
+
+  return (col);
+}
+
+
+/*
+ * 'mxml_write_string()' - Write a string, escaping & and < as needed.
+ */
+
+static int				/* O - 0 on success, -1 on failure */
+mxml_write_string(
+    const char      *s,			/* I - String to write */
+    void            *p,			/* I - Write pointer */
+    _mxml_putc_cb_t putc_cb)		/* I - Write callback */
+{
+  const char	*name;			/* Entity name, if any */
+
+
+  while (*s)
+  {
+    if ((name = mxmlEntityGetName(*s)) != NULL)
+    {
+      if ((*putc_cb)('&', p) < 0)
+        return (-1);
+
+      while (*name)
+      {
+	if ((*putc_cb)(*name, p) < 0)
+          return (-1);
+        name ++;
+      }
+
+      if ((*putc_cb)(';', p) < 0)
+        return (-1);
+    }
+    else if ((*putc_cb)(*s, p) < 0)
+      return (-1);
+
+    s ++;
+  }
+
+  return (0);
+}
+
+
+/*
+ * 'mxml_write_ws()' - Do whitespace callback...
+ */
+
+static int				/* O - New column */
+mxml_write_ws(mxml_node_t     *node,	/* I - Current node */
+              void            *p,	/* I - Write pointer */
+              mxml_save_cb_t  cb,	/* I - Callback function */
+	      int             ws,	/* I - Where value */
+	      int             col,	/* I - Current column */
+              _mxml_putc_cb_t putc_cb)	/* I - Write callback */
+{
+  const char	*s;			/* Whitespace string */
+
+
+  if (cb && (s = (*cb)(node, ws)) != NULL)
+  {
+    while (*s)
+    {
+      if ((*putc_cb)(*s, p) < 0)
+	return (-1);
+      else if (*s == '\n')
+	col = 0;
+      else if (*s == '\t')
+      {
+	col += MXML_TAB;
+	col = col - (col % MXML_TAB);
+      }
+      else
+	col ++;
+
+      s ++;
+    }
+  }
+
+  return (col);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-get.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-get.c
new file mode 100644
index 0000000..e2ff2bd
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-get.c
@@ -0,0 +1,448 @@
+/*
+ * Node get functions for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2014-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml-private.h"
+
+
+/*
+ * 'mxmlGetCDATA()' - Get the value for a CDATA node.
+ *
+ * @code NULL@ is returned if the node is not a CDATA element.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+const char *				/* O - CDATA value or @code NULL@ */
+mxmlGetCDATA(mxml_node_t *node)		/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT ||
+      strncmp(node->value.element.name, "![CDATA[", 8))
+    return (NULL);
+
+ /*
+  * Return the text following the CDATA declaration...
+  */
+
+  return (node->value.element.name + 8);
+}
+
+
+/*
+ * 'mxmlGetCustom()' - Get the value for a custom node.
+ *
+ * @code NULL@ is returned if the node (or its first child) is not a custom
+ * value node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+const void *				/* O - Custom value or @code NULL@ */
+mxmlGetCustom(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Return the integer value...
+  */
+
+  if (node->type == MXML_CUSTOM)
+    return (node->value.custom.data);
+  else if (node->type == MXML_ELEMENT &&
+           node->child &&
+	   node->child->type == MXML_CUSTOM)
+    return (node->child->value.custom.data);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'mxmlGetElement()' - Get the name for an element node.
+ *
+ * @code NULL@ is returned if the node is not an element node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+const char *				/* O - Element name or @code NULL@ */
+mxmlGetElement(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT)
+    return (NULL);
+
+ /*
+  * Return the element name...
+  */
+
+  return (node->value.element.name);
+}
+
+
+/*
+ * 'mxmlGetFirstChild()' - Get the first child of an element node.
+ *
+ * @code NULL@ is returned if the node is not an element node or if the node
+ * has no children.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_node_t *				/* O - First child or @code NULL@ */
+mxmlGetFirstChild(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT)
+    return (NULL);
+
+ /*
+  * Return the first child node...
+  */
+
+  return (node->child);
+}
+
+
+/*
+ * 'mxmlGetInteger()' - Get the integer value from the specified node or its
+ *                      first child.
+ *
+ * 0 is returned if the node (or its first child) is not an integer value node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+int					/* O - Integer value or 0 */
+mxmlGetInteger(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (0);
+
+ /*
+  * Return the integer value...
+  */
+
+  if (node->type == MXML_INTEGER)
+    return (node->value.integer);
+  else if (node->type == MXML_ELEMENT &&
+           node->child &&
+	   node->child->type == MXML_INTEGER)
+    return (node->child->value.integer);
+  else
+    return (0);
+}
+
+
+/*
+ * 'mxmlGetLastChild()' - Get the last child of an element node.
+ *
+ * @code NULL@ is returned if the node is not an element node or if the node
+ * has no children.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_node_t *				/* O - Last child or @code NULL@ */
+mxmlGetLastChild(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT)
+    return (NULL);
+
+ /*
+  * Return the node type...
+  */
+
+  return (node->last_child);
+}
+
+
+/*
+ * 'mxmlGetNextSibling()' - Get the next node for the current parent.
+ *
+ * @code NULL@ is returned if this is the last child for the current parent.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_node_t *
+mxmlGetNextSibling(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Return the node type...
+  */
+
+  return (node->next);
+}
+
+
+/*
+ * 'mxmlGetOpaque()' - Get an opaque string value for a node or its first child.
+ *
+ * @code NULL@ is returned if the node (or its first child) is not an opaque
+ * value node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+const char *				/* O - Opaque string or @code NULL@ */
+mxmlGetOpaque(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Return the integer value...
+  */
+
+  if (node->type == MXML_OPAQUE)
+    return (node->value.opaque);
+  else if (node->type == MXML_ELEMENT &&
+           node->child &&
+	   node->child->type == MXML_OPAQUE)
+    return (node->child->value.opaque);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'mxmlGetParent()' - Get the parent node.
+ *
+ * @code NULL@ is returned for a root node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_node_t *				/* O - Parent node or @code NULL@ */
+mxmlGetParent(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Return the node type...
+  */
+
+  return (node->parent);
+}
+
+
+/*
+ * 'mxmlGetPrevSibling()' - Get the previous node for the current parent.
+ *
+ * @code NULL@ is returned if this is the first child for the current parent.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_node_t *				/* O - Previous node or @code NULL@ */
+mxmlGetPrevSibling(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Return the node type...
+  */
+
+  return (node->prev);
+}
+
+
+/*
+ * 'mxmlGetReal()' - Get the real value for a node or its first child.
+ *
+ * 0.0 is returned if the node (or its first child) is not a real value node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+double					/* O - Real value or 0.0 */
+mxmlGetReal(mxml_node_t *node)		/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (0.0);
+
+ /*
+  * Return the integer value...
+  */
+
+  if (node->type == MXML_REAL)
+    return (node->value.real);
+  else if (node->type == MXML_ELEMENT &&
+           node->child &&
+	   node->child->type == MXML_REAL)
+    return (node->child->value.real);
+  else
+    return (0.0);
+}
+
+
+/*
+ * 'mxmlGetText()' - Get the text value for a node or its first child.
+ *
+ * @code NULL@ is returned if the node (or its first child) is not a text node.
+ * The "whitespace" argument can be @code NULL@.
+ *
+ * Note: Text nodes consist of whitespace-delimited words. You will only get
+ * single words of text when reading an XML file with @code MXML_TEXT@ nodes.
+ * If you want the entire string between elements in the XML file, you MUST read
+ * the XML file with @code MXML_OPAQUE@ nodes and get the resulting strings
+ * using the @link mxmlGetOpaque@ function instead.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+const char *				/* O - Text string or @code NULL@ */
+mxmlGetText(mxml_node_t *node,		/* I - Node to get */
+            int         *whitespace)	/* O - 1 if string is preceded by whitespace, 0 otherwise */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+  {
+    if (whitespace)
+      *whitespace = 0;
+
+    return (NULL);
+  }
+
+ /*
+  * Return the integer value...
+  */
+
+  if (node->type == MXML_TEXT)
+  {
+    if (whitespace)
+      *whitespace = node->value.text.whitespace;
+
+    return (node->value.text.string);
+  }
+  else if (node->type == MXML_ELEMENT &&
+           node->child &&
+	   node->child->type == MXML_TEXT)
+  {
+    if (whitespace)
+      *whitespace = node->child->value.text.whitespace;
+
+    return (node->child->value.text.string);
+  }
+  else
+  {
+    if (whitespace)
+      *whitespace = 0;
+
+    return (NULL);
+  }
+}
+
+
+/*
+ * 'mxmlGetType()' - Get the node type.
+ *
+ * @code MXML_IGNORE@ is returned if "node" is @code NULL@.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_type_t				/* O - Type of node */
+mxmlGetType(mxml_node_t *node)		/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (MXML_IGNORE);
+
+ /*
+  * Return the node type...
+  */
+
+  return (node->type);
+}
+
+
+/*
+ * 'mxmlGetUserData()' - Get the user data pointer for a node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+void *					/* O - User data pointer */
+mxmlGetUserData(mxml_node_t *node)	/* I - Node to get */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Return the user data pointer...
+  */
+
+  return (node->user_data);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-index.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-index.c
new file mode 100644
index 0000000..3416315
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-index.c
@@ -0,0 +1,652 @@
+/*
+ * Index support code for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml-private.h"
+
+
+/*
+ * Sort functions...
+ */
+
+static int	index_compare(mxml_index_t *ind, mxml_node_t *first,
+		              mxml_node_t *second);
+static int	index_find(mxml_index_t *ind, const char *element,
+		           const char *value, mxml_node_t *node);
+static void	index_sort(mxml_index_t *ind, int left, int right);
+
+
+/*
+ * 'mxmlIndexDelete()' - Delete an index.
+ */
+
+void
+mxmlIndexDelete(mxml_index_t *ind)	/* I - Index to delete */
+{
+ /*
+  * Range check input..
+  */
+
+  if (!ind)
+    return;
+
+ /*
+  * Free memory...
+  */
+
+  if (ind->attr)
+    free(ind->attr);
+
+  if (ind->alloc_nodes)
+    free(ind->nodes);
+
+  free(ind);
+}
+
+
+/*
+ * 'mxmlIndexEnum()' - Return the next node in the index.
+ *
+ * You should call @link mxmlIndexReset@ prior to using this function to get
+ * the first node in the index.  Nodes are returned in the sorted order of the
+ * index.
+ */
+
+mxml_node_t *				/* O - Next node or @code NULL@ if there is none */
+mxmlIndexEnum(mxml_index_t *ind)	/* I - Index to enumerate */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!ind)
+    return (NULL);
+
+ /*
+  * Return the next node...
+  */
+
+  if (ind->cur_node < ind->num_nodes)
+    return (ind->nodes[ind->cur_node ++]);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'mxmlIndexFind()' - Find the next matching node.
+ *
+ * You should call @link mxmlIndexReset@ prior to using this function for
+ * the first time with a particular set of "element" and "value"
+ * strings. Passing @code NULL@ for both "element" and "value" is equivalent
+ * to calling @link mxmlIndexEnum@.
+ */
+
+mxml_node_t *				/* O - Node or @code NULL@ if none found */
+mxmlIndexFind(mxml_index_t *ind,	/* I - Index to search */
+              const char   *element,	/* I - Element name to find, if any */
+	      const char   *value)	/* I - Attribute value, if any */
+{
+  int		diff,			/* Difference between names */
+		current,		/* Current entity in search */
+		first,			/* First entity in search */
+		last;			/* Last entity in search */
+
+
+#ifdef DEBUG
+  printf("mxmlIndexFind(ind=%p, element=\"%s\", value=\"%s\")\n",
+         ind, element ? element : "(null)", value ? value : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!ind || (!ind->attr && value))
+  {
+#ifdef DEBUG
+    puts("    returning NULL...");
+    if (ind)
+      printf("    ind->attr=\"%s\"\n", ind->attr ? ind->attr : "(null)");
+#endif /* DEBUG */
+
+    return (NULL);
+  }
+
+ /*
+  * If both element and value are NULL, just enumerate the nodes in the
+  * index...
+  */
+
+  if (!element && !value)
+    return (mxmlIndexEnum(ind));
+
+ /*
+  * If there are no nodes in the index, return NULL...
+  */
+
+  if (!ind->num_nodes)
+  {
+#ifdef DEBUG
+    puts("    returning NULL...");
+    puts("    no nodes!");
+#endif /* DEBUG */
+
+    return (NULL);
+  }
+
+ /*
+  * If cur_node == 0, then find the first matching node...
+  */
+
+  if (ind->cur_node == 0)
+  {
+   /*
+    * Find the first node using a modified binary search algorithm...
+    */
+
+    first = 0;
+    last  = ind->num_nodes - 1;
+
+#ifdef DEBUG
+    printf("    find first time, num_nodes=%d...\n", ind->num_nodes);
+#endif /* DEBUG */
+
+    while ((last - first) > 1)
+    {
+      current = (first + last) / 2;
+
+#ifdef DEBUG
+      printf("    first=%d, last=%d, current=%d\n", first, last, current);
+#endif /* DEBUG */
+
+      if ((diff = index_find(ind, element, value, ind->nodes[current])) == 0)
+      {
+       /*
+        * Found a match, move back to find the first...
+	*/
+
+#ifdef DEBUG
+        puts("    match!");
+#endif /* DEBUG */
+
+        while (current > 0 &&
+	       !index_find(ind, element, value, ind->nodes[current - 1]))
+	  current --;
+
+#ifdef DEBUG
+        printf("    returning first match=%d\n", current);
+#endif /* DEBUG */
+
+       /*
+        * Return the first match and save the index to the next...
+	*/
+
+        ind->cur_node = current + 1;
+
+	return (ind->nodes[current]);
+      }
+      else if (diff < 0)
+	last = current;
+      else
+	first = current;
+
+#ifdef DEBUG
+      printf("    diff=%d\n", diff);
+#endif /* DEBUG */
+    }
+
+   /*
+    * If we get this far, then we found exactly 0 or 1 matches...
+    */
+
+    for (current = first; current <= last; current ++)
+      if (!index_find(ind, element, value, ind->nodes[current]))
+      {
+       /*
+	* Found exactly one (or possibly two) match...
+	*/
+
+#ifdef DEBUG
+	printf("    returning only match %d...\n", current);
+#endif /* DEBUG */
+
+	ind->cur_node = current + 1;
+
+	return (ind->nodes[current]);
+      }
+
+   /*
+    * No matches...
+    */
+
+    ind->cur_node = ind->num_nodes;
+
+#ifdef DEBUG
+    puts("    returning NULL...");
+#endif /* DEBUG */
+
+    return (NULL);
+  }
+  else if (ind->cur_node < ind->num_nodes &&
+           !index_find(ind, element, value, ind->nodes[ind->cur_node]))
+  {
+   /*
+    * Return the next matching node...
+    */
+
+#ifdef DEBUG
+    printf("    returning next match %d...\n", ind->cur_node);
+#endif /* DEBUG */
+
+    return (ind->nodes[ind->cur_node ++]);
+  }
+
+ /*
+  * If we get this far, then we have no matches...
+  */
+
+  ind->cur_node = ind->num_nodes;
+
+#ifdef DEBUG
+  puts("    returning NULL...");
+#endif /* DEBUG */
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxmlIndexGetCount()' - Get the number of nodes in an index.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+int					/* I - Number of nodes in index */
+mxmlIndexGetCount(mxml_index_t *ind)	/* I - Index of nodes */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!ind)
+    return (0);
+
+ /*
+  * Return the number of nodes in the index...
+  */
+
+  return (ind->num_nodes);
+}
+
+
+/*
+ * 'mxmlIndexNew()' - Create a new index.
+ *
+ * The index will contain all nodes that contain the named element and/or
+ * attribute.  If both "element" and "attr" are @code NULL@, then the index will
+ * contain a sorted list of the elements in the node tree.  Nodes are
+ * sorted by element name and optionally by attribute value if the "attr"
+ * argument is not NULL.
+ */
+
+mxml_index_t *				/* O - New index */
+mxmlIndexNew(mxml_node_t *node,		/* I - XML node tree */
+             const char  *element,	/* I - Element to index or @code NULL@ for all */
+             const char  *attr)		/* I - Attribute to index or @code NULL@ for none */
+{
+  mxml_index_t	*ind;			/* New index */
+  mxml_node_t	*current,		/* Current node in index */
+  		**temp;			/* Temporary node pointer array */
+
+
+ /*
+  * Range check input...
+  */
+
+#ifdef DEBUG
+  printf("mxmlIndexNew(node=%p, element=\"%s\", attr=\"%s\")\n",
+         node, element ? element : "(null)", attr ? attr : "(null)");
+#endif /* DEBUG */
+
+  if (!node)
+    return (NULL);
+
+ /*
+  * Create a new index...
+  */
+
+  if ((ind = calloc(1, sizeof(mxml_index_t))) == NULL)
+  {
+    mxml_error("Unable to allocate %d bytes for index - %s",
+               sizeof(mxml_index_t), strerror(errno));
+    return (NULL);
+  }
+
+  if (attr)
+    ind->attr = strdup(attr);
+
+  if (!element && !attr)
+    current = node;
+  else
+    current = mxmlFindElement(node, node, element, attr, NULL, MXML_DESCEND);
+
+  while (current)
+  {
+    if (ind->num_nodes >= ind->alloc_nodes)
+    {
+      if (!ind->alloc_nodes)
+        temp = malloc(64 * sizeof(mxml_node_t *));
+      else
+        temp = realloc(ind->nodes, (ind->alloc_nodes + 64) * sizeof(mxml_node_t *));
+
+      if (!temp)
+      {
+       /*
+        * Unable to allocate memory for the index, so abort...
+	*/
+
+        mxml_error("Unable to allocate %d bytes for index: %s",
+	           (ind->alloc_nodes + 64) * sizeof(mxml_node_t *),
+		   strerror(errno));
+
+        mxmlIndexDelete(ind);
+	return (NULL);
+      }
+
+      ind->nodes       = temp;
+      ind->alloc_nodes += 64;
+    }
+
+    ind->nodes[ind->num_nodes ++] = current;
+
+    current = mxmlFindElement(current, node, element, attr, NULL, MXML_DESCEND);
+  }
+
+ /*
+  * Sort nodes based upon the search criteria...
+  */
+
+#ifdef DEBUG
+  {
+    int i;				/* Looping var */
+
+
+    printf("%d node(s) in index.\n\n", ind->num_nodes);
+
+    if (attr)
+    {
+      printf("Node      Address   Element         %s\n", attr);
+      puts("--------  --------  --------------  ------------------------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %-14.14s  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name,
+	       mxmlElementGetAttr(ind->nodes[i], attr));
+    }
+    else
+    {
+      puts("Node      Address   Element");
+      puts("--------  --------  --------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name);
+    }
+
+    putchar('\n');
+  }
+#endif /* DEBUG */
+
+  if (ind->num_nodes > 1)
+    index_sort(ind, 0, ind->num_nodes - 1);
+
+#ifdef DEBUG
+  {
+    int i;				/* Looping var */
+
+
+    puts("After sorting:\n");
+
+    if (attr)
+    {
+      printf("Node      Address   Element         %s\n", attr);
+      puts("--------  --------  --------------  ------------------------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %-14.14s  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name,
+	       mxmlElementGetAttr(ind->nodes[i], attr));
+    }
+    else
+    {
+      puts("Node      Address   Element");
+      puts("--------  --------  --------------");
+
+      for (i = 0; i < ind->num_nodes; i ++)
+	printf("%8d  %-8p  %s\n", i, ind->nodes[i],
+	       ind->nodes[i]->value.element.name);
+    }
+
+    putchar('\n');
+  }
+#endif /* DEBUG */
+
+ /*
+  * Return the new index...
+  */
+
+  return (ind);
+}
+
+
+/*
+ * 'mxmlIndexReset()' - Reset the enumeration/find pointer in the index and
+ *                      return the first node in the index.
+ *
+ * This function should be called prior to using @link mxmlIndexEnum@ or
+ * @link mxmlIndexFind@ for the first time.
+ */
+
+mxml_node_t *				/* O - First node or @code NULL@ if there is none */
+mxmlIndexReset(mxml_index_t *ind)	/* I - Index to reset */
+{
+#ifdef DEBUG
+  printf("mxmlIndexReset(ind=%p)\n", ind);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!ind)
+    return (NULL);
+
+ /*
+  * Set the index to the first element...
+  */
+
+  ind->cur_node = 0;
+
+ /*
+  * Return the first node...
+  */
+
+  if (ind->num_nodes)
+    return (ind->nodes[0]);
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'index_compare()' - Compare two nodes.
+ */
+
+static int				/* O - Result of comparison */
+index_compare(mxml_index_t *ind,	/* I - Index */
+              mxml_node_t  *first,	/* I - First node */
+              mxml_node_t  *second)	/* I - Second node */
+{
+  int	diff;				/* Difference */
+
+
+ /*
+  * Check the element name...
+  */
+
+  if ((diff = strcmp(first->value.element.name,
+                     second->value.element.name)) != 0)
+    return (diff);
+
+ /*
+  * Check the attribute value...
+  */
+
+  if (ind->attr)
+  {
+    if ((diff = strcmp(mxmlElementGetAttr(first, ind->attr),
+                       mxmlElementGetAttr(second, ind->attr))) != 0)
+      return (diff);
+  }
+
+ /*
+  * No difference, return 0...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'index_find()' - Compare a node with index values.
+ */
+
+static int				/* O - Result of comparison */
+index_find(mxml_index_t *ind,		/* I - Index */
+           const char   *element,	/* I - Element name or @code NULL@ */
+	   const char   *value,		/* I - Attribute value or @code NULL@ */
+           mxml_node_t  *node)		/* I - Node */
+{
+  int	diff;				/* Difference */
+
+
+ /*
+  * Check the element name...
+  */
+
+  if (element)
+  {
+    if ((diff = strcmp(element, node->value.element.name)) != 0)
+      return (diff);
+  }
+
+ /*
+  * Check the attribute value...
+  */
+
+  if (value)
+  {
+    if ((diff = strcmp(value, mxmlElementGetAttr(node, ind->attr))) != 0)
+      return (diff);
+  }
+
+ /*
+  * No difference, return 0...
+  */
+
+  return (0);
+}
+
+
+/*
+ * 'index_sort()' - Sort the nodes in the index...
+ *
+ * This function implements the classic quicksort algorithm...
+ */
+
+static void
+index_sort(mxml_index_t *ind,		/* I - Index to sort */
+           int          left,		/* I - Left node in partition */
+	   int          right)		/* I - Right node in partition */
+{
+  mxml_node_t	*pivot,			/* Pivot node */
+		*temp;			/* Swap node */
+  int		templ,			/* Temporary left node */
+		tempr;			/* Temporary right node */
+
+
+ /*
+  * Loop until we have sorted all the way to the right...
+  */
+
+  do
+  {
+   /*
+    * Sort the pivot in the current partition...
+    */
+
+    pivot = ind->nodes[left];
+
+    for (templ = left, tempr = right; templ < tempr;)
+    {
+     /*
+      * Move left while left node <= pivot node...
+      */
+
+      while ((templ < right) &&
+             index_compare(ind, ind->nodes[templ], pivot) <= 0)
+	templ ++;
+
+     /*
+      * Move right while right node > pivot node...
+      */
+
+      while ((tempr > left) &&
+             index_compare(ind, ind->nodes[tempr], pivot) > 0)
+	tempr --;
+
+     /*
+      * Swap nodes if needed...
+      */
+
+      if (templ < tempr)
+      {
+	temp              = ind->nodes[templ];
+	ind->nodes[templ] = ind->nodes[tempr];
+	ind->nodes[tempr] = temp;
+      }
+    }
+
+   /*
+    * When we get here, the right (tempr) node is the new position for the
+    * pivot node...
+    */
+
+    if (index_compare(ind, pivot, ind->nodes[tempr]) > 0)
+    {
+      ind->nodes[left]  = ind->nodes[tempr];
+      ind->nodes[tempr] = pivot;
+    }
+
+   /*
+    * Recursively sort the left partition as needed...
+    */
+
+    if (left < (tempr - 1))
+      index_sort(ind, left, tempr - 1);
+  }
+  while (right > (left = tempr + 1));
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-node.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-node.c
new file mode 100644
index 0000000..cad0b1c
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-node.c
@@ -0,0 +1,873 @@
+/*
+ * Node support code for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml-private.h"
+
+
+/*
+ * Local functions...
+ */
+
+static void		mxml_free(mxml_node_t *node);
+static mxml_node_t	*mxml_new(mxml_node_t *parent, mxml_type_t type);
+
+
+/*
+ * 'mxmlAdd()' - Add a node to a tree.
+ *
+ * Adds the specified node to the parent.  If the child argument is not
+ * @code NULL@, puts the new node before or after the specified child depending
+ * on the value of the where argument.  If the child argument is @code NULL@,
+ * puts the new node at the beginning of the child list (@code MXML_ADD_BEFORE@)
+ * or at the end of the child list (@code MXML_ADD_AFTER@).  The constant
+ * @code MXML_ADD_TO_PARENT@ can be used to specify a @code NULL@ child pointer.
+ */
+
+void
+mxmlAdd(mxml_node_t *parent,		/* I - Parent node */
+        int         where,		/* I - Where to add, @code MXML_ADD_BEFORE@ or @code MXML_ADD_AFTER@ */
+        mxml_node_t *child,		/* I - Child node for where or @code MXML_ADD_TO_PARENT@ */
+	mxml_node_t *node)		/* I - Node to add */
+{
+#ifdef DEBUG
+  fprintf(stderr, "mxmlAdd(parent=%p, where=%d, child=%p, node=%p)\n", parent,
+          where, child, node);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!parent || !node)
+    return;
+
+#if DEBUG > 1
+  fprintf(stderr, "    BEFORE: node->parent=%p\n", node->parent);
+  if (parent)
+  {
+    fprintf(stderr, "    BEFORE: parent->child=%p\n", parent->child);
+    fprintf(stderr, "    BEFORE: parent->last_child=%p\n", parent->last_child);
+    fprintf(stderr, "    BEFORE: parent->prev=%p\n", parent->prev);
+    fprintf(stderr, "    BEFORE: parent->next=%p\n", parent->next);
+  }
+#endif /* DEBUG > 1 */
+
+ /*
+  * Remove the node from any existing parent...
+  */
+
+  if (node->parent)
+    mxmlRemove(node);
+
+ /*
+  * Reset pointers...
+  */
+
+  node->parent = parent;
+
+  switch (where)
+  {
+    case MXML_ADD_BEFORE :
+        if (!child || child == parent->child || child->parent != parent)
+	{
+	 /*
+	  * Insert as first node under parent...
+	  */
+
+	  node->next = parent->child;
+
+	  if (parent->child)
+	    parent->child->prev = node;
+	  else
+	    parent->last_child = node;
+
+	  parent->child = node;
+	}
+	else
+	{
+	 /*
+	  * Insert node before this child...
+	  */
+
+	  node->next = child;
+	  node->prev = child->prev;
+
+	  if (child->prev)
+	    child->prev->next = node;
+	  else
+	    parent->child = node;
+
+	  child->prev = node;
+	}
+        break;
+
+    case MXML_ADD_AFTER :
+        if (!child || child == parent->last_child || child->parent != parent)
+	{
+	 /*
+	  * Insert as last node under parent...
+	  */
+
+	  node->parent = parent;
+	  node->prev   = parent->last_child;
+
+	  if (parent->last_child)
+	    parent->last_child->next = node;
+	  else
+	    parent->child = node;
+
+	  parent->last_child = node;
+        }
+	else
+	{
+	 /*
+	  * Insert node after this child...
+	  */
+
+	  node->prev = child;
+	  node->next = child->next;
+
+	  if (child->next)
+	    child->next->prev = node;
+	  else
+	    parent->last_child = node;
+
+	  child->next = node;
+	}
+        break;
+  }
+
+#if DEBUG > 1
+  fprintf(stderr, "    AFTER: node->parent=%p\n", node->parent);
+  if (parent)
+  {
+    fprintf(stderr, "    AFTER: parent->child=%p\n", parent->child);
+    fprintf(stderr, "    AFTER: parent->last_child=%p\n", parent->last_child);
+    fprintf(stderr, "    AFTER: parent->prev=%p\n", parent->prev);
+    fprintf(stderr, "    AFTER: parent->next=%p\n", parent->next);
+  }
+#endif /* DEBUG > 1 */
+}
+
+
+/*
+ * 'mxmlDelete()' - Delete a node and all of its children.
+ *
+ * If the specified node has a parent, this function first removes the
+ * node from its parent using the @link mxmlRemove@ function.
+ */
+
+void
+mxmlDelete(mxml_node_t *node)		/* I - Node to delete */
+{
+  mxml_node_t	*current,		/* Current node */
+		*next;			/* Next node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlDelete(node=%p)\n", node);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return;
+
+ /*
+  * Remove the node from its parent, if any...
+  */
+
+  mxmlRemove(node);
+
+ /*
+  * Delete children...
+  */
+
+  for (current = node->child; current; current = next)
+  {
+   /*
+    * Get the next node...
+    */
+
+    if ((next = current->child) != NULL)
+    {
+     /*
+      * Free parent nodes after child nodes have been freed...
+      */
+
+      current->child = NULL;
+      continue;
+    }
+
+    if ((next = current->next) == NULL)
+    {
+     /*
+      * Next node is the parent, which we'll free as needed...
+      */
+
+      if ((next = current->parent) == node)
+        next = NULL;
+    }
+
+   /*
+    * Free child...
+    */
+
+    mxml_free(current);
+  }
+
+ /*
+  * Then free the memory used by the parent node...
+  */
+
+  mxml_free(node);
+}
+
+
+/*
+ * 'mxmlGetRefCount()' - Get the current reference (use) count for a node.
+ *
+ * The initial reference count of new nodes is 1. Use the @link mxmlRetain@
+ * and @link mxmlRelease@ functions to increment and decrement a node's
+ * reference count.
+ *
+ * @since Mini-XML 2.7@.
+ */
+
+int					/* O - Reference count */
+mxmlGetRefCount(mxml_node_t *node)	/* I - Node */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (0);
+
+ /*
+  * Return the reference count...
+  */
+
+  return (node->ref_count);
+}
+
+
+/*
+ * 'mxmlNewCDATA()' - Create a new CDATA node.
+ *
+ * The new CDATA node is added to the end of the specified parent's child
+ * list.  The constant @code MXML_NO_PARENT@ can be used to specify that the new
+ * CDATA node has no parent.  The data string must be nul-terminated and
+ * is copied into the new node.  CDATA nodes currently use the
+ * @code MXML_ELEMENT@ type.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewCDATA(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+	     const char  *data)		/* I - Data string */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewCDATA(parent=%p, data=\"%s\")\n",
+          parent, data ? data : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!data)
+    return (NULL);
+
+ /*
+  * Create the node and set the name value...
+  */
+
+  if ((node = mxml_new(parent, MXML_ELEMENT)) != NULL)
+    node->value.element.name = _mxml_strdupf("![CDATA[%s", data);
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewCustom()' - Create a new custom data node.
+ *
+ * The new custom node is added to the end of the specified parent's child
+ * list. The constant @code MXML_NO_PARENT@ can be used to specify that the new
+ * element node has no parent. @code NULL@ can be passed when the data in the
+ * node is not dynamically allocated or is separately managed.
+ *
+ * @since Mini-XML 2.1@
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewCustom(
+    mxml_node_t              *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+    void                     *data,	/* I - Pointer to data */
+    mxml_custom_destroy_cb_t destroy)	/* I - Function to destroy data */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewCustom(parent=%p, data=%p, destroy=%p)\n", parent,
+          data, destroy);
+#endif /* DEBUG */
+
+ /*
+  * Create the node and set the value...
+  */
+
+  if ((node = mxml_new(parent, MXML_CUSTOM)) != NULL)
+  {
+    node->value.custom.data    = data;
+    node->value.custom.destroy = destroy;
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewElement()' - Create a new element node.
+ *
+ * The new element node is added to the end of the specified parent's child
+ * list. The constant @code MXML_NO_PARENT@ can be used to specify that the new
+ * element node has no parent.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewElement(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+               const char  *name)	/* I - Name of element */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewElement(parent=%p, name=\"%s\")\n", parent,
+          name ? name : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!name)
+    return (NULL);
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_ELEMENT)) != NULL)
+    node->value.element.name = strdup(name);
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewInteger()' - Create a new integer node.
+ *
+ * The new integer node is added to the end of the specified parent's child
+ * list. The constant @code MXML_NO_PARENT@ can be used to specify that the new
+ * integer node has no parent.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewInteger(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+               int         integer)	/* I - Integer value */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewInteger(parent=%p, integer=%d)\n", parent, integer);
+#endif /* DEBUG */
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_INTEGER)) != NULL)
+    node->value.integer = integer;
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewOpaque()' - Create a new opaque string.
+ *
+ * The new opaque string node is added to the end of the specified parent's
+ * child list.  The constant @code MXML_NO_PARENT@ can be used to specify that
+ * the new opaque string node has no parent.  The opaque string must be nul-
+ * terminated and is copied into the new node.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewOpaque(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+              const char  *opaque)	/* I - Opaque string */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewOpaque(parent=%p, opaque=\"%s\")\n", parent,
+          opaque ? opaque : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!opaque)
+    return (NULL);
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_OPAQUE)) != NULL)
+    node->value.opaque = strdup(opaque);
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewOpaquef()' - Create a new formatted opaque string node.
+ *
+ * The new opaque string node is added to the end of the specified parent's
+ * child list.  The constant @code MXML_NO_PARENT@ can be used to specify that
+ * the new opaque string node has no parent.  The format string must be
+ * nul-terminated and is formatted into the new node.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewOpaquef(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+               const char  *format,	/* I - Printf-style format string */
+	       ...)			/* I - Additional args as needed */
+{
+  mxml_node_t	*node;			/* New node */
+  va_list	ap;			/* Pointer to arguments */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewOpaquef(parent=%p, format=\"%s\", ...)\n", parent, format ? format : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!format)
+    return (NULL);
+
+ /*
+  * Create the node and set the text value...
+  */
+
+  if ((node = mxml_new(parent, MXML_OPAQUE)) != NULL)
+  {
+    va_start(ap, format);
+
+    node->value.opaque = _mxml_vstrdupf(format, ap);
+
+    va_end(ap);
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewReal()' - Create a new real number node.
+ *
+ * The new real number node is added to the end of the specified parent's
+ * child list.  The constant @code MXML_NO_PARENT@ can be used to specify that
+ * the new real number node has no parent.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewReal(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+            double      real)		/* I - Real number value */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewReal(parent=%p, real=%g)\n", parent, real);
+#endif /* DEBUG */
+
+ /*
+  * Create the node and set the element name...
+  */
+
+  if ((node = mxml_new(parent, MXML_REAL)) != NULL)
+    node->value.real = real;
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewText()' - Create a new text fragment node.
+ *
+ * The new text node is added to the end of the specified parent's child
+ * list.  The constant @code MXML_NO_PARENT@ can be used to specify that the new
+ * text node has no parent.  The whitespace parameter is used to specify
+ * whether leading whitespace is present before the node.  The text
+ * string must be nul-terminated and is copied into the new node.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewText(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+            int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+	    const char  *string)	/* I - String */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewText(parent=%p, whitespace=%d, string=\"%s\")\n",
+          parent, whitespace, string ? string : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!string)
+    return (NULL);
+
+ /*
+  * Create the node and set the text value...
+  */
+
+  if ((node = mxml_new(parent, MXML_TEXT)) != NULL)
+  {
+    node->value.text.whitespace = whitespace;
+    node->value.text.string     = strdup(string);
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlNewTextf()' - Create a new formatted text fragment node.
+ *
+ * The new text node is added to the end of the specified parent's child
+ * list.  The constant @code MXML_NO_PARENT@ can be used to specify that the new
+ * text node has no parent.  The whitespace parameter is used to specify
+ * whether leading whitespace is present before the node.  The format
+ * string must be nul-terminated and is formatted into the new node.
+ */
+
+mxml_node_t *				/* O - New node */
+mxmlNewTextf(mxml_node_t *parent,	/* I - Parent node or @code MXML_NO_PARENT@ */
+             int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+	     const char  *format,	/* I - Printf-style format string */
+	     ...)			/* I - Additional args as needed */
+{
+  mxml_node_t	*node;			/* New node */
+  va_list	ap;			/* Pointer to arguments */
+
+
+#ifdef DEBUG
+  fprintf(stderr, "mxmlNewTextf(parent=%p, whitespace=%d, format=\"%s\", ...)\n",
+          parent, whitespace, format ? format : "(null)");
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!format)
+    return (NULL);
+
+ /*
+  * Create the node and set the text value...
+  */
+
+  if ((node = mxml_new(parent, MXML_TEXT)) != NULL)
+  {
+    va_start(ap, format);
+
+    node->value.text.whitespace = whitespace;
+    node->value.text.string     = _mxml_vstrdupf(format, ap);
+
+    va_end(ap);
+  }
+
+  return (node);
+}
+
+
+/*
+ * 'mxmlRemove()' - Remove a node from its parent.
+ *
+ * This function does not free memory used by the node - use @link mxmlDelete@
+ * for that.  This function does nothing if the node has no parent.
+ */
+
+void
+mxmlRemove(mxml_node_t *node)		/* I - Node to remove */
+{
+#ifdef DEBUG
+  fprintf(stderr, "mxmlRemove(node=%p)\n", node);
+#endif /* DEBUG */
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || !node->parent)
+    return;
+
+ /*
+  * Remove from parent...
+  */
+
+#if DEBUG > 1
+  fprintf(stderr, "    BEFORE: node->parent=%p\n", node->parent);
+  if (node->parent)
+  {
+    fprintf(stderr, "    BEFORE: node->parent->child=%p\n", node->parent->child);
+    fprintf(stderr, "    BEFORE: node->parent->last_child=%p\n", node->parent->last_child);
+  }
+  fprintf(stderr, "    BEFORE: node->child=%p\n", node->child);
+  fprintf(stderr, "    BEFORE: node->last_child=%p\n", node->last_child);
+  fprintf(stderr, "    BEFORE: node->prev=%p\n", node->prev);
+  fprintf(stderr, "    BEFORE: node->next=%p\n", node->next);
+#endif /* DEBUG > 1 */
+
+  if (node->prev)
+    node->prev->next = node->next;
+  else
+    node->parent->child = node->next;
+
+  if (node->next)
+    node->next->prev = node->prev;
+  else
+    node->parent->last_child = node->prev;
+
+  node->parent = NULL;
+  node->prev   = NULL;
+  node->next   = NULL;
+
+#if DEBUG > 1
+  fprintf(stderr, "    AFTER: node->parent=%p\n", node->parent);
+  if (node->parent)
+  {
+    fprintf(stderr, "    AFTER: node->parent->child=%p\n", node->parent->child);
+    fprintf(stderr, "    AFTER: node->parent->last_child=%p\n", node->parent->last_child);
+  }
+  fprintf(stderr, "    AFTER: node->child=%p\n", node->child);
+  fprintf(stderr, "    AFTER: node->last_child=%p\n", node->last_child);
+  fprintf(stderr, "    AFTER: node->prev=%p\n", node->prev);
+  fprintf(stderr, "    AFTER: node->next=%p\n", node->next);
+#endif /* DEBUG > 1 */
+}
+
+
+/*
+ * 'mxmlNewXML()' - Create a new XML document tree.
+ *
+ * The "version" argument specifies the version number to put in the
+ * ?xml element node. If @code NULL@, version "1.0" is assumed.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+mxml_node_t *				/* O - New ?xml node */
+mxmlNewXML(const char *version)		/* I - Version number to use */
+{
+  char	element[1024];			/* Element text */
+
+
+  snprintf(element, sizeof(element), "?xml version=\"%s\" encoding=\"utf-8\"?",
+           version ? version : "1.0");
+
+  return (mxmlNewElement(NULL, element));
+}
+
+
+/*
+ * 'mxmlRelease()' - Release a node.
+ *
+ * When the reference count reaches zero, the node (and any children)
+ * is deleted via @link mxmlDelete@.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+int					/* O - New reference count */
+mxmlRelease(mxml_node_t *node)		/* I - Node */
+{
+  if (node)
+  {
+    if ((-- node->ref_count) <= 0)
+    {
+      mxmlDelete(node);
+      return (0);
+    }
+    else
+      return (node->ref_count);
+  }
+  else
+    return (-1);
+}
+
+
+/*
+ * 'mxmlRetain()' - Retain a node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+int					/* O - New reference count */
+mxmlRetain(mxml_node_t *node)		/* I - Node */
+{
+  if (node)
+    return (++ node->ref_count);
+  else
+    return (-1);
+}
+
+
+/*
+ * 'mxml_free()' - Free the memory used by a node.
+ *
+ * Note: Does not free child nodes, does not remove from parent.
+ */
+
+static void
+mxml_free(mxml_node_t *node)		/* I - Node */
+{
+  int	i;				/* Looping var */
+
+
+  switch (node->type)
+  {
+    case MXML_ELEMENT :
+        if (node->value.element.name)
+	  free(node->value.element.name);
+
+	if (node->value.element.num_attrs)
+	{
+	  for (i = 0; i < node->value.element.num_attrs; i ++)
+	  {
+	    if (node->value.element.attrs[i].name)
+	      free(node->value.element.attrs[i].name);
+	    if (node->value.element.attrs[i].value)
+	      free(node->value.element.attrs[i].value);
+	  }
+
+          free(node->value.element.attrs);
+	}
+        break;
+    case MXML_INTEGER :
+       /* Nothing to do */
+        break;
+    case MXML_OPAQUE :
+        if (node->value.opaque)
+	  free(node->value.opaque);
+        break;
+    case MXML_REAL :
+       /* Nothing to do */
+        break;
+    case MXML_TEXT :
+        if (node->value.text.string)
+	  free(node->value.text.string);
+        break;
+    case MXML_CUSTOM :
+        if (node->value.custom.data &&
+	    node->value.custom.destroy)
+	  (*(node->value.custom.destroy))(node->value.custom.data);
+	break;
+    default :
+        break;
+  }
+
+ /*
+  * Free this node...
+  */
+
+  free(node);
+}
+
+
+/*
+ * 'mxml_new()' - Create a new node.
+ */
+
+static mxml_node_t *			/* O - New node */
+mxml_new(mxml_node_t *parent,		/* I - Parent node */
+         mxml_type_t type)		/* I - Node type */
+{
+  mxml_node_t	*node;			/* New node */
+
+
+#if DEBUG > 1
+  fprintf(stderr, "mxml_new(parent=%p, type=%d)\n", parent, type);
+#endif /* DEBUG > 1 */
+
+ /*
+  * Allocate memory for the node...
+  */
+
+  if ((node = calloc(1, sizeof(mxml_node_t))) == NULL)
+  {
+#if DEBUG > 1
+    fputs("    returning NULL\n", stderr);
+#endif /* DEBUG > 1 */
+
+    return (NULL);
+  }
+
+#if DEBUG > 1
+  fprintf(stderr, "    returning %p\n", node);
+#endif /* DEBUG > 1 */
+
+ /*
+  * Set the node type...
+  */
+
+  node->type      = type;
+  node->ref_count = 1;
+
+ /*
+  * Add to the parent if present...
+  */
+
+  if (parent)
+    mxmlAdd(parent, MXML_ADD_AFTER, MXML_ADD_TO_PARENT, node);
+
+ /*
+  * Return the new node...
+  */
+
+  return (node);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-private.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-private.c
new file mode 100644
index 0000000..726acc9
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-private.c
@@ -0,0 +1,313 @@
+/*
+ * Private functions for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "mxml-private.h"
+
+
+/*
+ * Some crazy people think that unloading a shared object is a good or safe
+ * thing to do.  Unfortunately, most objects are simply *not* safe to unload
+ * and bad things *will* happen.
+ *
+ * The following mess of conditional code allows us to provide a destructor
+ * function in Mini-XML for our thread-global storage so that it can possibly
+ * be unloaded safely, although since there is no standard way to do so I
+ * can't even provide any guarantees that you can do it safely on all platforms.
+ *
+ * This code currently supports AIX, HP-UX, Linux, Mac OS X, Solaris, and
+ * Windows.  It might work on the BSDs and IRIX, but I haven't tested that.
+ */
+
+#if defined(__sun) || defined(_AIX)
+#  pragma fini(_mxml_fini)
+#  define _MXML_FINI _mxml_fini
+#elif defined(__hpux)
+#  pragma FINI _mxml_fini
+#  define _MXML_FINI _mxml_fini
+#elif defined(__GNUC__) /* Linux and Mac OS X */
+#  define _MXML_FINI __attribute((destructor)) _mxml_fini
+#else
+#  define _MXML_FINI _fini
+#endif /* __sun */
+
+
+/*
+ * 'mxml_error()' - Display an error message.
+ */
+
+void
+mxml_error(const char *format,		/* I - Printf-style format string */
+           ...)				/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to arguments */
+  char		s[1024];		/* Message string */
+  _mxml_global_t *global = _mxml_global();
+					/* Global data */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!format)
+    return;
+
+ /*
+  * Format the error message string...
+  */
+
+  va_start(ap, format);
+
+  vsnprintf(s, sizeof(s), format, ap);
+
+  va_end(ap);
+
+ /*
+  * And then display the error message...
+  */
+
+  if (global->error_cb)
+    (*global->error_cb)(s);
+  else
+    fprintf(stderr, "mxml: %s\n", s);
+}
+
+
+/*
+ * 'mxml_ignore_cb()' - Default callback for ignored values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_ignore_cb(mxml_node_t *node)	/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_IGNORE);
+}
+
+
+/*
+ * 'mxml_integer_cb()' - Default callback for integer values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_integer_cb(mxml_node_t *node)	/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_INTEGER);
+}
+
+
+/*
+ * 'mxml_opaque_cb()' - Default callback for opaque values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_opaque_cb(mxml_node_t *node)	/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_OPAQUE);
+}
+
+
+/*
+ * 'mxml_real_cb()' - Default callback for real number values.
+ */
+
+mxml_type_t				/* O - Node type */
+mxml_real_cb(mxml_node_t *node)		/* I - Current node */
+{
+  (void)node;
+
+  return (MXML_REAL);
+}
+
+
+#ifdef HAVE_PTHREAD_H			/**** POSIX threading ****/
+#  include <pthread.h>
+
+static pthread_key_t	_mxml_key = -1;	/* Thread local storage key */
+static pthread_once_t	_mxml_key_once = PTHREAD_ONCE_INIT;
+					/* One-time initialization object */
+static void		_mxml_init(void);
+static void		_mxml_destructor(void *g);
+
+
+/*
+ * '_mxml_destructor()' - Free memory used for globals...
+ */
+
+static void
+_mxml_destructor(void *g)		/* I - Global data */
+{
+  free(g);
+}
+
+
+/*
+ * '_mxml_fini()' - Clean up when unloaded.
+ */
+
+static void
+_MXML_FINI(void)
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  if (_mxml_key != -1)
+  {
+    if ((global = (_mxml_global_t *)pthread_getspecific(_mxml_key)) != NULL)
+      _mxml_destructor(global);
+
+    pthread_key_delete(_mxml_key);
+    _mxml_key = -1;
+  }
+}
+
+
+/*
+ * '_mxml_global()' - Get global data.
+ */
+
+_mxml_global_t *			/* O - Global data */
+_mxml_global(void)
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  pthread_once(&_mxml_key_once, _mxml_init);
+
+  if ((global = (_mxml_global_t *)pthread_getspecific(_mxml_key)) == NULL)
+  {
+    global = (_mxml_global_t *)calloc(1, sizeof(_mxml_global_t));
+    pthread_setspecific(_mxml_key, global);
+
+    global->num_entity_cbs = 1;
+    global->entity_cbs[0]  = _mxml_entity_cb;
+    global->wrap           = 72;
+  }
+
+  return (global);
+}
+
+
+/*
+ * '_mxml_init()' - Initialize global data...
+ */
+
+static void
+_mxml_init(void)
+{
+  pthread_key_create(&_mxml_key, _mxml_destructor);
+}
+
+
+#elif defined(_WIN32) && defined(MXML1_EXPORTS) /**** WIN32 threading ****/
+#  include <windows.h>
+
+static DWORD _mxml_tls_index;		/* Index for global storage */
+
+
+/*
+ * 'DllMain()' - Main entry for library.
+ */
+
+BOOL WINAPI				/* O - Success/failure */
+DllMain(HINSTANCE hinst,		/* I - DLL module handle */
+        DWORD     reason,		/* I - Reason */
+        LPVOID    reserved)		/* I - Unused */
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  (void)hinst;
+  (void)reserved;
+
+  switch (reason)
+  {
+    case DLL_PROCESS_ATTACH :		/* Called on library initialization */
+        if ((_mxml_tls_index = TlsAlloc()) == TLS_OUT_OF_INDEXES)
+          return (FALSE);
+        break;
+
+    case DLL_THREAD_DETACH :		/* Called when a thread terminates */
+        if ((global = (_mxml_global_t *)TlsGetValue(_mxml_tls_index)) != NULL)
+          free(global);
+        break;
+
+    case DLL_PROCESS_DETACH :		/* Called when library is unloaded */
+        if ((global = (_mxml_global_t *)TlsGetValue(_mxml_tls_index)) != NULL)
+          free(global);
+
+        TlsFree(_mxml_tls_index);
+        break;
+
+    default:
+        break;
+  }
+
+  return (TRUE);
+}
+
+
+/*
+ * '_mxml_global()' - Get global data.
+ */
+
+_mxml_global_t *			/* O - Global data */
+_mxml_global(void)
+{
+  _mxml_global_t	*global;	/* Global data */
+
+
+  if ((global = (_mxml_global_t *)TlsGetValue(_mxml_tls_index)) == NULL)
+  {
+    global = (_mxml_global_t *)calloc(1, sizeof(_mxml_global_t));
+
+    global->num_entity_cbs = 1;
+    global->entity_cbs[0]  = _mxml_entity_cb;
+    global->wrap           = 72;
+
+    TlsSetValue(_mxml_tls_index, (LPVOID)global);
+  }
+
+  return (global);
+}
+
+
+#else					/**** No threading ****/
+/*
+ * '_mxml_global()' - Get global data.
+ */
+
+_mxml_global_t *			/* O - Global data */
+_mxml_global(void)
+{
+  static _mxml_global_t	global =	/* Global data */
+  {
+    NULL,				/* error_cb */
+    1,					/* num_entity_cbs */
+    { _mxml_entity_cb },		/* entity_cbs */
+    72,					/* wrap */
+    NULL,				/* custom_load_cb */
+    NULL				/* custom_save_cb */
+  };
+
+
+  return (&global);
+}
+#endif /* HAVE_PTHREAD_H */
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-private.h b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-private.h
new file mode 100644
index 0000000..a97d769
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-private.h
@@ -0,0 +1,98 @@
+/*
+ * Private definitions for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml.h"
+
+
+/*
+ * Private structures...
+ */
+
+typedef struct _mxml_attr_s		/**** An XML element attribute value. ****/
+{
+  char			*name;		/* Attribute name */
+  char			*value;		/* Attribute value */
+} _mxml_attr_t;
+
+typedef struct _mxml_element_s		/**** An XML element value. ****/
+{
+  char			*name;		/* Name of element */
+  int			num_attrs;	/* Number of attributes */
+  _mxml_attr_t		*attrs;		/* Attributes */
+} _mxml_element_t;
+
+typedef struct _mxml_text_s		/**** An XML text value. ****/
+{
+  int			whitespace;	/* Leading whitespace? */
+  char			*string;	/* Fragment string */
+} _mxml_text_t;
+
+typedef struct _mxml_custom_s		/**** An XML custom value. ****/
+{
+  void			*data;		/* Pointer to (allocated) custom data */
+  mxml_custom_destroy_cb_t destroy;	/* Pointer to destructor function */
+} _mxml_custom_t;
+
+typedef union _mxml_value_u		/**** An XML node value. ****/
+{
+  _mxml_element_t	element;	/* Element */
+  int			integer;	/* Integer number */
+  char			*opaque;	/* Opaque string */
+  double		real;		/* Real number */
+  _mxml_text_t		text;		/* Text fragment */
+  _mxml_custom_t	custom;		/* Custom data @since Mini-XML 2.1@ */
+} _mxml_value_t;
+
+struct _mxml_node_s			/**** An XML node. ****/
+{
+  mxml_type_t		type;		/* Node type */
+  struct _mxml_node_s	*next;		/* Next node under same parent */
+  struct _mxml_node_s	*prev;		/* Previous node under same parent */
+  struct _mxml_node_s	*parent;	/* Parent node */
+  struct _mxml_node_s	*child;		/* First child node */
+  struct _mxml_node_s	*last_child;	/* Last child node */
+  _mxml_value_t		value;		/* Node value */
+  int			ref_count;	/* Use count */
+  void			*user_data;	/* User data */
+};
+
+struct _mxml_index_s			 /**** An XML node index. ****/
+{
+  char			*attr;		/* Attribute used for indexing or NULL */
+  int			num_nodes;	/* Number of nodes in index */
+  int			alloc_nodes;	/* Allocated nodes in index */
+  int			cur_node;	/* Current node */
+  mxml_node_t		**nodes;	/* Node array */
+};
+
+typedef struct _mxml_global_s		/**** Global, per-thread data ****/
+
+{
+  void	(*error_cb)(const char *);
+  int	num_entity_cbs;
+  int	(*entity_cbs[100])(const char *name);
+  int	wrap;
+  mxml_custom_load_cb_t	custom_load_cb;
+  mxml_custom_save_cb_t	custom_save_cb;
+} _mxml_global_t;
+
+
+/*
+ * Functions...
+ */
+
+extern _mxml_global_t	*_mxml_global(void);
+extern int		_mxml_entity_cb(const char *name);
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-search.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-search.c
new file mode 100644
index 0000000..8e2ef0a
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-search.c
@@ -0,0 +1,269 @@
+/*
+ * Search/navigation functions for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml-private.h"
+
+
+/*
+ * 'mxmlFindElement()' - Find the named element.
+ *
+ * The search is constrained by the name, attribute name, and value; any
+ * @code NULL@ names or values are treated as wildcards, so different kinds of
+ * searches can be implemented by looking for all elements of a given name
+ * or all elements with a specific attribute. The descend argument determines
+ * whether the search descends into child nodes; normally you will use
+ * @code MXML_DESCEND_FIRST@ for the initial search and @code MXML_NO_DESCEND@
+ * to find additional direct descendents of the node. The top node argument
+ * constrains the search to a particular node's children.
+ */
+
+mxml_node_t *				/* O - Element node or @code NULL@ */
+mxmlFindElement(mxml_node_t *node,	/* I - Current node */
+                mxml_node_t *top,	/* I - Top node */
+                const char  *element,	/* I - Element name or @code NULL@ for any */
+		const char  *attr,	/* I - Attribute name, or @code NULL@ for none */
+		const char  *value,	/* I - Attribute value, or @code NULL@ for any */
+		int         descend)	/* I - Descend into tree - @code MXML_DESCEND@, @code MXML_NO_DESCEND@, or @code MXML_DESCEND_FIRST@ */
+{
+  const char	*temp;			/* Current attribute value */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!node || !top || (!attr && value))
+    return (NULL);
+
+ /*
+  * Start with the next node...
+  */
+
+  node = mxmlWalkNext(node, top, descend);
+
+ /*
+  * Loop until we find a matching element...
+  */
+
+  while (node != NULL)
+  {
+   /*
+    * See if this node matches...
+    */
+
+    if (node->type == MXML_ELEMENT &&
+        node->value.element.name &&
+	(!element || !strcmp(node->value.element.name, element)))
+    {
+     /*
+      * See if we need to check for an attribute...
+      */
+
+      if (!attr)
+        return (node);			/* No attribute search, return it... */
+
+     /*
+      * Check for the attribute...
+      */
+
+      if ((temp = mxmlElementGetAttr(node, attr)) != NULL)
+      {
+       /*
+        * OK, we have the attribute, does it match?
+	*/
+
+	if (!value || !strcmp(value, temp))
+	  return (node);		/* Yes, return it... */
+      }
+    }
+
+   /*
+    * No match, move on to the next node...
+    */
+
+    if (descend == MXML_DESCEND)
+      node = mxmlWalkNext(node, top, MXML_DESCEND);
+    else
+      node = node->next;
+  }
+
+  return (NULL);
+}
+
+
+/*
+ * 'mxmlFindPath()' - Find a node with the given path.
+ *
+ * The "path" is a slash-separated list of element names. The name "*" is
+ * considered a wildcard for one or more levels of elements.  For example,
+ * "foo/one/two", "bar/two/one", "*\/one", and so forth.
+ *
+ * The first child node of the found node is returned if the given node has
+ * children and the first child is a value node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+mxml_node_t *				/* O - Found node or @code NULL@ */
+mxmlFindPath(mxml_node_t *top,		/* I - Top node */
+	     const char  *path)		/* I - Path to element */
+{
+  mxml_node_t	*node;			/* Current node */
+  char		element[256];		/* Current element name */
+  const char	*pathsep;		/* Separator in path */
+  int		descend;		/* mxmlFindElement option */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (!top || !path || !*path)
+    return (NULL);
+
+ /*
+  * Search each element in the path...
+  */
+
+  node = top;
+  while (*path)
+  {
+   /*
+    * Handle wildcards...
+    */
+
+    if (!strncmp(path, "*/", 2))
+    {
+      path += 2;
+      descend = MXML_DESCEND;
+    }
+    else
+      descend = MXML_DESCEND_FIRST;
+
+   /*
+    * Get the next element in the path...
+    */
+
+    if ((pathsep = strchr(path, '/')) == NULL)
+      pathsep = path + strlen(path);
+
+    if (pathsep == path || (pathsep - path) >= sizeof(element))
+      return (NULL);
+
+    memcpy(element, path, pathsep - path);
+    element[pathsep - path] = '\0';
+
+    if (*pathsep)
+      path = pathsep + 1;
+    else
+      path = pathsep;
+
+   /*
+    * Search for the element...
+    */
+
+    if ((node = mxmlFindElement(node, node, element, NULL, NULL,
+                                descend)) == NULL)
+      return (NULL);
+  }
+
+ /*
+  * If we get this far, return the node or its first child...
+  */
+
+  if (node->child && node->child->type != MXML_ELEMENT)
+    return (node->child);
+  else
+    return (node);
+}
+
+
+/*
+ * 'mxmlWalkNext()' - Walk to the next logical node in the tree.
+ *
+ * The descend argument controls whether the first child is considered
+ * to be the next node.  The top node argument constrains the walk to
+ * the node's children.
+ */
+
+mxml_node_t *				/* O - Next node or @code NULL@ */
+mxmlWalkNext(mxml_node_t *node,		/* I - Current node */
+             mxml_node_t *top,		/* I - Top node */
+             int         descend)	/* I - Descend into tree - @code MXML_DESCEND@, @code MXML_NO_DESCEND@, or @code MXML_DESCEND_FIRST@ */
+{
+  if (!node)
+    return (NULL);
+  else if (node->child && descend)
+    return (node->child);
+  else if (node == top)
+    return (NULL);
+  else if (node->next)
+    return (node->next);
+  else if (node->parent && node->parent != top)
+  {
+    node = node->parent;
+
+    while (!node->next)
+      if (node->parent == top || !node->parent)
+        return (NULL);
+      else
+        node = node->parent;
+
+    return (node->next);
+  }
+  else
+    return (NULL);
+}
+
+
+/*
+ * 'mxmlWalkPrev()' - Walk to the previous logical node in the tree.
+ *
+ * The descend argument controls whether the previous node's last child
+ * is considered to be the previous node.  The top node argument constrains
+ * the walk to the node's children.
+ */
+
+mxml_node_t *				/* O - Previous node or @code NULL@ */
+mxmlWalkPrev(mxml_node_t *node,		/* I - Current node */
+             mxml_node_t *top,		/* I - Top node */
+             int         descend)	/* I - Descend into tree - @code MXML_DESCEND@, @code MXML_NO_DESCEND@, or @code MXML_DESCEND_FIRST@ */
+{
+  if (!node || node == top)
+    return (NULL);
+  else if (node->prev)
+  {
+    if (node->prev->last_child && descend)
+    {
+     /*
+      * Find the last child under the previous node...
+      */
+
+      node = node->prev->last_child;
+
+      while (node->last_child)
+        node = node->last_child;
+
+      return (node);
+    }
+    else
+      return (node->prev);
+  }
+  else if (node->parent != top)
+    return (node->parent);
+  else
+    return (NULL);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-set.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-set.c
new file mode 100644
index 0000000..b6479b6
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-set.c
@@ -0,0 +1,399 @@
+/*
+ * Node set functions for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+#include "mxml-private.h"
+
+
+/*
+ * 'mxmlSetCDATA()' - Set the element name of a CDATA node.
+ *
+ * The node is not changed if it (or its first child) is not a CDATA element node.
+ *
+ * @since Mini-XML 2.3@
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetCDATA(mxml_node_t *node,		/* I - Node to set */
+             const char  *data)		/* I - New data string */
+{
+  char	*s;				/* String pointer */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      strncmp(node->value.element.name, "![CDATA[", 8) &&
+      node->child && node->child->type == MXML_ELEMENT &&
+      !strncmp(node->child->value.element.name, "![CDATA[", 8))
+    node = node->child;
+
+  if (!node || node->type != MXML_ELEMENT || !data ||
+      strncmp(node->value.element.name, "![CDATA[", 8))
+    return (-1);
+
+  if (data == (node->value.element.name + 8))
+    return (0);
+
+ /*
+  * Allocate the new value, free any old element value, and set the new value...
+  */
+
+  s = _mxml_strdupf("![CDATA[%s", data);
+
+  if (node->value.element.name)
+    free(node->value.element.name);
+
+  node->value.element.name = s;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetCustom()' - Set the data and destructor of a custom data node.
+ *
+ * The node is not changed if it (or its first child) is not a custom node.
+ *
+ * @since Mini-XML 2.1@
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetCustom(
+    mxml_node_t              *node,	/* I - Node to set */
+    void                     *data,	/* I - New data pointer */
+    mxml_custom_destroy_cb_t destroy)	/* I - New destructor function */
+{
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_CUSTOM)
+    node = node->child;
+
+  if (!node || node->type != MXML_CUSTOM)
+    return (-1);
+
+  if (data == node->value.custom.data)
+  {
+    node->value.custom.destroy = destroy;
+    return (0);
+  }
+
+ /*
+  * Free any old element value and set the new value...
+  */
+
+  if (node->value.custom.data && node->value.custom.destroy)
+    (*(node->value.custom.destroy))(node->value.custom.data);
+
+  node->value.custom.data    = data;
+  node->value.custom.destroy = destroy;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetElement()' - Set the name of an element node.
+ *
+ * The node is not changed if it is not an element node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetElement(mxml_node_t *node,	/* I - Node to set */
+               const char  *name)	/* I - New name string */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node || node->type != MXML_ELEMENT || !name)
+    return (-1);
+
+  if (name == node->value.element.name)
+    return (0);
+
+ /*
+  * Free any old element value and set the new value...
+  */
+
+  if (node->value.element.name)
+    free(node->value.element.name);
+
+  node->value.element.name = strdup(name);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetInteger()' - Set the value of an integer node.
+ *
+ * The node is not changed if it (or its first child) is not an integer node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetInteger(mxml_node_t *node,	/* I - Node to set */
+               int         integer)	/* I - Integer value */
+{
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_INTEGER)
+    node = node->child;
+
+  if (!node || node->type != MXML_INTEGER)
+    return (-1);
+
+ /*
+  * Set the new value and return...
+  */
+
+  node->value.integer = integer;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetOpaque()' - Set the value of an opaque node.
+ *
+ * The node is not changed if it (or its first child) is not an opaque node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetOpaque(mxml_node_t *node,	/* I - Node to set */
+              const char  *opaque)	/* I - Opaque string */
+{
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_OPAQUE)
+    node = node->child;
+
+  if (!node || node->type != MXML_OPAQUE || !opaque)
+    return (-1);
+
+  if (node->value.opaque == opaque)
+    return (0);
+
+ /*
+  * Free any old opaque value and set the new value...
+  */
+
+  if (node->value.opaque)
+    free(node->value.opaque);
+
+  node->value.opaque = strdup(opaque);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetOpaquef()' - Set the value of an opaque string node to a formatted string.
+ *
+ * The node is not changed if it (or its first child) is not an opaque node.
+ *
+ * @since Mini-XML 2.11@
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetOpaquef(mxml_node_t *node,	/* I - Node to set */
+               const char  *format,	/* I - Printf-style format string */
+	       ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to arguments */
+  char		*s;			/* Temporary string */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_OPAQUE)
+    node = node->child;
+
+  if (!node || node->type != MXML_OPAQUE || !format)
+    return (-1);
+
+ /*
+  * Format the new string, free any old string value, and set the new value...
+  */
+
+  va_start(ap, format);
+  s = _mxml_vstrdupf(format, ap);
+  va_end(ap);
+
+  if (node->value.opaque)
+    free(node->value.opaque);
+
+  node->value.opaque = s;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetReal()' - Set the value of a real number node.
+ *
+ * The node is not changed if it (or its first child) is not a real number node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetReal(mxml_node_t *node,		/* I - Node to set */
+            double      real)		/* I - Real number value */
+{
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_REAL)
+    node = node->child;
+
+  if (!node || node->type != MXML_REAL)
+    return (-1);
+
+ /*
+  * Set the new value and return...
+  */
+
+  node->value.real = real;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetText()' - Set the value of a text node.
+ *
+ * The node is not changed if it (or its first child) is not a text node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetText(mxml_node_t *node,		/* I - Node to set */
+            int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+	    const char  *string)	/* I - String */
+{
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_TEXT)
+    node = node->child;
+
+  if (!node || node->type != MXML_TEXT || !string)
+    return (-1);
+
+  if (string == node->value.text.string)
+  {
+    node->value.text.whitespace = whitespace;
+    return (0);
+  }
+
+ /*
+  * Free any old string value and set the new value...
+  */
+
+  if (node->value.text.string)
+    free(node->value.text.string);
+
+  node->value.text.whitespace = whitespace;
+  node->value.text.string     = strdup(string);
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetTextf()' - Set the value of a text node to a formatted string.
+ *
+ * The node is not changed if it (or its first child) is not a text node.
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetTextf(mxml_node_t *node,		/* I - Node to set */
+             int         whitespace,	/* I - 1 = leading whitespace, 0 = no whitespace */
+             const char  *format,	/* I - Printf-style format string */
+	     ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to arguments */
+  char		*s;			/* Temporary string */
+
+
+ /*
+  * Range check input...
+  */
+
+  if (node && node->type == MXML_ELEMENT &&
+      node->child && node->child->type == MXML_TEXT)
+    node = node->child;
+
+  if (!node || node->type != MXML_TEXT || !format)
+    return (-1);
+
+ /*
+  * Free any old string value and set the new value...
+  */
+
+  va_start(ap, format);
+  s = _mxml_vstrdupf(format, ap);
+  va_end(ap);
+
+  if (node->value.text.string)
+    free(node->value.text.string);
+
+  node->value.text.whitespace = whitespace;
+  node->value.text.string     = s;
+
+  return (0);
+}
+
+
+/*
+ * 'mxmlSetUserData()' - Set the user data pointer for a node.
+ *
+ * @since Mini-XML 2.7@
+ */
+
+int					/* O - 0 on success, -1 on failure */
+mxmlSetUserData(mxml_node_t *node,	/* I - Node to set */
+                void        *data)	/* I - User data pointer */
+{
+ /*
+  * Range check input...
+  */
+
+  if (!node)
+    return (-1);
+
+ /*
+  * Set the user data pointer and return...
+  */
+
+  node->user_data = data;
+  return (0);
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml-string.c b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-string.c
new file mode 100644
index 0000000..724f510
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml-string.c
@@ -0,0 +1,559 @@
+/*
+ * String functions for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Include necessary headers...
+ */
+
+#include "config.h"
+
+
+/*
+ * The va_copy macro is part of C99, but many compilers don't implement it.
+ * Provide a "direct assignment" implmentation when va_copy isn't defined...
+ */
+
+#ifndef va_copy
+#  ifdef __va_copy
+#    define va_copy(dst,src) __va_copy(dst,src)
+#  else
+#    define va_copy(dst,src) memcpy(&dst, &src, sizeof(va_list))
+#  endif /* __va_copy */
+#endif /* va_copy */
+
+
+#ifndef HAVE_SNPRINTF
+/*
+ * '_mxml_snprintf()' - Format a string.
+ */
+
+int					/* O - Number of bytes formatted */
+_mxml_snprintf(char       *buffer,	/* I - Output buffer */
+               size_t     bufsize,	/* I - Size of output buffer */
+	       const char *format,	/* I - Printf-style format string */
+	       ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Argument list */
+  int		bytes;			/* Number of bytes formatted */
+
+
+  va_start(ap, format);
+  bytes = vsnprintf(buffer, bufsize, format, ap);
+  va_end(ap);
+
+  return (bytes);
+}
+#endif /* !HAVE_SNPRINTF */
+
+
+/*
+ * '_mxml_strdup()' - Duplicate a string.
+ */
+
+#ifndef HAVE_STRDUP
+char *					/* O - New string pointer */
+_mxml_strdup(const char *s)		/* I - String to duplicate */
+{
+  char	*t;				/* New string pointer */
+
+
+  if (s == NULL)
+    return (NULL);
+
+  if ((t = malloc(strlen(s) + 1)) == NULL)
+    return (NULL);
+
+  return (strcpy(t, s));
+}
+#endif /* !HAVE_STRDUP */
+
+
+/*
+ * '_mxml_strdupf()' - Format and duplicate a string.
+ */
+
+char *					/* O - New string pointer */
+_mxml_strdupf(const char *format,	/* I - Printf-style format string */
+              ...)			/* I - Additional arguments as needed */
+{
+  va_list	ap;			/* Pointer to additional arguments */
+  char		*s;			/* Pointer to formatted string */
+
+
+ /*
+  * Get a pointer to the additional arguments, format the string,
+  * and return it...
+  */
+
+  va_start(ap, format);
+#ifdef HAVE_VASPRINTF
+  if (vasprintf(&s, format, ap) < 0)
+    s = NULL;
+#else
+  s = _mxml_vstrdupf(format, ap);
+#endif /* HAVE_VASPRINTF */
+  va_end(ap);
+
+  return (s);
+}
+
+
+#ifndef HAVE_STRLCAT
+/*
+ * '_mxml_strlcat()' - Safely concatenate a string.
+ */
+
+size_t					/* O - Number of bytes copied */
+_mxml_strlcat(char       *dst,		/* I - Destination buffer */
+              const char *src,		/* I - Source string */
+              size_t     dstsize)	/* I - Size of destinatipon buffer */
+{
+  size_t	srclen;			/* Length of source string */
+  size_t	dstlen;			/* Length of destination string */
+
+
+ /*
+  * Figure out how much room is left...
+  */
+
+  dstlen = strlen(dst);
+
+  if (dstsize <= (dstlen + 1))
+    return (dstlen);		        /* No room, return immediately... */
+
+  dstsize -= dstlen + 1;
+
+ /*
+  * Figure out how much room is needed...
+  */
+
+  srclen = strlen(src);
+
+ /*
+  * Copy the appropriate amount...
+  */
+
+  if (srclen > dstsize)
+    srclen = dstsize;
+
+  memmove(dst + dstlen, src, srclen);
+  dst[dstlen + srclen] = '\0';
+
+  return (dstlen + srclen);
+}
+#endif /* !HAVE_STRLCAT */
+
+
+#ifndef HAVE_STRLCPY
+/*
+ * '_mxml_strlcpy()' - Safely copy a string.
+ */
+
+size_t					/* O - Number of bytes copied */
+_mxml_strlcpy(char       *dst,		/* I - Destination buffer */
+              const char *src,		/* I - Source string */
+              size_t     dstsize)	/* I - Size of destinatipon buffer */
+{
+  size_t        srclen;                 /* Length of source string */
+
+
+ /*
+  * Figure out how much room is needed...
+  */
+
+  dstsize --;
+
+  srclen = strlen(src);
+
+ /*
+  * Copy the appropriate amount...
+  */
+
+  if (srclen > dstsize)
+    srclen = dstsize;
+
+  memmove(dst, src, srclen);
+  dst[srclen] = '\0';
+
+  return (srclen);
+}
+#endif /* !HAVE_STRLCPY */
+
+
+#ifndef HAVE_VSNPRINTF
+/*
+ * '_mxml_vsnprintf()' - Format a string into a fixed size buffer.
+ */
+
+int					/* O - Number of bytes formatted */
+_mxml_vsnprintf(char       *buffer,	/* O - Output buffer */
+                size_t     bufsize,	/* O - Size of output buffer */
+		const char *format,	/* I - Printf-style format string */
+ 		va_list    ap)		/* I - Pointer to additional arguments */
+{
+  char		*bufptr,		/* Pointer to position in buffer */
+		*bufend,		/* Pointer to end of buffer */
+		sign,			/* Sign of format width */
+		size,			/* Size character (h, l, L) */
+		type;			/* Format type character */
+  int		width,			/* Width of field */
+		prec;			/* Number of characters of precision */
+  char		tformat[100],		/* Temporary format string for sprintf() */
+		*tptr,			/* Pointer into temporary format */
+		temp[1024];		/* Buffer for formatted numbers */
+  char		*s;			/* Pointer to string */
+  int		slen;			/* Length of string */
+  int		bytes;			/* Total number of bytes needed */
+
+
+ /*
+  * Loop through the format string, formatting as needed...
+  */
+
+  bufptr = buffer;
+  bufend = buffer + bufsize - 1;
+  bytes  = 0;
+
+  while (*format)
+  {
+    if (*format == '%')
+    {
+      tptr = tformat;
+      *tptr++ = *format++;
+
+      if (*format == '%')
+      {
+        if (bufptr && bufptr < bufend)
+          *bufptr++ = *format;
+        bytes ++;
+        format ++;
+	continue;
+      }
+      else if (strchr(" -+#\'", *format))
+      {
+        *tptr++ = *format;
+        sign = *format++;
+      }
+      else
+        sign = 0;
+
+      if (*format == '*')
+      {
+       /*
+        * Get width from argument...
+	*/
+
+	format ++;
+	width = va_arg(ap, int);
+
+	snprintf(tptr, sizeof(tformat) - (tptr - tformat), "%d", width);
+	tptr += strlen(tptr);
+      }
+      else
+      {
+	width = 0;
+
+	while (isdigit(*format & 255))
+	{
+	  if (tptr < (tformat + sizeof(tformat) - 1))
+	    *tptr++ = *format;
+
+	  width = width * 10 + *format++ - '0';
+	}
+      }
+
+      if (*format == '.')
+      {
+	if (tptr < (tformat + sizeof(tformat) - 1))
+	  *tptr++ = *format;
+
+        format ++;
+
+        if (*format == '*')
+	{
+         /*
+	  * Get precision from argument...
+	  */
+
+	  format ++;
+	  prec = va_arg(ap, int);
+
+	  snprintf(tptr, sizeof(tformat) - (tptr - tformat), "%d", prec);
+	  tptr += strlen(tptr);
+	}
+	else
+	{
+	  prec = 0;
+
+	  while (isdigit(*format & 255))
+	  {
+	    if (tptr < (tformat + sizeof(tformat) - 1))
+	      *tptr++ = *format;
+
+	    prec = prec * 10 + *format++ - '0';
+	  }
+	}
+      }
+      else
+        prec = -1;
+
+      if (*format == 'l' && format[1] == 'l')
+      {
+        size = 'L';
+
+	if (tptr < (tformat + sizeof(tformat) - 2))
+	{
+	  *tptr++ = 'l';
+	  *tptr++ = 'l';
+	}
+
+	format += 2;
+      }
+      else if (*format == 'h' || *format == 'l' || *format == 'L')
+      {
+	if (tptr < (tformat + sizeof(tformat) - 1))
+	  *tptr++ = *format;
+
+        size = *format++;
+      }
+
+      if (!*format)
+        break;
+
+      if (tptr < (tformat + sizeof(tformat) - 1))
+        *tptr++ = *format;
+
+      type  = *format++;
+      *tptr = '\0';
+
+      switch (type)
+      {
+	case 'E' : /* Floating point formats */
+	case 'G' :
+	case 'e' :
+	case 'f' :
+	case 'g' :
+	    if ((width + 2) > sizeof(temp))
+	      break;
+
+	    sprintf(temp, tformat, va_arg(ap, double));
+
+            bytes += strlen(temp);
+
+            if (bufptr)
+	    {
+	      if ((bufptr + strlen(temp)) > bufend)
+	      {
+		strncpy(bufptr, temp, (size_t)(bufend - bufptr));
+		bufptr = bufend;
+	      }
+	      else
+	      {
+		strcpy(bufptr, temp);
+		bufptr += strlen(temp);
+	      }
+	    }
+	    break;
+
+        case 'B' : /* Integer formats */
+	case 'X' :
+	case 'b' :
+        case 'd' :
+	case 'i' :
+	case 'o' :
+	case 'u' :
+	case 'x' :
+	    if ((width + 2) > sizeof(temp))
+	      break;
+
+#ifdef HAVE_LONG_LONG
+	    if (size == 'L')
+	      sprintf(temp, tformat, va_arg(ap, long long));
+	    else
+#endif /* HAVE_LONG_LONG */
+	    sprintf(temp, tformat, va_arg(ap, int));
+
+            bytes += strlen(temp);
+
+	    if (bufptr)
+	    {
+	      if ((bufptr + strlen(temp)) > bufend)
+	      {
+		strncpy(bufptr, temp, (size_t)(bufend - bufptr));
+		bufptr = bufend;
+	      }
+	      else
+	      {
+		strcpy(bufptr, temp);
+		bufptr += strlen(temp);
+	      }
+	    }
+	    break;
+
+	case 'p' : /* Pointer value */
+	    if ((width + 2) > sizeof(temp))
+	      break;
+
+	    sprintf(temp, tformat, va_arg(ap, void *));
+
+            bytes += strlen(temp);
+
+	    if (bufptr)
+	    {
+	      if ((bufptr + strlen(temp)) > bufend)
+	      {
+		strncpy(bufptr, temp, (size_t)(bufend - bufptr));
+		bufptr = bufend;
+	      }
+	      else
+	      {
+		strcpy(bufptr, temp);
+		bufptr += strlen(temp);
+	      }
+	    }
+	    break;
+
+        case 'c' : /* Character or character array */
+	    bytes += width;
+
+	    if (bufptr)
+	    {
+	      if (width <= 1)
+	        *bufptr++ = va_arg(ap, int);
+	      else
+	      {
+		if ((bufptr + width) > bufend)
+		  width = bufend - bufptr;
+
+		memcpy(bufptr, va_arg(ap, char *), (size_t)width);
+		bufptr += width;
+	      }
+	    }
+	    break;
+
+	case 's' : /* String */
+	    if ((s = va_arg(ap, char *)) == NULL)
+	      s = "(null)";
+
+	    slen = strlen(s);
+	    if (slen > width && prec != width)
+	      width = slen;
+
+            bytes += width;
+
+	    if (bufptr)
+	    {
+	      if ((bufptr + width) > bufend)
+	        width = bufend - bufptr;
+
+              if (slen > width)
+	        slen = width;
+
+	      if (sign == '-')
+	      {
+		strncpy(bufptr, s, (size_t)slen);
+		memset(bufptr + slen, ' ', (size_t)(width - slen));
+	      }
+	      else
+	      {
+		memset(bufptr, ' ', (size_t)(width - slen));
+		strncpy(bufptr + width - slen, s, (size_t)slen);
+	      }
+
+	      bufptr += width;
+	    }
+	    break;
+
+	case 'n' : /* Output number of chars so far */
+	    *(va_arg(ap, int *)) = bytes;
+	    break;
+      }
+    }
+    else
+    {
+      bytes ++;
+
+      if (bufptr && bufptr < bufend)
+        *bufptr++ = *format;
+
+      format ++;
+    }
+  }
+
+ /*
+  * Nul-terminate the string and return the number of characters needed.
+  */
+
+  *bufptr = '\0';
+
+  return (bytes);
+}
+#endif /* !HAVE_VSNPRINTF */
+
+
+/*
+ * '_mxml_vstrdupf()' - Format and duplicate a string.
+ */
+
+char *					/* O - New string pointer */
+_mxml_vstrdupf(const char *format,	/* I - Printf-style format string */
+               va_list    ap)		/* I - Pointer to additional arguments */
+{
+#ifdef HAVE_VASPRINTF
+  char		*s;			/* String */
+
+  if (vasprintf(&s, format, ap) < 0)
+    s = NULL;
+
+  return (s);
+
+#else
+  int		bytes;			/* Number of bytes required */
+  char		*buffer,		/* String buffer */
+		temp[256];		/* Small buffer for first vsnprintf */
+
+
+ /*
+  * First format with a tiny buffer; this will tell us how many bytes are
+  * needed...
+  */
+
+#  ifdef _WIN32
+  bytes = _vscprintf(format, ap);
+
+#  else
+  va_list	apcopy;			/* Copy of argument list */
+
+  va_copy(apcopy, ap);
+  if ((bytes = vsnprintf(temp, sizeof(temp), format, apcopy)) < sizeof(temp))
+  {
+   /*
+    * Hey, the formatted string fits in the tiny buffer, so just dup that...
+    */
+
+    return (strdup(temp));
+  }
+#  endif /* _WIN32 */
+
+ /*
+  * Allocate memory for the whole thing and reformat to the new buffer...
+  */
+
+  if ((buffer = calloc(1, bytes + 1)) != NULL)
+    vsnprintf(buffer, bytes + 1, format, ap);
+
+ /*
+  * Return the new string...
+  */
+
+  return (buffer);
+#endif /* HAVE_VASPRINTF */
+}
diff --git a/device/generic/goldfish/hx-touch/mxml-3.1/mxml.h b/device/generic/goldfish/hx-touch/mxml-3.1/mxml.h
new file mode 100644
index 0000000..f346385
--- /dev/null
+++ b/device/generic/goldfish/hx-touch/mxml-3.1/mxml.h
@@ -0,0 +1,275 @@
+/*
+ * Header file for Mini-XML, a small XML file parsing library.
+ *
+ * https://www.msweet.org/mxml
+ *
+ * Copyright © 2003-2019 by Michael R Sweet.
+ *
+ * Licensed under Apache License v2.0.  See the file "LICENSE" for more
+ * information.
+ */
+
+/*
+ * Prevent multiple inclusion...
+ */
+
+#ifndef _mxml_h_
+#  define _mxml_h_
+
+/*
+ * Include necessary headers...
+ */
+
+#  include <stdio.h>
+#  include <stdlib.h>
+#  include <string.h>
+#  include <ctype.h>
+#  include <errno.h>
+
+
+/*
+ * Constants...
+ */
+
+#  define MXML_MAJOR_VERSION	3	/* Major version number */
+#  define MXML_MINOR_VERSION	1	/* Minor version number */
+
+#  define MXML_TAB		8	/* Tabs every N columns */
+
+#  define MXML_NO_CALLBACK	0	/* Don't use a type callback */
+#  define MXML_INTEGER_CALLBACK	mxml_integer_cb
+					/* Treat all data as integers */
+#  define MXML_OPAQUE_CALLBACK	mxml_opaque_cb
+					/* Treat all data as opaque */
+#  define MXML_REAL_CALLBACK	mxml_real_cb
+					/* Treat all data as real numbers */
+#  define MXML_TEXT_CALLBACK	0	/* Treat all data as text */
+#  define MXML_IGNORE_CALLBACK	mxml_ignore_cb
+					/* Ignore all non-element content */
+
+#  define MXML_NO_PARENT	0	/* No parent for the node */
+
+#  define MXML_DESCEND		1	/* Descend when finding/walking */
+#  define MXML_NO_DESCEND	0	/* Don't descend when finding/walking */
+#  define MXML_DESCEND_FIRST	-1	/* Descend for first find */
+
+#  define MXML_WS_BEFORE_OPEN	0	/* Callback for before open tag */
+#  define MXML_WS_AFTER_OPEN	1	/* Callback for after open tag */
+#  define MXML_WS_BEFORE_CLOSE	2	/* Callback for before close tag */
+#  define MXML_WS_AFTER_CLOSE	3	/* Callback for after close tag */
+
+#  define MXML_ADD_BEFORE	0	/* Add node before specified node */
+#  define MXML_ADD_AFTER	1	/* Add node after specified node */
+#  define MXML_ADD_TO_PARENT	NULL	/* Add node relative to parent */
+
+
+/*
+ * Data types...
+ */
+
+typedef enum mxml_sax_event_e		/**** SAX event type. ****/
+{
+  MXML_SAX_CDATA,			/* CDATA node */
+  MXML_SAX_COMMENT,			/* Comment node */
+  MXML_SAX_DATA,			/* Data node */
+  MXML_SAX_DIRECTIVE,			/* Processing directive node */
+  MXML_SAX_ELEMENT_CLOSE,		/* Element closed */
+  MXML_SAX_ELEMENT_OPEN			/* Element opened */
+} mxml_sax_event_t;
+
+typedef enum mxml_type_e		/**** The XML node type. ****/
+{
+  MXML_IGNORE = -1,			/* Ignore/throw away node @since Mini-XML 2.3@ */
+  MXML_ELEMENT,				/* XML element with attributes */
+  MXML_INTEGER,				/* Integer value */
+  MXML_OPAQUE,				/* Opaque string */
+  MXML_REAL,				/* Real value */
+  MXML_TEXT,				/* Text fragment */
+  MXML_CUSTOM				/* Custom data @since Mini-XML 2.1@ */
+} mxml_type_t;
+
+typedef void (*mxml_custom_destroy_cb_t)(void *);
+					/**** Custom data destructor ****/
+
+typedef void (*mxml_error_cb_t)(const char *);
+					/**** Error callback function ****/
+
+typedef struct _mxml_node_s mxml_node_t;	/**** An XML node. ****/
+
+typedef struct _mxml_index_s mxml_index_t;
+					/**** An XML node index. ****/
+
+typedef int (*mxml_custom_load_cb_t)(mxml_node_t *, const char *);
+					/**** Custom data load callback function ****/
+
+typedef char *(*mxml_custom_save_cb_t)(mxml_node_t *);
+					/**** Custom data save callback function ****/
+
+typedef int (*mxml_entity_cb_t)(const char *);
+					/**** Entity callback function */
+
+typedef mxml_type_t (*mxml_load_cb_t)(mxml_node_t *);
+					/**** Load callback function ****/
+
+typedef const char *(*mxml_save_cb_t)(mxml_node_t *, int);
+					/**** Save callback function ****/
+
+typedef void (*mxml_sax_cb_t)(mxml_node_t *, mxml_sax_event_t, void *);
+					/**** SAX callback function ****/
+
+
+/*
+ * C++ support...
+ */
+
+#  ifdef __cplusplus
+extern "C" {
+#  endif /* __cplusplus */
+
+/*
+ * Prototypes...
+ */
+
+extern void		mxmlAdd(mxml_node_t *parent, int where,
+			        mxml_node_t *child, mxml_node_t *node);
+extern void		mxmlDelete(mxml_node_t *node);
+extern void		mxmlElementDeleteAttr(mxml_node_t *node,
+			                      const char *name);
+extern const char	*mxmlElementGetAttr(mxml_node_t *node, const char *name);
+extern const char       *mxmlElementGetAttrByIndex(mxml_node_t *node, int idx, const char **name);
+extern int              mxmlElementGetAttrCount(mxml_node_t *node);
+extern void		mxmlElementSetAttr(mxml_node_t *node, const char *name,
+			                   const char *value);
+extern void		mxmlElementSetAttrf(mxml_node_t *node, const char *name,
+			                    const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 3, 4)))
+#    endif /* __GNUC__ */
+;
+extern int		mxmlEntityAddCallback(mxml_entity_cb_t cb);
+extern const char	*mxmlEntityGetName(int val);
+extern int		mxmlEntityGetValue(const char *name);
+extern void		mxmlEntityRemoveCallback(mxml_entity_cb_t cb);
+extern mxml_node_t	*mxmlFindElement(mxml_node_t *node, mxml_node_t *top,
+			                 const char *element, const char *attr,
+					 const char *value, int descend);
+extern mxml_node_t	*mxmlFindPath(mxml_node_t *node, const char *path);
+extern const char	*mxmlGetCDATA(mxml_node_t *node);
+extern const void	*mxmlGetCustom(mxml_node_t *node);
+extern const char	*mxmlGetElement(mxml_node_t *node);
+extern mxml_node_t	*mxmlGetFirstChild(mxml_node_t *node);
+extern int		mxmlGetInteger(mxml_node_t *node);
+extern mxml_node_t	*mxmlGetLastChild(mxml_node_t *node);
+extern mxml_node_t	*mxmlGetNextSibling(mxml_node_t *node);
+extern const char	*mxmlGetOpaque(mxml_node_t *node);
+extern mxml_node_t	*mxmlGetParent(mxml_node_t *node);
+extern mxml_node_t	*mxmlGetPrevSibling(mxml_node_t *node);
+extern double		mxmlGetReal(mxml_node_t *node);
+extern int		mxmlGetRefCount(mxml_node_t *node);
+extern const char	*mxmlGetText(mxml_node_t *node, int *whitespace);
+extern mxml_type_t	mxmlGetType(mxml_node_t *node);
+extern void		*mxmlGetUserData(mxml_node_t *node);
+extern void		mxmlIndexDelete(mxml_index_t *ind);
+extern mxml_node_t	*mxmlIndexEnum(mxml_index_t *ind);
+extern mxml_node_t	*mxmlIndexFind(mxml_index_t *ind,
+			               const char *element,
+			               const char *value);
+extern int		mxmlIndexGetCount(mxml_index_t *ind);
+extern mxml_index_t	*mxmlIndexNew(mxml_node_t *node, const char *element,
+			              const char *attr);
+extern mxml_node_t	*mxmlIndexReset(mxml_index_t *ind);
+extern mxml_node_t	*mxmlLoadFd(mxml_node_t *top, int fd,
+			            mxml_type_t (*cb)(mxml_node_t *));
+extern mxml_node_t	*mxmlLoadFile(mxml_node_t *top, FILE *fp,
+			              mxml_type_t (*cb)(mxml_node_t *));
+extern mxml_node_t	*mxmlLoadString(mxml_node_t *top, const char *s,
+			                mxml_type_t (*cb)(mxml_node_t *));
+extern mxml_node_t	*mxmlNewCDATA(mxml_node_t *parent, const char *string);
+extern mxml_node_t	*mxmlNewCustom(mxml_node_t *parent, void *data,
+			               mxml_custom_destroy_cb_t destroy);
+extern mxml_node_t	*mxmlNewElement(mxml_node_t *parent, const char *name);
+extern mxml_node_t	*mxmlNewInteger(mxml_node_t *parent, int integer);
+extern mxml_node_t	*mxmlNewOpaque(mxml_node_t *parent, const char *opaque);
+extern mxml_node_t	*mxmlNewOpaquef(mxml_node_t *parent, const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 2, 3)))
+#    endif /* __GNUC__ */
+;
+extern mxml_node_t	*mxmlNewReal(mxml_node_t *parent, double real);
+extern mxml_node_t	*mxmlNewText(mxml_node_t *parent, int whitespace, const char *string);
+extern mxml_node_t	*mxmlNewTextf(mxml_node_t *parent, int whitespace, const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 3, 4)))
+#    endif /* __GNUC__ */
+;
+extern mxml_node_t	*mxmlNewXML(const char *version);
+extern int		mxmlRelease(mxml_node_t *node);
+extern void		mxmlRemove(mxml_node_t *node);
+extern int		mxmlRetain(mxml_node_t *node);
+extern char		*mxmlSaveAllocString(mxml_node_t *node,
+			        	     mxml_save_cb_t cb);
+extern int		mxmlSaveFd(mxml_node_t *node, int fd,
+			           mxml_save_cb_t cb);
+extern int		mxmlSaveFile(mxml_node_t *node, FILE *fp,
+			             mxml_save_cb_t cb);
+extern int		mxmlSaveString(mxml_node_t *node, char *buffer,
+			               int bufsize, mxml_save_cb_t cb);
+extern mxml_node_t	*mxmlSAXLoadFd(mxml_node_t *top, int fd,
+			               mxml_type_t (*cb)(mxml_node_t *),
+			               mxml_sax_cb_t sax, void *sax_data);
+extern mxml_node_t	*mxmlSAXLoadFile(mxml_node_t *top, FILE *fp,
+			                 mxml_type_t (*cb)(mxml_node_t *),
+			                 mxml_sax_cb_t sax, void *sax_data);
+extern mxml_node_t	*mxmlSAXLoadString(mxml_node_t *top, const char *s,
+			                   mxml_type_t (*cb)(mxml_node_t *),
+			                   mxml_sax_cb_t sax, void *sax_data);
+extern int		mxmlSetCDATA(mxml_node_t *node, const char *data);
+extern int		mxmlSetCustom(mxml_node_t *node, void *data,
+			              mxml_custom_destroy_cb_t destroy);
+extern void		mxmlSetCustomHandlers(mxml_custom_load_cb_t load,
+			                      mxml_custom_save_cb_t save);
+extern int		mxmlSetElement(mxml_node_t *node, const char *name);
+extern void		mxmlSetErrorCallback(mxml_error_cb_t cb);
+extern int		mxmlSetInteger(mxml_node_t *node, int integer);
+extern int		mxmlSetOpaque(mxml_node_t *node, const char *opaque);
+extern int		mxmlSetOpaquef(mxml_node_t *node, const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 2, 3)))
+#    endif /* __GNUC__ */
+;
+extern int		mxmlSetReal(mxml_node_t *node, double real);
+extern int		mxmlSetText(mxml_node_t *node, int whitespace,
+			            const char *string);
+extern int		mxmlSetTextf(mxml_node_t *node, int whitespace,
+			             const char *format, ...)
+#    ifdef __GNUC__
+__attribute__ ((__format__ (__printf__, 3, 4)))
+#    endif /* __GNUC__ */
+;
+extern int		mxmlSetUserData(mxml_node_t *node, void *data);
+extern void		mxmlSetWrapMargin(int column);
+extern mxml_node_t	*mxmlWalkNext(mxml_node_t *node, mxml_node_t *top,
+			              int descend);
+extern mxml_node_t	*mxmlWalkPrev(mxml_node_t *node, mxml_node_t *top,
+			              int descend);
+
+
+/*
+ * Semi-private functions...
+ */
+
+extern void		mxml_error(const char *format, ...);
+extern mxml_type_t	mxml_ignore_cb(mxml_node_t *node);
+extern mxml_type_t	mxml_integer_cb(mxml_node_t *node);
+extern mxml_type_t	mxml_opaque_cb(mxml_node_t *node);
+extern mxml_type_t	mxml_real_cb(mxml_node_t *node);
+
+
+/*
+ * C++ support...
+ */
+
+#  ifdef __cplusplus
+}
+#  endif /* __cplusplus */
+#endif /* !_mxml_h_ */
diff --git a/device/generic/goldfish/init.goldfish.sh b/device/generic/goldfish/init.goldfish.sh
index 025a9c4..4b11ffe 100755
--- a/device/generic/goldfish/init.goldfish.sh
+++ b/device/generic/goldfish/init.goldfish.sh
@@ -1,15 +1,5 @@
 #!/system/bin/sh
 
-# Setup networking when boot starts
-ifconfig eth0 10.0.2.15 netmask 255.255.255.0 up
-route add default gw 10.0.2.2 dev eth0
-
-wifi=`getprop ro.kernel.qemu.wifi`
-case "$wifi" in
-    1) /system/bin/init.wifi.sh
-       ;;
-esac
-
 # ro.kernel.android.qemud is normally set when we
 # want the RIL (radio interface layer) to talk to
 # the emulated modem through qemud.
diff --git a/device/generic/goldfish/init.hardware.usb.rc b/device/generic/goldfish/init.hardware.usb.rc
new file mode 100644
index 0000000..25d69d1
--- /dev/null
+++ b/device/generic/goldfish/init.hardware.usb.rc
@@ -0,0 +1,43 @@
+#
+# Copyright (C) 2017 The Android Open-Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+
+on boot
+    mkdir /dev/usb-ffs 0770 shell shell
+    mkdir /dev/usb-ffs/adb 0770 shell shell
+    mount configfs none /config
+    mkdir /config/usb_gadget/g1 0770 shell shell
+    write /config/usb_gadget/g1/idVendor 0x18d1
+    write /config/usb_gadget/g1/bcdDevice 0x0223
+    write /config/usb_gadget/g1/bcdUSB 0x0200
+    mkdir /config/usb_gadget/g1/strings/0x409 0770
+    write /config/usb_gadget/g1/strings/0x409/serialnumber CORELLIUM-I7
+    write /config/usb_gadget/g1/strings/0x409/manufacturer Foxconn-China
+    write /config/usb_gadget/g1/strings/0x409/product Phone
+    mkdir /config/usb_gadget/g1/functions/accessory.gs2
+    mkdir /config/usb_gadget/g1/functions/audio_source.gs3
+    mkdir /config/usb_gadget/g1/functions/ffs.adb
+    mkdir /config/usb_gadget/g1/functions/mtp.gs0
+    mkdir /config/usb_gadget/g1/functions/ptp.gs1
+    mkdir /config/usb_gadget/g1/functions/midi.gs5
+    mkdir /config/usb_gadget/g1/configs/b.1 0770 shell shell
+    mkdir /config/usb_gadget/g1/configs/b.1/strings/0x409 0770 shell shell
+    write /config/usb_gadget/g1/os_desc/b_vendor_code 0x1
+    write /config/usb_gadget/g1/os_desc/qw_sign "MSFT100"
+    write /config/usb_gadget/g1/configs/b.1/MaxPower 500
+    symlink /config/usb_gadget/g1/configs/b.1 /config/usb_gadget/g1/os_desc/b.1
+    mount functionfs adb /dev/usb-ffs/adb uid=2000,gid=2000
+    setprop sys.usb.configfs 1
+    setprop sys.usb.controller "20c100000.usbdev"
diff --git a/device/generic/goldfish/init.ranchu-core.sh b/device/generic/goldfish/init.ranchu-core.sh
index e6c9de4..51b6600 100755
--- a/device/generic/goldfish/init.ranchu-core.sh
+++ b/device/generic/goldfish/init.ranchu-core.sh
@@ -1,5 +1,8 @@
 #!/vendor/bin/sh
 
+# Unbind fbcon
+echo 0 > /sys/devices/virtual/vtconsole/vtcon1/bind
+
 #init cannot access ro.kernel.android.bootanim,
 #so do a translation into vendor.qemu space
 bootanim=`getprop ro.kernel.android.bootanim`
@@ -20,3 +23,6 @@ case "$allowsuspend" in
     *) echo "emulator_wake_lock" > /sys/power/wake_lock
     ;;
 esac
+
+setprop ro.serialno `/vendor/bin/syscfg /dev/block/nvme0n3 SrNm z`
+setprop ro.boot.hardware.revision `syscfg /dev/block/nvme0n3 'Mod#' z`
diff --git a/device/generic/goldfish/init.ranchu-net.sh b/device/generic/goldfish/init.ranchu-net.sh
index a47ac15..fe86e30 100755
--- a/device/generic/goldfish/init.ranchu-net.sh
+++ b/device/generic/goldfish/init.ranchu-net.sh
@@ -1,23 +1,80 @@
 #!/vendor/bin/sh
 
-# Check if WiFi is enabled. If it is run the WiFi init script. If not we just
-# have to run the DHCP client in the default namespace and that will set up
-# all the networking.
-wifi=`getprop ro.kernel.qemu.wifi`
-case "$wifi" in
-    1) /vendor/bin/init.wifi.sh
-       ;;
-    *) setprop ctl.start dhcpclient_def
-       ;;
-esac
-
-# set up the second interface (for inter-emulator connections)
-# if required
-my_ip=`getprop net.shared_net_ip`
-case "$my_ip" in
-    "")
-    ;;
-    *) ifconfig eth1 "$my_ip" netmask 255.255.255.0 up
-    ;;
-esac
+OTP_CHIP=`cat /sys/module/brcmfmac/parameters/otp_chip_id`
+OTP_NVRAM=`cat /sys/module/brcmfmac/parameters/otp_nvram_id`
+CHIP=`cat /sys/module/brcmfmac/parameters/otp_chip_id | tr '_' '\n' | grep '^C-' | cut -c3-`
 
+MODULE='unknown'
+BTMODULE=''
+if [ -d /sys/bus/pci/devices/0000:00:02.0 ]; then
+	if [ -d /sys/bus/pci/devices/0000:00:02.0/0000:* ]; then
+		if [ `cat /sys/bus/pci/devices/0000:00:02.0/0000:*/vendor` == '0x14e4' ]; then
+			if [ -f /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/elsa.trx ]; then
+				MODULE='elsa'
+			fi
+			if [ -f /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/olaf.trx ]; then
+				MODULE='olaf'
+			fi
+		fi
+	fi
+fi
+if [ -d /sys/bus/pci/devices/0000:00:03.0 ]; then
+	if [ -d /sys/bus/pci/devices/0000:00:03.0/0000:* ]; then
+		if [ `cat /sys/bus/pci/devices/0000:00:03.0/0000:*/vendor` == '0x14e4' ]; then
+			if [ -f /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/kristoff.trx ]; then
+				MODULE='kristoff'
+			fi
+			if [ -f /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/sven.trx ]; then
+				MODULE='sven'
+			fi
+			if [ -f /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/baccus-2.trx ]; then
+				MODULE='baccus-2'
+				BTMODULE='baccus2'
+			fi
+		fi
+	fi
+fi
+
+if [ $MODULE == 'unknown' ]; then
+	echo WLAN PCI device not found.
+	exit 1
+fi
+if [ x$BTMODULE == x ]; then
+	BTMODULE=$MODULE
+fi
+
+mkdir -p /data/vendor/firmware/brcm
+ln -sf /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/${MODULE}.trx /data/vendor/firmware/brcm/brcmfmac${CHIP}-pcie.bin
+ln -sf /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/${MODULE}.clmb /data/vendor/firmware/brcm/brcmfmac${CHIP}-pcie.clm_blob
+ln -sf /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/${MODULE}.txcb /data/vendor/firmware/brcm/brcmfmac${CHIP}-pcie.txcb
+ln -sf /hostfs/usr/share/firmware/wifi/${OTP_CHIP}/P-${MODULE}_${OTP_NVRAM}.txt /data/vendor/firmware/brcm/brcmfmac${CHIP}-pcie.hx,h9p.txt
+
+BTFW_NAME=`/vendor/bin/hcdpack /hostfs/usr/sbin/BlueTool ${OTP_CHIP} ${BTMODULE} ${OTP_NVRAM} /data/vendor/firmware/brcm/BCM.hcd`
+echo serial0-0 > /sys/bus/serial/drivers/hci_uart_bcm/unbind
+if [ -f /data/vendor/firmware/brcm/BCM.hcd ]; then
+    mv /data/vendor/firmware/brcm/BCM.hcd /data/vendor/firmware/brcm/${BTFW_NAME}
+    /vendor/bin/syscfg /dev/block/nvme0n3 BMac x:6 > /sys/module/btbcm/parameters/mac_addr
+    echo -n /data/vendor/firmware/ > /sys/module/btbcm/parameters/alternative_fw_path
+fi
+
+/vendor/bin/syscfg /dev/block/nvme0n3 WMac x:6 > /sys/module/brcmfmac/parameters/nvram_mac_addr
+echo -n /data/vendor/firmware > /sys/module/brcmfmac/parameters/alternative_fw_path
+
+for RETRY in `seq 1 3`; do
+    echo 1 > /sys/bus/pci/devices/0000:02:00.0/remove
+    sleep 1
+    echo 1 > /sys/bus/pci/devices/0000:00:02.0/dev_rescan
+    echo 1 > /sys/bus/pci/devices/0000:00:03.0/dev_rescan
+    for DELAY in `seq 1 6`; do
+        if [ -e /sys/class/net/wlan0 ]; then
+            ifconfig wlan0 up
+            if [ -f /data/vendor/firmware/brcm/${BTFW_NAME} ]; then
+                echo serial0-0 > /sys/bus/serial/drivers/hci_uart_bcm/bind
+            fi
+            exit 0
+        fi
+        sleep 1
+    done
+done
+
+echo WLAN start up failed.
diff --git a/device/generic/goldfish/init.ranchu.rc b/device/generic/goldfish/init.ranchu.rc
index 81bcc22..e35cef9 100644
--- a/device/generic/goldfish/init.ranchu.rc
+++ b/device/generic/goldfish/init.ranchu.rc
@@ -15,6 +15,8 @@ on init
     write /sys/block/zram0/comp_algorithm lz4
     write /proc/sys/vm/page-cluster 0
 
+    mount apfs /dev/block/nvme0n1p1+0 /hostfs ro
+
 on post-fs-data
     setprop vold.post_fs_data_done 1
     mkdir /data/vendor/var 0755 root root
@@ -28,7 +30,7 @@ on zygote-start
     mkdir /data/vendor/wifi/wpa/sockets 0770 wifi wifi
 
 on boot
-    setprop ro.hardware.egl emulation
+    setprop ro.hardware.egl swiftshader
     setprop debug.hwui.renderer opengl
     setprop debug.hwui.renderer ${ro.kernel.qemu.uirenderer}
     setprop ro.opengles.version ${ro.kernel.qemu.opengles.version}
@@ -37,7 +39,7 @@ on boot
     setprop dalvik.vm.heapsize ${ro.kernel.qemu.dalvik.vm.heapsize}
     chown root system /sys/power/wake_lock
     chown root system /sys/power/wake_unlock
-    setprop ro.hardware.audio.primary goldfish
+    setprop ro.hardware.audio.primary default
 
     setprop wifi.interface wlan0
     setprop wifi.direct.interface p2p-dev-wlan0
@@ -147,3 +149,10 @@ on property:sys.boot_completed=1
 
 on sys-boot-completed-set && property:persist.sys.zram_enabled=1
     swapon_all /vendor/etc/fstab.${ro.hardware}
+
+on early-boot
+    # Permission for LED driver
+    chown system system /sys/class/backlight/0-0062/brightness
+    chown system system /sys/class/backlight/0-0063/brightness
+
+import /vendor/etc/init/hw/init.ranchu.usb.rc
diff --git a/device/generic/goldfish/wifi/createns/Android.mk b/device/generic/goldfish/libmemtrack/Android.mk
similarity index 57%
rename from wifi/createns/Android.mk
rename to libmemtrack/Android.mk
index 0486e45..7b92d09 100644
--- a/device/generic/goldfish/wifi/createns/Android.mk
+++ b/device/generic/goldfish/libmemtrack/Android.mk
@@ -14,19 +14,17 @@
 
 LOCAL_PATH := $(call my-dir)
 
+# HAL module implemenation stored in
+# hw/<POWERS_HARDWARE_MODULE_ID>.<ro.hardware>.so
 include $(CLEAR_VARS)
 
-LOCAL_SRC_FILES := \
-	createns.cpp
-
-LOCAL_CFLAGS := -Wall -Wextra -Werror
-LOCAL_LDFLAGS := 
-LOCAL_SHARED_LIBRARIES := libcutils liblog
-LOCAL_PROPRIETARY_MODULE := true
-LOCAL_MODULE := createns
-
-LOCAL_MODULE_CLASS := EXECUTABLES
-
-include $(BUILD_EXECUTABLE)
-
-
+LOCAL_VENDOR_MODULE := true
+LOCAL_MODULE_RELATIVE_PATH := hw
+LOCAL_C_INCLUDES += hardware/libhardware/include
+LOCAL_CFLAGS := -Wconversion -Wall -Werror -Wno-sign-conversion
+LOCAL_CLANG  := true
+LOCAL_SHARED_LIBRARIES := liblog libhardware
+LOCAL_SRC_FILES := memtrack_dummy.c
+LOCAL_MODULE := memtrack.ranchu
+#LOCAL_MODULE := memtrack.$(TARGET_BOARD_PLATFORM)
+include $(BUILD_SHARED_LIBRARY)
diff --git a/device/generic/goldfish/libmemtrack/memtrack_dummy.c b/device/generic/goldfish/libmemtrack/memtrack_dummy.c
new file mode 100644
index 0000000..98beefd
--- /dev/null
+++ b/device/generic/goldfish/libmemtrack/memtrack_dummy.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <errno.h>
+
+#include <hardware/memtrack.h>
+
+int dummy_memtrack_init(const struct memtrack_module *module)
+{
+    if (!module)
+        return -1;
+
+    return 0;
+}
+
+static struct hw_module_methods_t memtrack_module_methods = {
+    .open = NULL,
+};
+
+struct memtrack_module HAL_MODULE_INFO_SYM = {
+    .common = {
+        .tag = HARDWARE_MODULE_TAG,
+        .module_api_version = MEMTRACK_MODULE_API_VERSION_0_1,
+        .hal_api_version = HARDWARE_HAL_API_VERSION,
+        .id = MEMTRACK_HARDWARE_MODULE_ID,
+        .name = "Dummy Memory Tracker HAL",
+        .author = "The Android Open Source Project",
+        .methods = &memtrack_module_methods,
+    },
+
+    .init = dummy_memtrack_init,
+};
diff --git a/device/generic/goldfish/lights/Android.mk b/device/generic/goldfish/lights/Android.mk
index 41ab150..1f5c42d 100644
--- a/device/generic/goldfish/lights/Android.mk
+++ b/device/generic/goldfish/lights/Android.mk
@@ -17,12 +17,13 @@ LOCAL_PATH := $(call my-dir)
 # HAL module implemenation, not prelinked and stored in
 # hw/<LIGHTS_HARDWARE_MODULE_ID>.<ro.hardware>.so
 include $(CLEAR_VARS)
-LOCAL_RENDOR_MODULE := true
+LOCAL_VENDOR_MODULE := true
 LOCAL_MODULE_RELATIVE_PATH := hw
 LOCAL_SHARED_LIBRARIES := liblog libcutils
-LOCAL_C_INC := lights_qemu.c
+LOCAL_C_INC := lights_hw.c
+LOCAL_HEADER_LIBRARIES := libhardware_headers
 LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
-LOCAL_SRC_FILES := lights_qemu.c
+LOCAL_SRC_FILES := lights_hw.c
 LOCAL_MODULE := lights.ranchu
 LOCAL_CFLAGS += -DLIGHT_BACKLIGHT
 include $(BUILD_SHARED_LIBRARY)
diff --git a/device/generic/goldfish/lights/lights_hw.c b/device/generic/goldfish/lights/lights_hw.c
new file mode 100644
index 0000000..f78737d
--- /dev/null
+++ b/device/generic/goldfish/lights/lights_hw.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2014, 2017-2018 The  Linux Foundation. All rights reserved.
+ * Not a contribution
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+// #define LOG_NDEBUG 0
+
+#include <log/log.h>
+#include <cutils/properties.h>
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <dirent.h>
+
+#include <sys/ioctl.h>
+#include <sys/types.h>
+
+#include <hardware/lights.h>
+
+/*
+ * Change this to 1 to support battery notifications via BatteryService
+ */
+#define LIGHTS_SUPPORT_BATTERY 0
+#define CG_COLOR_ID_PROPERTY "ro.boot.hardware.color"
+
+/******************************************************************************/
+static pthread_once_t g_init = PTHREAD_ONCE_INIT;
+static pthread_mutex_t g_lock = PTHREAD_MUTEX_INITIALIZER;
+static int g_last_backlight_mode = BRIGHTNESS_MODE_USER;
+
+static char brightness_path[256] = "/sys/class/backlight/0-0062/brightness";
+
+/**
+ * device methods
+ */
+
+void init_globals(void)
+{
+    DIR *dir;
+    struct dirent *de;
+
+    // init the mutex
+    pthread_mutex_init(&g_lock, NULL);
+
+    dir = opendir("/sys/class/backlight");
+    if(dir) {
+        while((de = readdir(dir))) {
+            if(de->d_name[0] != '.') {
+                sprintf(brightness_path, "/sys/class/backlight/%s/brightness", de->d_name);
+                break;
+            }
+        }
+        closedir(dir);
+    }
+
+    ALOGW("Backlight path: %s\n", brightness_path);
+}
+
+static int
+write_int(char const* path, int value)
+{
+    int fd;
+    static int already_warned = 0;
+
+    fd = open(path, O_WRONLY);
+    if (fd >= 0) {
+        char buffer[20];
+        ssize_t amt;
+        size_t bytes = snprintf(buffer, sizeof(buffer), "%d\n", value);
+        if(bytes < sizeof(buffer)) {
+            amt = write(fd, buffer, bytes);
+        } else {
+            amt = -1;
+            errno = -EINVAL;
+        }
+        close(fd);
+        return amt == -1 ? -errno : 0;
+    } else {
+        if (already_warned == 0) {
+            ALOGE("write_int failed to open %s\n", path);
+            already_warned = 1;
+        }
+        return -errno;
+    }
+}
+
+static int
+is_lit(struct light_state_t const* state)
+{
+    return state->color & 0x00ffffff;
+}
+
+static int
+rgb_to_brightness(struct light_state_t const* state)
+{
+    int color = state->color & 0x00ffffff;
+    return ((77*((color>>16)&0x00ff))
+            + (150*((color>>8)&0x00ff)) + (29*(color&0x00ff))) >> 8;
+}
+
+static int
+brightness_equation(int brightness)
+{
+    if(brightness < 0)
+        brightness = 0;
+    if(brightness > 255)
+        brightness = 255;
+    brightness = 255 - brightness;
+    brightness = 255 * 255 - brightness * brightness;
+    brightness = (brightness * 2001) / (255 * 255);
+    return brightness;
+}
+
+static int
+set_light_backlight(struct light_device_t* dev,
+        struct light_state_t const* state)
+{
+    int err = 0;
+    int brightness = rgb_to_brightness(state);
+    unsigned int lpEnabled =
+        state->brightnessMode == BRIGHTNESS_MODE_LOW_PERSISTENCE;
+    if(!dev) {
+        return -1;
+    }
+
+    // The HAL requires that when low-persistence is requested, errors occur in only
+    // one case: if VR mode is unsupported.  So if the display just doesn't happen to
+    // be in the right state for VR mode (an error case in the SDM845 kernel driver),
+    // suppress the error.
+    bool suppress_persistence_error = false;
+
+    pthread_mutex_lock(&g_lock);
+    // Toggle low persistence mode state
+    bool persistence_mode = ((g_last_backlight_mode != state->brightnessMode && lpEnabled) ||
+                            (!lpEnabled &&
+                            g_last_backlight_mode == BRIGHTNESS_MODE_LOW_PERSISTENCE));
+    bool cannot_handle_persistence = persistence_mode;
+    g_last_backlight_mode = state->brightnessMode;
+
+    if (!err && !lpEnabled) {
+        brightness = brightness_equation(brightness);
+        err = write_int(brightness_path, brightness);
+    }
+
+    pthread_mutex_unlock(&g_lock);
+    if (suppress_persistence_error) {
+        return 0;
+    } else {
+        return cannot_handle_persistence ? -ENOSYS : err;
+    }
+}
+
+/** Close the lights device */
+static int
+close_lights(struct light_device_t *dev)
+{
+    if (dev) {
+        free(dev);
+    }
+    return 0;
+}
+
+
+/******************************************************************************/
+
+/**
+ * module methods
+ */
+
+/** Open a new instance of a lights device using name */
+static int open_lights(const struct hw_module_t* module, char const* name,
+        struct hw_device_t** device)
+{
+    int (*set_light)(struct light_device_t* dev,
+            struct light_state_t const* state);
+
+    if (0 == strcmp(LIGHT_ID_BACKLIGHT, name)) {
+        set_light = set_light_backlight;
+    } else
+        return -EINVAL;
+
+    pthread_once(&g_init, init_globals);
+
+    struct light_device_t *dev = malloc(sizeof(struct light_device_t));
+
+    if(!dev)
+        return -ENOMEM;
+
+    memset(dev, 0, sizeof(*dev));
+
+    dev->common.tag = HARDWARE_DEVICE_TAG;
+    dev->common.version = LIGHTS_DEVICE_API_VERSION_2_0;
+    dev->common.module = (struct hw_module_t*)module;
+    dev->common.close = (int (*)(struct hw_device_t*))close_lights;
+    dev->set_light = set_light;
+
+    *device = (struct hw_device_t*)dev;
+    return 0;
+}
+
+static struct hw_module_methods_t lights_module_methods = {
+    .open =  open_lights,
+};
+
+/*
+ * The lights Module
+ */
+struct hw_module_t HAL_MODULE_INFO_SYM = {
+    .tag = HARDWARE_MODULE_TAG,
+    .version_major = 1,
+    .version_minor = 0,
+    .id = LIGHTS_HARDWARE_MODULE_ID,
+    .name = "lights Module",
+    .author = "Google, Inc.",
+    .methods = &lights_module_methods,
+};
diff --git a/device/generic/goldfish/lights/lights_qemu.c b/device/generic/goldfish/lights/lights_qemu.c
deleted file mode 100644
index 1c408c1..0000000
--- a/device/generic/goldfish/lights/lights_qemu.c
+++ /dev/null
@@ -1,213 +0,0 @@
-/* Copyright (C) 2011 The Android Open Source Project
- *
- * Original code licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this software except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * This implements a lights hardware library for the Android emulator.
- * the following code should be built as a shared library that will be
- * placed into /system/lib/hw/lights.goldfish.so
- *
- * It will be loaded by the code in hardware/libhardware/hardware.c
- * which is itself called from
- * ./frameworks/base/services/jni/com_android_server_HardwareService.cpp
- */
-
-#ifdef LOG_TAG
-#undef LOG_TAG
-#define LOG_TAG "Lights"
-#endif
-
-/* we connect with the emulator through the "hw-control" qemud service */
-#define  LIGHTS_SERVICE_NAME "hw-control"
-
-#include <cutils/log.h>
-#include <stdint.h>
-#include <string.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <sys/ioctl.h>
-#include <sys/types.h>
-#include <hardware/lights.h>
-#include "qemud.h"
-
-/* Set to 1 to enable debug messages to the log */
-#define DEBUG 0
-#if DEBUG
-# define D(...) ALOGD(__VA_ARGS__)
-#else
-# define D(...) do{}while(0)
-#endif
-
-#define  E(...)  ALOGE(__VA_ARGS__)
-
-/* Get brightness(0~255) from state. */
-static int
-rgb_to_brightness( struct light_state_t const* state )
-{
-    int color = state->color & 0x00ffffff;
-    return ((77 * ((color >> 16) & 0x00ff))
-            + (150 * ((color >> 8) & 0x00ff)) + (29 * (color & 0x00ff))) >> 8;
-}
-
-/* set backlight brightness by LIGHTS_SERVICE_NAME service. */
-static int
-set_light_backlight( struct light_device_t* dev, struct light_state_t const* state )
-{
-    /* Get Lights service. */
-    int  fd = qemud_channel_open( LIGHTS_SERVICE_NAME );
-
-    if (fd < 0) {
-        E( "%s: no qemud connection", __FUNCTION__ );
-        return -1;
-    }
-
-    D( "%s: On/Off %d/%d flashMode %d brightnessMode %d"
-       " RGB = 0x%08x", __func__,
-       state->flashOnMS,
-       state->flashOffMS,
-       state->flashMode,
-       state->brightnessMode,
-       state->color );
-
-    int brightness = rgb_to_brightness( state );
-
-    char buffer[64];
-    snprintf( buffer, sizeof(buffer), "power:light:brightness:lcd_backlight:%d", brightness );
-    D( "%s: lcd_backlight command: %s", __FUNCTION__, buffer );
-
-    /* send backlight command to perform the backlight setting. */
-    if (qemud_channel_send( fd, buffer, -1 ) < 0) {
-        E( "%s: could not query lcd_backlight: %s", __FUNCTION__, strerror(errno) );
-        close( fd );
-        return -1;
-    }
-
-    close( fd );
-    return 0;
-}
-
-static int
-set_light_buttons( struct light_device_t* dev, struct light_state_t const* state )
-{
-    /* @Waiting for later implementation. */
-    D( "%s: Not implemented.", __FUNCTION__ );
-
-    return 0;
-}
-
-static int
-set_light_battery( struct light_device_t* dev, struct light_state_t const* state )
-{
-    /* @Waiting for later implementation. */
-    D( "%s: Not implemented.", __FUNCTION__ );
-
-    return 0;
-}
-
-static int
-set_light_keyboard( struct light_device_t* dev, struct light_state_t const* state )
-{
-    /* @Waiting for later implementation. */
-    D( "%s: Not implemented.", __FUNCTION__ );
-
-    return 0;
-}
-
-static int
-set_light_notifications( struct light_device_t* dev, struct light_state_t const* state )
-{
-    /* @Waiting for later implementation. */
-    D( "%s: Not implemented.", __FUNCTION__ );
-
-    return 0;
-}
-
-static int
-set_light_attention( struct light_device_t* dev, struct light_state_t const* state )
-{
-    /* @Waiting for later implementation. */
-    D( "%s: Not implemented.", __FUNCTION__ );
-
-    return 0;
-}
-
-/** Close the lights device */
-static int
-close_lights( struct light_device_t *dev )
-{
-    free( dev );
-
-    return 0;
-}
-
-/**
- * module methods
- */
-
-/** Open a new instance of a lights device using name */
-static int
-open_lights( const struct hw_module_t* module, char const *name,
-        struct hw_device_t **device )
-{
-    void* set_light;
-
-    if (0 == strcmp( LIGHT_ID_BACKLIGHT, name )) {
-        set_light = set_light_backlight;
-    } else if (0 == strcmp( LIGHT_ID_KEYBOARD, name )) {
-        set_light = set_light_keyboard;
-    } else if (0 == strcmp( LIGHT_ID_BUTTONS, name )) {
-        set_light = set_light_buttons;
-    } else if (0 == strcmp( LIGHT_ID_BATTERY, name )) {
-        set_light = set_light_battery;
-    } else if (0 == strcmp( LIGHT_ID_NOTIFICATIONS, name )) {
-        set_light = set_light_notifications;
-    } else if (0 == strcmp( LIGHT_ID_ATTENTION, name )) {
-        set_light = set_light_attention;
-    } else {
-        D( "%s: %s light isn't supported yet.", __FUNCTION__, name );
-        return -EINVAL;
-    }
-
-    struct light_device_t *dev = malloc( sizeof(struct light_device_t) );
-    if (dev == NULL) {
-        return -EINVAL;
-    }
-    memset( dev, 0, sizeof(*dev) );
-
-    dev->common.tag = HARDWARE_DEVICE_TAG;
-    dev->common.version = 0;
-    dev->common.module = (struct hw_module_t*)module;
-    dev->common.close = (int (*)(struct hw_device_t*))close_lights;
-    dev->set_light = set_light;
-
-    *device = (struct hw_device_t*)dev;
-    return 0;
-}
-
-static struct hw_module_methods_t lights_module_methods = {
-    .open =  open_lights,
-};
-
-/*
- * The emulator lights Module
- */
-struct hw_module_t HAL_MODULE_INFO_SYM = {
-    .tag = HARDWARE_MODULE_TAG,
-    .version_major = 1,
-    .version_minor = 0,
-    .id = LIGHTS_HARDWARE_MODULE_ID,
-    .name = "Goldfish lights Module",
-    .author = "The Android Open Source Project",
-    .methods = &lights_module_methods,
-};
diff --git a/device/generic/goldfish/manifest-arm.xml b/device/generic/goldfish/manifest-arm.xml
index 2189d91..0be055a 100644
--- a/device/generic/goldfish/manifest-arm.xml
+++ b/device/generic/goldfish/manifest-arm.xml
@@ -209,6 +209,51 @@
             <instance>default</instance>
         </interface>
     </hal>
+    <hal format="hidl">
+        <name>android.hardware.light</name>
+        <transport>hwbinder</transport>
+        <version>2.0</version>
+        <interface>
+            <name>ILight</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.memtrack</name>
+        <transport>hwbinder</transport>
+        <version>1.0</version>
+        <interface>
+            <name>IMemtrack</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.bluetooth</name>
+        <transport>hwbinder</transport>
+        <version>1.0</version>
+        <interface>
+            <name>IBluetoothHci</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.bluetooth.audio</name>
+        <transport>hwbinder</transport>
+        <version>2.0</version>
+        <interface>
+            <name>IBluetoothAudioProvidersFactory</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.usb</name>
+        <transport>hwbinder</transport>
+        <version>1.1</version>
+        <interface>
+            <name>IUsb</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
     <sepolicy>
         <version>27.0</version>
     </sepolicy>
diff --git a/device/generic/goldfish/manifest.xml b/device/generic/goldfish/manifest.xml
index dd598e8..551cf4d 100644
--- a/device/generic/goldfish/manifest.xml
+++ b/device/generic/goldfish/manifest.xml
@@ -209,6 +209,51 @@
             <instance>default</instance>
         </interface>
     </hal>
+    <hal format="hidl">
+        <name>android.hardware.light</name>
+        <transport>hwbinder</transport>
+        <version>2.0</version>
+        <interface>
+            <name>ILight</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.memtrack</name>
+        <transport>hwbinder</transport>
+        <version>1.0</version>
+        <interface>
+            <name>IMemtrack</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.bluetooth</name>
+        <transport>hwbinder</transport>
+        <version>1.0</version>
+        <interface>
+            <name>IBluetoothHci</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.bluetooth.audio</name>
+        <transport>hwbinder</transport>
+        <version>2.0</version>
+        <interface>
+            <name>IBluetoothAudioProvidersFactory</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
+    <hal format="hidl">
+        <name>android.hardware.usb</name>
+        <transport>hwbinder</transport>
+        <version>1.1</version>
+        <interface>
+            <name>IUsb</name>
+            <instance>default</instance>
+        </interface>
+    </hal>
     <sepolicy>
         <version>27.0</version>
     </sepolicy>
diff --git a/device/generic/goldfish/overlay/frameworks/base/core/res/res/values/config.xml b/device/generic/goldfish/overlay/frameworks/base/core/res/res/values/config.xml
index b466231..3eb6a35 100644
--- a/device/generic/goldfish/overlay/frameworks/base/core/res/res/values/config.xml
+++ b/device/generic/goldfish/overlay/frameworks/base/core/res/res/values/config.xml
@@ -40,4 +40,64 @@
          to get a smaller screen and opening the lid causes the device to enter the unfolded state
          which means to get a larger screen. -->
     <bool name="config_lidControlsDisplayFold">true</bool>
+
+    <!-- An array describing the screen's backlight values corresponding to the brightness
+         values in the config_screenBrightnessNits array.
+
+         This array should be equal in size to config_screenBrightnessBacklight. -->
+    <integer-array name="config_screenBrightnessBacklight">
+        <item>0</item>
+        <item>15</item>
+        <item>30</item>
+        <item>45</item>
+        <item>60</item>
+        <item>75</item>
+        <item>90</item>
+        <item>105</item>
+        <item>120</item>
+        <item>135</item>
+        <item>150</item>
+        <item>165</item>
+        <item>180</item>
+        <item>195</item>
+        <item>210</item>
+        <item>225</item>
+        <item>240</item>
+        <item>255</item>
+    </integer-array>
+
+    <!-- An array of floats describing the screen brightness in nits corresponding to the backlight
+         values in the config_screenBrightnessBacklight array.  On OLED displays these  values
+         should be measured with an all white image while the display is in the fully on state.
+         Note that this value should *not* reflect the maximum brightness value for any high
+         brightness modes but only the maximum brightness value obtainable in a sustainable manner.
+
+         This array should be equal in size to config_screenBrightnessBacklight -->
+    <array name="config_screenBrightnessNits">
+        <item>0</item>
+        <item>26.11</item>
+        <item>50.5</item>
+        <item>74.17</item>
+        <item>96.89</item>
+        <item>118.3</item>
+        <item>139.8</item>
+        <item>162.9</item>
+        <item>189.8</item>
+        <item>217.4</item>
+        <item>240.4</item>
+        <item>265.3</item>
+        <item>288.7</item>
+        <item>316</item>
+        <item>340.8</item>
+        <item>357.9</item>
+        <item>376.2</item>
+        <item>392.9</item>
+    </array>
+
+    <!-- Default screen brightness setting.
+         Must be in the range specified by minimum and maximum. -->
+    <integer name="config_screenBrightnessSettingDefault">165</integer>
+
+    <!-- If this is true, the screen will come on when you unplug usb/power/whatever. -->
+    <bool name="config_unplugTurnsOnScreen">true</bool>
 </resources>
diff --git a/device/generic/goldfish/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/device/generic/goldfish/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
index 7b206e4..029372f 100644
--- a/device/generic/goldfish/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/device/generic/goldfish/overlay/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -18,13 +18,12 @@
 -->
 
 <resources>
-    <bool name="def_lockscreen_disabled">true</bool>
+    <bool name="def_lockscreen_disabled">false</bool>
     <bool name="def_wifi_on">true</bool>
     <!-- Allow scanning even if WiFi is disabled -->
-    <integer name="def_wifi_scan_always_available">1</integer>
+    <integer name="def_wifi_scan_always_available">0</integer>
 
-    <!-- maximize the timeout to INT_MAX about 500+ hours -->
-    <integer name="def_screen_off_timeout">2147483647</integer>
+    <integer name="def_screen_off_timeout">30000</integer>
 
     <!-- Allow users to use both the on-screen keyboard, as well as a real
          keyboard -->
diff --git a/device/generic/goldfish/p2p_supplicant_overlay.conf b/device/generic/goldfish/p2p_supplicant_overlay.conf
new file mode 100644
index 0000000..b5e89e0
--- /dev/null
+++ b/device/generic/goldfish/p2p_supplicant_overlay.conf
@@ -0,0 +1,2 @@
+disable_scan_offload=1
+p2p_no_group_iface=1
diff --git a/device/generic/goldfish/sepolicy/common/file_contexts b/device/generic/goldfish/sepolicy/common/file_contexts
index c1350f9..9406df7 100644
--- a/device/generic/goldfish/sepolicy/common/file_contexts
+++ b/device/generic/goldfish/sepolicy/common/file_contexts
@@ -58,3 +58,9 @@
 /data/vendor/mediadrm(/.*)?            u:object_r:mediadrm_vendor_data_file:s0
 /data/vendor/var/run(/.*)?             u:object_r:varrun_file:s0
 
+# hx-touch
+/dev/hx-touch                          u:object_r:hx_touch_device:s0
+/vendor/bin/hw/hx-touchd               u:object_r:hx_touch_exec:s0
+/dev/block/nvme0n3                     u:object_r:syscfg_block_device:s0
+/apfs(/.*)?                            u:object_r:rootfs:s0
+/hostfs(/.*)?                          u:object_r:rootfs:s0
diff --git a/device/generic/goldfish/sepolicy/common/hx-touch.te b/device/generic/goldfish/sepolicy/common/hx-touch.te
new file mode 100644
index 0000000..02438e0
--- /dev/null
+++ b/device/generic/goldfish/sepolicy/common/hx-touch.te
@@ -0,0 +1,10 @@
+type hx_touch, domain;
+type hx_touch_exec, exec_type, vendor_file_type, file_type;
+
+init_daemon_domain(hx_touch)
+allow hx_touch hx_touch_device:chr_file rw_file_perms;
+allow hx_touch console_device:chr_file rw_file_perms;
+allow hx_touch syscfg_block_device:blk_file rw_file_perms;
+
+type hx_touch_device, dev_type;
+type syscfg_block_device, dev_type;
diff --git a/device/generic/goldfish/syscfg/Android.bp b/device/generic/goldfish/syscfg/Android.bp
new file mode 100644
index 0000000..c58b9a2
--- /dev/null
+++ b/device/generic/goldfish/syscfg/Android.bp
@@ -0,0 +1,12 @@
+cc_binary {
+    name: "syscfg",
+    proprietary: true,
+    srcs: [
+        "main.c",
+        "syscfg.c",
+    ],
+    cflags: [
+        "-Wall",
+        "-Werror",
+    ],
+}
diff --git a/device/generic/goldfish/syscfg/main.c b/device/generic/goldfish/syscfg/main.c
new file mode 100644
index 0000000..2c9d121
--- /dev/null
+++ b/device/generic/goldfish/syscfg/main.c
@@ -0,0 +1,81 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syscfg.h>
+
+int main(int argc, char *argv[])
+{
+    uint8_t *buf, ch;
+    unsigned long len, explen = 0, i;
+    char fmt = 's', sep = 0, *fa;
+    uint64_t ubuf;
+
+    if(argc < 3 || argc > 4) {
+        fprintf(stderr, "usage: syscfg <syscfg.bin> <entry> [<format>]\n"
+                        "       <syscfg.bin> is usually /dev/nvme0n3\n"
+                        "       <entry> is 4-characted entry ID\n"
+                        "       <format> is [<type>][<len>]\n"
+                        "         <type> is 's' for string, 'z' for zero-terminated string,\n"
+                        "                   'u' for unsigned decimal, 'x' for hex\n"
+                        "                   (optionally followed by separator character)\n"
+                        "         <len> is expected number of bytes (otherwise prints all)\n");
+        return 1;
+    }
+
+    buf = syscfg_get(argv[1], argv[2], &len);
+    if(!buf) {
+        fprintf(stderr, "SysCfg item '%s' not found.\n", argv[2]);
+        return 1;
+    }
+
+    if(argc >= 4) {
+        fa = argv[3];
+        if(fa[0] > '9') {
+            fmt = fa[0];
+            fa ++;
+            if(fa[0] && (fa[0] < '0' || fa[0] > '9')) {
+                sep = fa[0];
+                fa ++;
+            }
+        }
+        if(fa[0])
+            explen = strtoul(fa, NULL, 0);
+    }
+
+    if(!explen)
+        explen = len;
+
+    if(fmt == 'u') {
+        if(len > 8)
+            len = 8;
+        ubuf = 0;
+        memcpy(&ubuf, buf, len);
+        printf("%llu", (unsigned long long)ubuf);
+        return 0;
+    }
+
+    for(i=0; i<explen; i++) {
+        ch = (i < len) ? buf[i] : 0;
+        switch(fmt) {
+        case 's':
+            putchar(ch);
+            break;
+        case 'z':
+            if(ch == '\0')
+                return 0;
+            putchar(ch);
+            break;
+        case 'x':
+            printf("%02x", ch);
+            if(sep && i < explen - 1)
+                putchar(sep);
+            break;
+        default:
+            fprintf(stderr, "unknown format character '%c'.\n", fmt);
+            return 1;
+        }
+    }
+
+    return 0;
+}
diff --git a/device/generic/goldfish/syscfg/syscfg.c b/device/generic/goldfish/syscfg/syscfg.c
new file mode 100644
index 0000000..f03bca5
--- /dev/null
+++ b/device/generic/goldfish/syscfg/syscfg.c
@@ -0,0 +1,136 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2018-20 Corellium LLC
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define DEFAULT_SIZE 131072
+#define MAX_SIZE 8192
+
+struct syscfg_hdr {
+    char magic[4];
+    uint32_t unk_0; /* 0x7C */
+    uint32_t size;
+    uint32_t version;
+    uint32_t unk_1; /* 0 */
+    uint32_t nkeys;
+};
+
+struct syscfg_key {
+    char name[4];
+    union {
+        uint8_t value[16];
+        struct {
+            char name[4];
+            uint32_t size;
+            uint32_t offset;
+            uint32_t rsvd; /* -1 */
+        } jumbo;
+    };
+};
+
+static void flip4(char *out, char *in)
+{
+    unsigned i;
+    for(i=0; i<4; i++)
+        out[i] = in[3-i];
+}
+
+void *syscfg_get(const char *fname, const char *elem, unsigned long *plen)
+{
+    FILE *f = fopen(fname, "rb");
+    unsigned size, elen = 0;
+    uint8_t *buf;
+    struct syscfg_hdr *hdr;
+    struct syscfg_key *key;
+    unsigned idx;
+    char name[5];
+    void *eval = NULL, *res = NULL;
+
+    if(!f) {
+        fprintf(stderr, "Could not open file '%s'.\n", fname);
+        return NULL;
+    }
+    fseek(f, 0, SEEK_END);
+    size = ftell(f);
+    fseek(f, 0, SEEK_SET);
+
+    if(!size)
+        size = DEFAULT_SIZE;
+
+    buf = malloc(size);
+    if(!buf) {
+        fclose(f);
+        fprintf(stderr, "Could not allocate memory.\n");
+        return NULL;
+    }
+    size = fread(buf, 1, size, f);
+    fclose(f);
+
+    if(size < sizeof(struct syscfg_hdr)) {
+        fprintf(stderr, "SysCfg too small for header.\n");
+        free(buf);
+        return NULL;
+    }
+
+    hdr = (void *)buf;
+    if(memcmp(hdr->magic, "gfCS", 4)) {
+        fprintf(stderr, "SysCfg header magic value incorrect.\n");
+        free(buf);
+        return NULL;
+    }
+    if(hdr->size > size) {
+        fprintf(stderr, "SysCfg header declares %d bytes, but only %d in file.\n", hdr->size, size);
+        free(buf);
+        return NULL;
+    }
+    if(hdr->nkeys * sizeof(struct syscfg_key) + sizeof(struct syscfg_hdr) > hdr->size) {
+        fprintf(stderr, "SysCfg header declares %d entries, does not fit in %d bytes.\n", hdr->nkeys, hdr->size);
+        free(buf);
+        return NULL;
+    }
+
+    key = (void *)(hdr + 1);
+    name[4] = 0;
+    for(idx=0; idx<hdr->nkeys; idx++)
+        if(memcmp(key[idx].name, "BTNC", 4)) {
+            flip4(name, key[idx].name);
+            if(!strcmp(name, elem)) {
+                eval = key[idx].value;
+                elen = sizeof(key[idx].value);
+                break;
+            }
+        } else {
+            flip4(name, key[idx].jumbo.name);
+            if(!strcmp(name, elem)) {
+                if(key[idx].jumbo.offset > hdr->size || key[idx].jumbo.offset + key[idx].jumbo.size > hdr->size) {
+                    fprintf(stderr, "SysCfg jumbo key '%s' does not fit in %d bytes (%d+%d).\n", name, hdr->size, key[idx].jumbo.offset, key[idx].jumbo.size);
+                    free(buf);
+                    return NULL;
+                }
+                eval = buf + key[idx].jumbo.offset;
+                elen = key[idx].jumbo.size;
+                break;
+            }
+        }
+
+    if(eval) {
+        res = malloc(elen);
+        if(!res) {
+            free(buf);
+            fprintf(stderr, "Could not allocate memory.\n");
+            return NULL;
+        }
+
+        memcpy(res, eval, elen);
+    }
+
+    free(buf);
+    if(plen)
+        *plen = elen;
+    return res;
+}
diff --git a/device/generic/goldfish/syscfg/syscfg.h b/device/generic/goldfish/syscfg/syscfg.h
new file mode 100644
index 0000000..9de3e2c
--- /dev/null
+++ b/device/generic/goldfish/syscfg/syscfg.h
@@ -0,0 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2018-20 Corellium LLC
+ */
+
+#ifndef _SYSCFG_H
+#define _SYSCFG_H
+
+void *syscfg_get(const char *fname, const char *elem, unsigned long *plen);
+
+#endif
diff --git a/device/generic/goldfish/usb/Android.bp b/device/generic/goldfish/usb/Android.bp
new file mode 100644
index 0000000..9198043
--- /dev/null
+++ b/device/generic/goldfish/usb/Android.bp
@@ -0,0 +1,35 @@
+// Copyright (C) 2017 The Android Open Source Project
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+cc_binary {
+    name: "android.hardware.usb@1.0-service.ranchu",
+    defaults: ["hidl_defaults"],
+    init_rc: ["android.hardware.usb@1.0-service.ranchu.rc"],
+    relative_install_path: "hw",
+    vendor: true,
+    srcs: [
+        "service.cpp",
+        "Usb.cpp",
+    ],
+
+    shared_libs: [
+        "libcutils",
+        "libhidlbase",
+        "libhidltransport",
+        "liblog",
+        "libutils",
+        "libhardware",
+        "android.hardware.usb@1.0",
+    ],
+}
diff --git a/device/generic/goldfish/usb/OWNERS b/device/generic/goldfish/usb/OWNERS
new file mode 100644
index 0000000..fefae56
--- /dev/null
+++ b/device/generic/goldfish/usb/OWNERS
@@ -0,0 +1 @@
+badhri@google.com
diff --git a/device/generic/goldfish/usb/Usb.cpp b/device/generic/goldfish/usb/Usb.cpp
new file mode 100644
index 0000000..0385b7d
--- /dev/null
+++ b/device/generic/goldfish/usb/Usb.cpp
@@ -0,0 +1,338 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+#include <assert.h>
+#include <dirent.h>
+#include <iostream>
+#include <fstream>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#include <cutils/uevent.h>
+#include <sys/epoll.h>
+#include <utils/Errors.h>
+#include <utils/StrongPointer.h>
+
+#include "Usb.h"
+
+namespace android {
+namespace hardware {
+namespace usb {
+namespace V1_0 {
+namespace implementation {
+
+// Set by the signal handler to destroy the thread
+volatile bool destroyThread;
+
+bool roleIsOk(PortRole role) {
+    if (role.type == PortRoleType::POWER_ROLE) {
+        if (role.role ==  static_cast<uint32_t> (PortPowerRole::SINK))
+            return true;
+    } else if (role.type == PortRoleType::DATA_ROLE) {
+        if (role.role == static_cast<uint32_t> (PortDataRole::DEVICE))
+            return true;
+    } else if (role.type == PortRoleType::MODE) {
+        if (role.role == static_cast<uint32_t> (PortMode::UFP))
+            return true;
+    }
+    return false;
+}
+
+Return<void> Usb::switchRole(const hidl_string& portName,
+        const PortRole& newRole) {
+
+    if(roleIsOk(newRole)) {
+        ALOGI("Role switch successful");
+        Return<void> ret = mCallback->notifyRoleSwitchStatus(portName, newRole, Status::SUCCESS);
+        if (!ret.isOk())
+            ALOGE("RoleSwitchStatus error %s", ret.description().c_str());
+    } else {
+        ALOGI("Role switch failed");
+        Return<void> ret = mCallback->notifyRoleSwitchStatus(portName, newRole, Status::ERROR);
+        if (!ret.isOk())
+            ALOGE("RoleSwitchStatus error %s", ret.description().c_str());
+    }
+
+    return Void();
+}
+
+Status getCurrentRoleHelper(std::string portName,
+        PortRoleType type, uint32_t &currentRole)  {
+    (void)portName;
+    if (type == PortRoleType::POWER_ROLE) {
+        currentRole = static_cast<uint32_t>(PortPowerRole::SINK);
+    } else if (type == PortRoleType::DATA_ROLE) {
+        currentRole = static_cast<uint32_t> (PortDataRole::DEVICE);
+    } else if (type == PortRoleType::MODE) {
+        currentRole = static_cast<uint32_t> (PortMode::UFP);
+    }
+
+    return Status::SUCCESS;
+}
+
+bool canSwitchRoleHelper(const std::string portName, PortRoleType type)  {
+    (void)portName;
+    (void)type;
+    return false;
+}
+
+Status getPortModeHelper(const std::string portName, PortMode& portMode)  {
+    (void)portName;
+    portMode = PortMode::UFP;
+    return Status::SUCCESS;
+}
+
+Status getTypeCPortNamesHelper(std::vector<std::string>& names) {
+    names.resize(1);
+    names[0] = "usb0";
+    return Status::SUCCESS;
+}
+
+Status getPortStatusHelper (hidl_vec<PortStatus>& currentPortStatus) {
+    std::vector<std::string> names;
+    Status result = getTypeCPortNamesHelper(names);
+
+    if (result == Status::SUCCESS) {
+        currentPortStatus.resize(names.size());
+        for(std::vector<std::string>::size_type i = 0; i < names.size(); i++) {
+            ALOGI("%s", names[i].c_str());
+            currentPortStatus[i].portName = names[i];
+
+            uint32_t currentRole;
+            if (getCurrentRoleHelper(names[i], PortRoleType::POWER_ROLE,
+                    currentRole) == Status::SUCCESS) {
+                currentPortStatus[i].currentPowerRole =
+                static_cast<PortPowerRole> (currentRole);
+            } else {
+                ALOGE("Error while retreiving portNames");
+                goto done;
+            }
+
+            if (getCurrentRoleHelper(names[i],
+                    PortRoleType::DATA_ROLE, currentRole) == Status::SUCCESS) {
+                currentPortStatus[i].currentDataRole =
+                        static_cast<PortDataRole> (currentRole);
+            } else {
+                ALOGE("Error while retreiving current port role");
+                goto done;
+            }
+
+            if (getCurrentRoleHelper(names[i], PortRoleType::MODE,
+                    currentRole) == Status::SUCCESS) {
+                currentPortStatus[i].currentMode =
+                    static_cast<PortMode> (currentRole);
+            } else {
+                ALOGE("Error while retreiving current data role");
+                goto done;
+            }
+
+            currentPortStatus[i].canChangeMode =
+                canSwitchRoleHelper(names[i], PortRoleType::MODE);
+            currentPortStatus[i].canChangeDataRole =
+                canSwitchRoleHelper(names[i], PortRoleType::DATA_ROLE);
+            currentPortStatus[i].canChangePowerRole =
+                canSwitchRoleHelper(names[i], PortRoleType::POWER_ROLE);
+
+            ALOGI("canChangeMode: %d canChagedata: %d canChangePower:%d",
+                currentPortStatus[i].canChangeMode,
+                currentPortStatus[i].canChangeDataRole,
+                currentPortStatus[i].canChangePowerRole);
+
+            if (getPortModeHelper(names[i], currentPortStatus[i].supportedModes)
+                  != Status::SUCCESS) {
+                ALOGE("Error while retrieving port modes");
+                goto done;
+            }
+        }
+        return Status::SUCCESS;
+    }
+done:
+    return Status::ERROR;
+}
+
+Return<void> Usb::queryPortStatus() {
+    hidl_vec<PortStatus> currentPortStatus;
+    Status status;
+
+    status = getPortStatusHelper(currentPortStatus);
+    Return<void> ret = mCallback->notifyPortStatusChange(currentPortStatus,
+       status);
+    if (!ret.isOk())
+        ALOGE("queryPortStatus error %s", ret.description().c_str());
+
+    return Void();
+}
+struct data {
+    int uevent_fd;
+    android::hardware::usb::V1_0::implementation::Usb *usb;
+};
+
+static void uevent_event(uint32_t /*epevents*/, struct data *payload) {
+    char msg[UEVENT_MSG_LEN + 2];
+    char *cp;
+    int n;
+
+    n = uevent_kernel_multicast_recv(payload->uevent_fd, msg, UEVENT_MSG_LEN);
+    if (n <= 0)
+        return;
+    if (n >= UEVENT_MSG_LEN)   /* overflow -- discard */
+        return;
+
+    msg[n] = '\0';
+    msg[n + 1] = '\0';
+    cp = msg;
+
+    while (*cp) {
+        if (!strcmp(cp, "SUBSYSTEM=dual_role_usb")) {
+            ALOGE("uevent received %s", cp);
+            if (payload->usb->mCallback != NULL) {
+                hidl_vec<PortStatus> currentPortStatus;
+                Status status = getPortStatusHelper(currentPortStatus);
+                Return<void> ret =
+                    payload->usb->mCallback->notifyPortStatusChange(currentPortStatus, status);
+                if (!ret.isOk())
+                    ALOGE("error %s", ret.description().c_str());
+            }
+            break;
+        }
+        /* advance to after the next \0 */
+        while (*cp++);
+    }
+}
+
+void* work(void* param) {
+    int epoll_fd, uevent_fd;
+    struct epoll_event ev;
+    int nevents = 0;
+    struct data payload;
+
+    ALOGE("creating thread");
+
+    uevent_fd = uevent_open_socket(64*1024, true);
+
+    if (uevent_fd < 0) {
+        ALOGE("uevent_init: uevent_open_socket failed\n");
+        return NULL;
+    }
+
+    payload.uevent_fd = uevent_fd;
+    payload.usb = (android::hardware::usb::V1_0::implementation::Usb *)param;
+
+    fcntl(uevent_fd, F_SETFL, O_NONBLOCK);
+
+    ev.events = EPOLLIN;
+    ev.data.ptr = (void *)uevent_event;
+
+    epoll_fd = epoll_create(64);
+    if (epoll_fd == -1) {
+        ALOGE("epoll_create failed; errno=%d", errno);
+        goto error;
+    }
+
+    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, uevent_fd, &ev) == -1) {
+        ALOGE("epoll_ctl failed; errno=%d", errno);
+        goto error;
+    }
+
+    while (!destroyThread) {
+        struct epoll_event events[64];
+
+        nevents = epoll_wait(epoll_fd, events, 64, -1);
+        if (nevents == -1) {
+            if (errno == EINTR)
+                continue;
+            ALOGE("usb epoll_wait failed; errno=%d", errno);
+            break;
+        }
+
+        for (int n = 0; n < nevents; ++n) {
+            if (events[n].data.ptr)
+                (*(void (*)(int, struct data *payload))events[n].data.ptr)
+                    (events[n].events, &payload);
+        }
+    }
+
+    ALOGI("exiting worker thread");
+error:
+    close(uevent_fd);
+
+    if (epoll_fd >= 0)
+        close(epoll_fd);
+
+    return NULL;
+}
+
+void sighandler(int sig)
+{
+    if (sig == SIGUSR1) {
+        destroyThread = true;
+        ALOGI("destroy set");
+        return;
+    }
+    signal(SIGUSR1, sighandler);
+}
+
+Return<void> Usb::setCallback(const sp<IUsbCallback>& callback) {
+
+    pthread_mutex_lock(&mLock);
+    if ((mCallback == NULL && callback == NULL) ||
+            (mCallback != NULL && callback != NULL)) {
+        mCallback = callback;
+        pthread_mutex_unlock(&mLock);
+        return Void();
+    }
+
+    mCallback = callback;
+    ALOGI("registering callback");
+
+    if (mCallback == NULL) {
+        if  (!pthread_kill(mPoll, SIGUSR1)) {
+            pthread_join(mPoll, NULL);
+            ALOGI("pthread destroyed");
+        }
+        pthread_mutex_unlock(&mLock);
+        return Void();
+    }
+
+    destroyThread = false;
+    signal(SIGUSR1, sighandler);
+
+    if (pthread_create(&mPoll, NULL, work, this)) {
+        ALOGE("pthread creation failed %d", errno);
+        mCallback = NULL;
+    }
+    pthread_mutex_unlock(&mLock);
+    return Void();
+}
+
+// Protects *usb assignment
+pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
+Usb *usb;
+
+Usb::Usb() {
+    pthread_mutex_lock(&lock);
+    // Make this a singleton class
+    assert(usb == NULL);
+    usb = this;
+    pthread_mutex_unlock(&lock);
+}
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace usb
+}  // namespace hardware
+}  // namespace android
diff --git a/device/generic/goldfish/usb/Usb.h b/device/generic/goldfish/usb/Usb.h
new file mode 100644
index 0000000..ddfcac6
--- /dev/null
+++ b/device/generic/goldfish/usb/Usb.h
@@ -0,0 +1,52 @@
+#ifndef ANDROID_HARDWARE_USB_V1_0_USB_H
+#define ANDROID_HARDWARE_USB_V1_0_USB_H
+
+#include <android/hardware/usb/1.0/IUsb.h>
+#include <hidl/MQDescriptor.h>
+#include <hidl/Status.h>
+#include <log/log.h>
+
+#ifdef LOG_TAG
+#undef LOG_TAG
+#endif
+
+#define LOG_TAG "android.hardware.usb@1.0-service"
+#define UEVENT_MSG_LEN 2048
+
+namespace android {
+namespace hardware {
+namespace usb {
+namespace V1_0 {
+namespace implementation {
+
+using ::android::hardware::usb::V1_0::IUsb;
+using ::android::hardware::usb::V1_0::IUsbCallback;
+using ::android::hardware::usb::V1_0::PortRole;
+using ::android::hidl::base::V1_0::IBase;
+using ::android::hardware::hidl_array;
+using ::android::hardware::hidl_memory;
+using ::android::hardware::hidl_string;
+using ::android::hardware::hidl_vec;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::sp;
+
+struct Usb : public IUsb {
+    Usb();
+    Return<void> switchRole(const hidl_string& portName, const PortRole& role) override;
+    Return<void> setCallback(const sp<IUsbCallback>& callback) override;
+    Return<void> queryPortStatus() override;
+
+    sp<IUsbCallback> mCallback;
+    private:
+        pthread_t mPoll;
+        pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER;
+};
+
+}  // namespace implementation
+}  // namespace V1_0
+}  // namespace usb
+}  // namespace hardware
+}  // namespace android
+
+#endif  // ANDROID_HARDWARE_USB_V1_0_USB_H
diff --git a/device/generic/goldfish/usb/android.hardware.usb@1.0-service.ranchu.rc b/device/generic/goldfish/usb/android.hardware.usb@1.0-service.ranchu.rc
new file mode 100644
index 0000000..322c1c9
--- /dev/null
+++ b/device/generic/goldfish/usb/android.hardware.usb@1.0-service.ranchu.rc
@@ -0,0 +1,4 @@
+service vendor.usb-hal-1-0 /vendor/bin/hw/android.hardware.usb@1.0-service.ranchu
+    class hal
+    user system
+    group system
diff --git a/device/generic/goldfish/usb/service.cpp b/device/generic/goldfish/usb/service.cpp
new file mode 100644
index 0000000..43ab6f0
--- /dev/null
+++ b/device/generic/goldfish/usb/service.cpp
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <hidl/HidlTransportSupport.h>
+#include "Usb.h"
+
+using android::sp;
+
+// libhwbinder:
+using android::hardware::configureRpcThreadpool;
+using android::hardware::joinRpcThreadpool;
+
+// Generated HIDL files
+using android::hardware::usb::V1_0::IUsb;
+using android::hardware::usb::V1_0::implementation::Usb;
+
+using android::status_t;
+using android::OK;
+
+int main() {
+
+    android::sp<IUsb> service = new Usb();
+
+    configureRpcThreadpool(1, true /*callerWillJoin*/);
+    status_t status = service->registerAsService();
+
+    if (status == OK) {
+        ALOGI("USB HAL Ready.");
+        joinRpcThreadpool();
+    }
+
+    ALOGE("Cannot register USB HAL service");
+    return 1;
+}
diff --git a/device/generic/goldfish/vendor.mk b/device/generic/goldfish/vendor.mk
index 2d2642d..1d0a9ec 100644
--- a/device/generic/goldfish/vendor.mk
+++ b/device/generic/goldfish/vendor.mk
@@ -17,12 +17,12 @@
 # This file is to configure vendor/data partitions of emulator-related products
 #
 
+BOARD_HAVE_BLUETOOTH := true
+
 # Device modules
 PRODUCT_PACKAGES += \
     vulkan.ranchu \
-    gralloc.goldfish \
     gralloc.goldfish.default \
-    gralloc.ranchu \
     libGLESv1_CM_emulation \
     lib_renderControl_enc \
     libEGL_emulation \
@@ -45,8 +45,7 @@ PRODUCT_PACKAGES += \
     gps.goldfish \
     gps.ranchu \
     fingerprint.goldfish \
-    audio.primary.goldfish \
-    audio.primary.goldfish_legacy \
+    audio.primary.default \
     power.goldfish \
     power.ranchu \
     fingerprint.ranchu \
@@ -60,13 +59,25 @@ PRODUCT_PACKAGES += \
     hwcomposer.ranchu \
     toybox_vendor \
     android.hardware.audio@2.0-service \
-    android.hardware.wifi@1.0-service \
     android.hardware.biometrics.fingerprint@2.1-service \
+    android.hardware.bluetooth@1.0-service.btlinux \
+    android.hardware.bluetooth.audio@2.0-impl \
+    android.hardware.usb@1.0-service.ranchu \
     sh_vendor \
     iw_vendor \
     audio.r_submix.default \
     local_time.default \
-    SdkSetup
+    SdkSetup \
+    hx-touchd \
+    syscfg \
+    hcdpack \
+    openlauncher \
+    Launcher3QuickStepNoLaunch \
+    signal
+
+PRODUCT_PACKAGES += memtrack.ranchu \
+    android.hardware.memtrack@1.0-service \
+    android.hardware.memtrack@1.0-impl
 
 PRODUCT_PACKAGES += \
     android.hardware.audio@4.0-impl:32 \
@@ -91,6 +102,10 @@ PRODUCT_PACKAGES += \
     android.hardware.gnss@1.0-impl
 endif
 
+PRODUCT_PACKAGES += \
+    lights.ranchu \
+    android.hardware.light@2.0-impl \
+    android.hardware.light@2.0-service
 
 PRODUCT_PACKAGES += \
     android.hardware.sensors@1.0-impl \
@@ -107,9 +122,14 @@ PRODUCT_PACKAGES += \
 
 PRODUCT_PROPERTY_OVERRIDES += ro.control_privapp_permissions=enforce
 PRODUCT_PROPERTY_OVERRIDES += ro.hardware.power=ranchu
+PRODUCT_PROPERTY_OVERRIDES += ro.sf.lcd_density=326
+PRODUCT_PROPERTY_OVERRIDES += ro.radio.noril=true
+PRODUCT_PROPERTY_OVERRIDES += qemu.hw.mainkeys=0
 
 PRODUCT_PROPERTY_OVERRIDES += persist.sys.zram_enabled=1 \
 
+PRODUCT_DISABLE_SCUDO := true
+
 PRODUCT_PACKAGES += \
     camera.device@1.0-impl \
     android.hardware.camera.provider@2.4-service \
@@ -119,18 +139,6 @@ PRODUCT_PACKAGES += \
     android.hardware.gatekeeper@1.0-impl \
     android.hardware.gatekeeper@1.0-service
 
-# WiFi: vendor side
-PRODUCT_PACKAGES += \
-	createns \
-	dhcpclient \
-	dhcpserver \
-	execns \
-	hostapd \
-	hostapd_nohidl \
-	ipv6proxy \
-	netmgr \
-	wpa_supplicant \
-
 PRODUCT_PACKAGES += android.hardware.thermal@2.0-service.mock
 
 # Needed for /system/priv-app/SdkSetup/SdkSetup.apk to pass CTS android.permission2.cts.PrivappPermissionsTest.
@@ -146,20 +154,21 @@ PRODUCT_COPY_FILES += \
     device/generic/goldfish/fstab.ranchu.initrd:$(TARGET_COPY_OUT_RAMDISK)/fstab.ranchu \
     device/generic/goldfish/data/etc/apns-conf.xml:data/misc/apns/apns-conf.xml \
     device/generic/goldfish/data/etc/local.prop:data/local.prop \
+    device/generic/goldfish/init.hardware.usb.rc:$(TARGET_COPY_OUT_VENDOR)/etc/init/hw/init.ranchu.usb.rc \
     device/generic/goldfish/init.ranchu-core.sh:$(TARGET_COPY_OUT_VENDOR)/bin/init.ranchu-core.sh \
     device/generic/goldfish/init.ranchu-net.sh:$(TARGET_COPY_OUT_VENDOR)/bin/init.ranchu-net.sh \
-    device/generic/goldfish/wifi/init.wifi.sh:$(TARGET_COPY_OUT_VENDOR)/bin/init.wifi.sh \
     device/generic/goldfish/init.ranchu.rc:$(TARGET_COPY_OUT_VENDOR)/etc/init/hw/init.ranchu.rc \
     device/generic/goldfish/fstab.ranchu:$(TARGET_COPY_OUT_VENDOR)/etc/fstab.ranchu \
     device/generic/goldfish/ueventd.ranchu.rc:$(TARGET_COPY_OUT_VENDOR)/ueventd.rc \
     device/generic/goldfish/input/goldfish_rotary.idc:$(TARGET_COPY_OUT_VENDOR)/usr/idc/goldfish_rotary.idc \
     device/generic/goldfish/manifest.xml:$(TARGET_COPY_OUT_VENDOR)/manifest.xml \
     device/generic/goldfish/data/etc/config.ini:config.ini \
-    device/generic/goldfish/wifi/simulated_hostapd.conf:$(TARGET_COPY_OUT_VENDOR)/etc/simulated_hostapd.conf \
     device/generic/goldfish/wifi/wpa_supplicant.conf:$(TARGET_COPY_OUT_VENDOR)/etc/wifi/wpa_supplicant.conf \
-    device/generic/goldfish/wifi/WifiConfigStore.xml:data/misc/wifi/WifiConfigStore.xml \
     frameworks/native/data/etc/android.hardware.wifi.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.wifi.xml \
     frameworks/native/data/etc/android.hardware.wifi.direct.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.wifi.direct.xml \
+    frameworks/native/data/etc/android.hardware.bluetooth.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.bluetooth.xml \
+    frameworks/native/data/etc/android.hardware.bluetooth_le.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.bluetooth_le.xml \
+    frameworks/native/data/etc/android.hardware.usb.accessory.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/android.hardware.usb.accessory.xml \
     device/generic/goldfish/data/etc/handheld_core_hardware.xml:$(TARGET_COPY_OUT_VENDOR)/etc/permissions/handheld_core_hardware.xml \
     device/generic/goldfish/camera/media_profiles.xml:$(TARGET_COPY_OUT_VENDOR)/etc/media_profiles_V1_0.xml \
     frameworks/av/media/libstagefright/data/media_codecs_google_audio.xml:$(TARGET_COPY_OUT_VENDOR)/etc/media_codecs_google_audio.xml \
@@ -182,3 +191,17 @@ PRODUCT_COPY_FILES += \
     frameworks/av/services/audiopolicy/config/audio_policy_volumes.xml:$(TARGET_COPY_OUT_VENDOR)/etc/audio_policy_volumes.xml \
     frameworks/av/services/audiopolicy/config/default_volume_tables.xml:$(TARGET_COPY_OUT_VENDOR)/etc/default_volume_tables.xml \
     frameworks/av/services/audiopolicy/config/surround_sound_configuration_5_0.xml:$(TARGET_COPY_OUT_VENDOR)/etc/surround_sound_configuration_5_0.xml \
+    device/generic/goldfish/hx-touch/hx-touch.fwlist:$(TARGET_COPY_OUT_VENDOR)/etc/hw/hx-touch.fwlist \
+
+# WLAN driver configuration files
+PRODUCT_COPY_FILES += \
+    device/generic/goldfish/wpa_supplicant_overlay.conf:$(TARGET_COPY_OUT_VENDOR)/etc/wifi/wpa_supplicant_overlay.conf     \
+    device/generic/goldfish/p2p_supplicant_overlay.conf:$(TARGET_COPY_OUT_VENDOR)/etc/wifi/p2p_supplicant_overlay.conf     \
+
+# Wi-Fi
+PRODUCT_PACKAGES += \
+    android.hardware.wifi@1.0-service \
+    libwpa_client \
+    hostapd \
+    wificond \
+    wpa_supplicant
diff --git a/device/generic/goldfish/wifi/WifiConfigStore.xml b/device/generic/goldfish/wifi/WifiConfigStore.xml
deleted file mode 100644
index bb5645a..0000000
--- a/device/generic/goldfish/wifi/WifiConfigStore.xml
+++ /dev/null
@@ -1,48 +0,0 @@
-<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
-<WifiConfigStoreData>
-    <int name="Version" value="1" />
-    <NetworkList>
-        <Network>
-            <WifiConfiguration>
-                <string name="ConfigKey">&quot;AndroidWifi&quot;NONE</string>
-                <string name="SSID">&quot;AndroidWifi&quot;</string>
-                <null name="BSSID" />
-                <null name="PreSharedKey" />
-                <null name="WEPKeys" />
-                <int name="WEPTxKeyIndex" value="0" />
-                <boolean name="HiddenSSID" value="false" />
-                <boolean name="RequirePMF" value="false" />
-                <byte-array name="AllowedKeyMgmt" num="1">01</byte-array>
-                <byte-array name="AllowedProtocols" num="1">03</byte-array>
-                <byte-array name="AllowedAuthAlgos" num="1">01</byte-array>
-                <byte-array name="AllowedGroupCiphers" num="1">0f</byte-array>
-                <byte-array name="AllowedPairwiseCiphers" num="1">06</byte-array>
-                <boolean name="Shared" value="true" />
-                <int name="Status" value="0" />
-                <null name="FQDN" />
-                <null name="ProviderFriendlyName" />
-                <null name="LinkedNetworksList" />
-                <null name="DefaultGwMacAddress" />
-                <boolean name="ValidatedInternetAccess" value="true" />
-                <boolean name="NoInternetAccessExpected" value="false" />
-                <int name="UserApproved" value="0" />
-                <boolean name="MeteredHint" value="false" />
-                <boolean name="UseExternalScores" value="false" />
-                <int name="NumAssociation" value="2" />
-                <boolean name="IsLegacyPasspointConfig" value="false" />
-                <long-array name="RoamingConsortiumOIs" num="0" />
-            </WifiConfiguration>
-            <NetworkStatus>
-                <string name="SelectionStatus">NETWORK_SELECTION_ENABLED</string>
-                <string name="DisableReason">NETWORK_SELECTION_ENABLE</string>
-            </NetworkStatus>
-            <IpConfiguration>
-                <string name="IpAssignment">DHCP</string>
-                <string name="ProxySettings">NONE</string>
-            </IpConfiguration>
-        </Network>
-    </NetworkList>
-    <PasspointConfigData>
-        <long name="ProviderIndex" value="0" />
-    </PasspointConfigData>
-</WifiConfigStoreData>
diff --git a/device/generic/goldfish/wifi/createns/createns.cpp b/device/generic/goldfish/wifi/createns/createns.cpp
deleted file mode 100644
index 66f6dd3..0000000
--- a/device/generic/goldfish/wifi/createns/createns.cpp
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "createns"
-#include <log/log.h>
-
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <sched.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/mount.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include <limits>
-#include <string>
-#include <vector>
-
-static const char kNamespacePath[] = "/data/vendor/var/run/netns/";
-static const char kProcNsNet[] = "/proc/self/ns/net";
-
-class Fd {
-public:
-    explicit Fd(int fd) : mFd(fd) { }
-    Fd(const Fd&) = delete;
-    ~Fd() {
-        if (mFd != -1) {
-            ::close(mFd);
-            mFd = -1;
-        }
-    }
-
-    int get() const { return mFd; }
-    Fd& operator=(const Fd&) = delete;
-private:
-    int mFd;
-};
-
-static void usage(const char* program) {
-    ALOGE("%s <namespace>", program);
-}
-
-static bool removeFile(const char* file) {
-    if (::unlink(file) == -1) {
-        ALOGE("Failed to unlink file '%s': %s", file, strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-static std::string getNamespacePath(const char* name) {
-    size_t len = strlen(name);
-    if (len == 0) {
-        ALOGE("Must provide a namespace argument that is not empty");
-        return std::string();
-    }
-
-    if (std::numeric_limits<size_t>::max() - sizeof(kNamespacePath) < len) {
-        // The argument is so big the resulting string can't fit in size_t
-        ALOGE("Namespace argument too long");
-        return std::string();
-    }
-
-    std::vector<char> nsPath(sizeof(kNamespacePath) + len);
-    size_t totalSize = strlcpy(nsPath.data(), kNamespacePath, nsPath.size());
-    if (totalSize >= nsPath.size()) {
-        // The resulting string had to be concatenated to fit, this is a logic
-        // error in the code above that determines the size of the data.
-        ALOGE("Could not create namespace path");
-        return std::string();
-    }
-    totalSize = strlcat(nsPath.data(), name, nsPath.size());
-    if (totalSize >= nsPath.size()) {
-        // The resulting string had to be concatenated to fit, this is a logic
-        // error in the code above that determines the size of the data.
-        ALOGE("Could not append to namespace path");
-        return std::string();
-    }
-    return nsPath.data();
-}
-
-static bool writeNamespacePid(const char* name, pid_t pid) {
-    std::string path = getNamespacePath(name);
-    if (path.empty()) {
-        return false;
-    }
-    path += ".pid";
-
-    Fd fd(::open(path.c_str(),
-                 O_CREAT | O_EXCL | O_WRONLY | O_CLOEXEC,
-                 S_IRUSR | S_IRGRP | S_IROTH));
-    if (fd.get() == -1) {
-        ALOGE("Unable to create file '%s': %s", path.c_str(), strerror(errno));
-        return false;
-    }
-
-    // In order to safely print a pid_t we use int64_t with a known format
-    // specifier. Ensure that a pid_t will fit in a pid_t. According to POSIX
-    // pid_t is signed.
-    static_assert(sizeof(pid_t) <= sizeof(int64_t),
-                  "pid_t is larger than int64_t");
-    char pidString[32];
-    int printed = snprintf(pidString,
-                           sizeof(pidString),
-                           "%" PRId64,
-                           static_cast<int64_t>(pid));
-    if (printed <= 0) {
-        ALOGE("Unabled to created PID string for writing");
-        removeFile(path.c_str());
-        return false;
-    }
-
-    const char* toPrint = pidString;
-    int remaining = printed;
-    for (;;) {
-        int result = ::write(fd.get(), toPrint, remaining);
-        if (result < 0) {
-            if (errno == EINTR) {
-                continue;
-            }
-            ALOGE("Unable to write pid to file %s: %s",
-                  path.c_str(), strerror(errno));
-            removeFile(path.c_str());
-            return false;
-        } else if (result < printed) {
-            remaining -= result;
-            toPrint += result;
-        } else {
-            break;
-        }
-    }
-    return true;
-}
-
-static pid_t daemonize(int fd) {
-    // This convoluted way of demonizing the process is described in
-    // man (7) daemon.
-
-    // (1) Close all files, we don't have any open files at this point
-    // (2) Reset all signal handlers to default, they already are
-    // (3) Reset the signal mask, we never changed it
-    // (4) Sanitize environment block, we didn't change the environment
-    // (5) Call fork
-    pid_t pid = ::fork();
-    if (pid != 0) {
-        // In the parent, nothing more to do
-        return pid;
-    }
-
-    // (6) Acquire a new session to detach from terminal
-    ::setsid();
-
-    // (7) Fork again to avoid the daemon being attached to a terminal again
-    pid = ::fork();
-    if (pid != 0) {
-        // (8) This is the first child, needs to call exit
-        exit(0);
-        return pid;
-    }
-    // (9) Connect /dev/null to stdin, stdout, stderr
-    ::close(STDIN_FILENO);
-    ::close(STDOUT_FILENO);
-    ::close(STDERR_FILENO);
-    // Since open will always reuse the lowest available fd and we have closed
-    // every single fd at this point we can just open them in the correct order.
-    if (::open("/dev/null", O_RDONLY) == -1) {
-        ALOGE("Unable to open /dev/null as stdin");
-    }
-    if (::open("/dev/null", O_WRONLY) == -1) {
-        ALOGE("Unable to open /dev/null as stdout");
-    }
-    if (::open("/dev/null", O_WRONLY) == -1) {
-        ALOGE("Unable to open /dev/null as stderr");
-    }
-    // (10) Reset umask to zero
-    ::umask(0);
-    // (11) Change directory to root (/)
-    if (::chdir("/") != 0) {
-        ALOGE("Failed to set working directory to root: %s", strerror(errno));
-    }
-    // (12) Write the pid of the daemon to a file, we're passing this to
-    // the process that starts the daemon to ensure that the pid file exists
-    // once that process exits. Atomicity is guaranteed by that write requiring
-    // that the pid file does not exist to begin with.
-    pid = ::getpid();
-    if (::write(fd, &pid, sizeof(pid)) != sizeof(pid)) {
-        ALOGE("Unable to write pid to pipe: %s", strerror(errno));
-        ::close(fd);
-        exit(1);
-    }
-    ::close(fd);
-    // (13) Drop privileges, doing this causes problems for execns when it's
-    // trying to open the proc/ns/net file of this process so we can't do that.
-    // (14) Notify the starting process that the daemon is running, this is done
-    // in step (12) above.
-    // (15) Exit starting process happens in main where it returns.
-    return 0;
-}
-
-int main(int argc, char* argv[]) {
-    if (argc != 2) {
-        usage(argv[0]);
-        return 1;
-    }
-    int fds[2];
-    if (::pipe2(fds, O_CLOEXEC) != 0) {
-        ALOGE("Failed to create pipe: %s", strerror(errno));
-        return 1;
-    }
-    Fd readPipe(fds[0]);
-    Fd writePipe(fds[1]);
-
-    if (::unshare(CLONE_NEWNET) != 0) {
-        ALOGE("Failed to create network namespace '%s': %s",
-              argv[1],
-              strerror(errno));
-        return 1;
-    }
-
-    std::string path = getNamespacePath(argv[1]);
-    if (path.empty()) {
-        return 1;
-    }
-    {
-        // Open and then immediately close the fd
-        Fd fd(::open(path.c_str(), O_CREAT | O_EXCL | O_RDONLY | O_CLOEXEC, 0));
-        if (fd.get() == -1) {
-            ALOGE("Failed to open file %s: %s", path.c_str(), strerror(errno));
-            return 1;
-        }
-    }
-    if (::mount(kProcNsNet, path.c_str(), nullptr, MS_BIND, nullptr) != 0) {
-        ALOGE("Failed to bind %s to %s: %s",
-              kProcNsNet,
-              path.c_str(),
-              strerror(errno));
-        // Clean up on failure
-        removeFile(path.c_str());
-        return 1;
-    }
-
-    // At this point we fork. This way we keep a process in the namespace alive
-    // without this command being blocking. This is valuable because it allows
-    // us to write the pid to a file before we exit. That way we can guarantee
-    // that after this command completes there is a pid to be read, there is no
-    // asynchronous behavior going on.
-    pid_t pid = daemonize(writePipe.get());
-    if (pid == 0) {
-        // In the child
-        for (;;) {
-            pause();
-        }
-    } else {
-        // In the parent, read the pid of the daemon from the pipe and write it
-        // to a file.
-        pid_t child = 0;
-        if (::read(readPipe.get(), &child, sizeof(child)) != sizeof(child)) {
-            ALOGE("Failed to read child PID from pipe: %s", strerror(errno));
-            return 1;
-        }
-        if (!writeNamespacePid(argv[1], child)) {
-            return 1;
-        }
-    }
-
-    return 0;
-}
-
diff --git a/device/generic/goldfish/wifi/execns/Android.mk b/device/generic/goldfish/wifi/execns/Android.mk
deleted file mode 100644
index e7d4c5e..0000000
--- a/device/generic/goldfish/wifi/execns/Android.mk
+++ /dev/null
@@ -1,17 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-	execns.cpp
-
-LOCAL_LDFLAGS := 
-LOCAL_SHARED_LIBRARIES := libcutils liblog
-LOCAL_PROPRIETARY_MODULE := true
-LOCAL_MODULE := execns
-
-LOCAL_MODULE_CLASS := EXECUTABLES
-
-include $(BUILD_EXECUTABLE)
-
-
diff --git a/device/generic/goldfish/wifi/execns/execns.cpp b/device/generic/goldfish/wifi/execns/execns.cpp
deleted file mode 100644
index 770d249..0000000
--- a/device/generic/goldfish/wifi/execns/execns.cpp
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "execns"
-#include <log/log.h>
-
-#include <errno.h>
-#include <fcntl.h>
-#include <grp.h>
-#include <pwd.h>
-#include <sched.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-
-#include <string>
-#include <vector>
-
-static bool isTerminal = false;
-// Print errors to stderr if running from a terminal, otherwise print to logcat
-// This is useful for debugging from a terminal
-#define LOGE(...) do { \
-    if (isTerminal) { \
-        fprintf(stderr, __VA_ARGS__); \
-        fprintf(stderr, "\n"); \
-    } else { \
-        ALOGE(__VA_ARGS__); \
-    } \
-} while (0)
-
-static const char kNetNsDir[] = "/data/vendor/var/run/netns";
-
-class FileDescriptor {
-public:
-    explicit FileDescriptor(int fd) : mFd(fd) { }
-    FileDescriptor(const FileDescriptor&) = delete;
-    ~FileDescriptor() {
-        if (mFd != -1) {
-            close(mFd);
-            mFd = -1;
-        }
-    }
-    int get() const { return mFd; }
-    FileDescriptor& operator=(const FileDescriptor&) = delete;
-private:
-    int mFd;
-};
-
-class File {
-public:
-    explicit File(FILE* file) : mFile(file) { }
-    File(const File&) = delete;
-    ~File() {
-        if (mFile) {
-            ::fclose(mFile);
-            mFile = nullptr;
-        }
-    }
-
-    FILE* get() const { return mFile; }
-    File& operator=(const File&) = delete;
-private:
-    FILE* mFile;
-};
-
-static void printUsage(const char* program) {
-    LOGE("%s [-u user] [-g group] <namespace> <program> [options...]", program);
-}
-
-static bool isNumericString(const char* str) {
-    while (isdigit(*str)) {
-        ++str;
-    }
-    return *str == '\0';
-}
-
-static std::string readNamespacePid(const char* ns) {
-    char nsPath[PATH_MAX];
-    snprintf(nsPath, sizeof(nsPath), "%s/%s.pid", kNetNsDir, ns);
-
-    File file(::fopen(nsPath, "r"));
-    if (file.get() == nullptr) {
-        LOGE("Unable to open file %s for namespace %s: %s",
-             nsPath, ns, strerror(errno));
-        return std::string();
-    }
-
-    char buffer[32];
-    size_t bytesRead = ::fread(buffer, 1, sizeof(buffer), file.get());
-    if (bytesRead < sizeof(buffer) && feof(file.get())) {
-        // Reached end-of-file, null-terminate
-        buffer[bytesRead] = '\0';
-        if (isNumericString(buffer)) {
-            // File is valid and contains a number, return it
-            return buffer;
-        }
-        LOGE("File %s does not contain a valid pid '%s'", nsPath, buffer);
-    } else if (ferror(file.get())) {
-        LOGE("Error reading from file %s: %s", nsPath, strerror(errno));
-    } else {
-        LOGE("Invalid contents of pid file %s", nsPath);
-    }
-    return std::string();
-}
-
-static bool setNetworkNamespace(const char* ns) {
-    // There is a file in the net namespace dir (/data/vendor/var/run/netns) with
-    // the name "<namespace>.pid". This file contains the pid of the createns
-    // process that created the namespace.
-    //
-    // To switch network namespace we're going to call setns which requires an
-    // open file descriptor to /proc/<pid>/ns/net where <pid> refers to a
-    // process already running in that namespace. So using the pid from the file
-    // above we can determine which path to use.
-    std::string pid = readNamespacePid(ns);
-    if (pid.empty()) {
-        return false;
-    }
-    char nsPath[PATH_MAX];
-    snprintf(nsPath, sizeof(nsPath), "/proc/%s/ns/net", pid.c_str());
-
-    FileDescriptor nsFd(open(nsPath, O_RDONLY | O_CLOEXEC));
-    if (nsFd.get() == -1) {
-        LOGE("Cannot open network namespace '%s' at '%s': %s",
-             ns, nsPath, strerror(errno));
-        return false;
-    }
-
-    if (setns(nsFd.get(), CLONE_NEWNET) == -1) {
-        LOGE("Cannot set network namespace '%s': %s",
-             ns, strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-static bool changeUser(const char* user) {
-    struct passwd* pwd = ::getpwnam(user);
-    if (pwd == nullptr) {
-        LOGE("Could not find user '%s'", user);
-        return false;
-    }
-
-    if (::setuid(pwd->pw_uid) != 0) {
-        LOGE("Cannot switch to user '%s': %s", user, strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-static bool changeGroup(const char* group) {
-    struct group* grp = ::getgrnam(group);
-    if (grp == nullptr) {
-        LOGE("Could not find group '%s'", group);
-        return false;
-    }
-
-    if (::setgid(grp->gr_gid) != 0) {
-        LOGE("Cannot switch to group '%s': %s", group, strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-// Append a formatted string to the end of |buffer|. The total size in |buffer|
-// is |size|, including any existing string data. The string to append is
-// specified by |fmt| and any additional arguments required by the format
-// string. If the function fails it returns -1, otherwise it returns the number
-// of characters printed (excluding the terminating NULL). On success the
-// string is always null-terminated.
-static int sncatf(char* buffer, size_t size, const char* fmt, ...) {
-    size_t len = strnlen(buffer, size);
-    if (len >= size) {
-        // The length exceeds the available size, if len == size then there is
-        // also a terminating null after len bytes which would then be outside
-        // the provided buffer.
-        return -1;
-    }
-
-    va_list args;
-    va_start(args, fmt);
-    int printed = vsnprintf(buffer + len, size - len, fmt, args);
-    buffer[size - 1] = '\0';
-    va_end(args);
-    return printed;
-}
-
-/**
- * Execute a given |command| with |argc| number of parameters that are located
- * in |argv|. The first parameter in |argv| is the command that should be run
- * followed by its arguments.
- */
-static int execCommand( int argc, char** argv) {
-    if (argc <= 0 || argv == nullptr || argv[0] == nullptr) {
-        LOGE("No command specified");
-        return 1;
-    }
-
-    std::vector<char*> arguments;
-    // Place all the arguments in the vector and the terminating null
-    arguments.insert(arguments.begin(), argv, argv + argc);
-    arguments.push_back(nullptr);
-
-    char buffer[4096];
-    if (execvp(argv[0], arguments.data()) == -1) {
-        // Save errno in case it gets changed by printing stuff.
-        int error = errno;
-        int printed = snprintf(buffer, sizeof(buffer),
-                               "Could not execute command '%s", argv[0]);
-        if (printed < 0) {
-            LOGE("Could not execute command: %s", strerror(error));
-            return error;
-        }
-        for (int i = 1; i < argc; ++i) {
-            // Be nice to the user and print quotes if there are spaces to
-            // indicate how we saw it. If there are already single quotes in
-            // there confusion will ensue.
-            if (strchr(argv[i], ' ')) {
-                sncatf(buffer, sizeof(buffer), " \"%s\"", argv[i]);
-            } else {
-                sncatf(buffer, sizeof(buffer), " %s", argv[i]);
-            }
-        }
-        sncatf(buffer, sizeof(buffer), "': %s", strerror(error));
-        LOGE("%s", buffer);
-        return error;
-    }
-    // execvp never returns unless it fails so this is just to return something.
-    return 0;
-}
-
-/**
- * Enter a given network namespace argv[1] and execute command argv[2] with
- * options argv[3..argc-1] in that namespace.
- */
-int main(int argc, char* argv[]) {
-    isTerminal = isatty(STDOUT_FILENO) != 0;
-
-    // Parse parameters
-    const char* user = nullptr;
-    const char* group = nullptr;
-    int nsArg = -1;
-    int execArg = -1;
-    for (int i = 1; i < argc; ++i) {
-        if (::strcmp(argv[i], "-u") == 0) {
-            if (user || i + 1 >= argc) {
-                LOGE("Missing argument to option -u");
-                return 1;
-            }
-            user = argv[++i];
-        } else if (::strcmp(argv[i], "-g") == 0) {
-            if (group || i + 1 >= argc) {
-                LOGE("Missing argument to option -g");
-                return 1;
-            }
-            group = argv[++i];
-        } else {
-            // Break on the first non-option and treat it as the namespace name
-            nsArg = i;
-            if (i + 1 < argc) {
-                execArg = i + 1;
-            }
-            break;
-        }
-    }
-
-    if (nsArg < 0 || execArg < 0) {
-        // Missing namespace and/or exec arguments
-        printUsage(argv[0]);
-        return 1;
-    }
-
-    // First set the new network namespace for this process
-    if (!setNetworkNamespace(argv[nsArg])) {
-        return 1;
-    }
-
-    // Changing namespace is the privileged operation, so now we can drop
-    // privileges by changing user and/or group if the user requested it. Note
-    // that it's important to change group first because it must be done as a
-    // privileged user. Otherwise an attacker might be able to restore group
-    // privileges by using the group ID that is saved by setgid when running
-    // as a non-privileged user.
-    if (group && !changeGroup(group)) {
-        return 1;
-    }
-
-    if (user && !changeUser(user)) {
-        return 1;
-    }
-
-    // Now run the command with all the remaining parameters
-    return execCommand(argc - execArg, &argv[execArg]);
-}
-
diff --git a/device/generic/goldfish/wifi/init.wifi.sh b/device/generic/goldfish/wifi/init.wifi.sh
deleted file mode 100755
index ff64e91..0000000
--- a/device/generic/goldfish/wifi/init.wifi.sh
+++ /dev/null
@@ -1,111 +0,0 @@
-#!/vendor/bin/sh
-
-# Do all the setup required for WiFi.
-# The kernel driver mac80211_hwsim has already created two virtual wifi devices
-# us. These devices are connected so that everything that's sent on one device
-# is recieved on the other and vice versa. This allows us to create a fake
-# WiFi network with an access point running inside the guest. Here is the setup
-# for that and the basics of how it works.
-#
-# Create a namespace named router and move eth0 to it. Create a virtual ethernet
-# pair of devices and move both one virtual ethernet interface and one virtual
-# wifi interface into the router namespace. Then set up NAT networking for those
-# interfaces so that traffic flowing through them reach eth0 and eventually the
-# host and the internet. The main network namespace will now only see the other
-# ends of those pipes and send traffic on them depending on if WiFi or radio is
-# used.  Finally run hostapd in the network namespace to create an access point
-# for the guest to connect to and dnsmasq to serve as a DHCP server for the WiFi
-# connection.
-#
-#          main namespace                     router namespace
-#       -------       ----------   |    ---------------
-#       | ril |<----->| radio0 |<--+--->| radio0-peer |<-------+
-#       -------       ----------   |    ---------------        |
-#                                  |            ^              |
-#                                  |            |              |
-#                                  |            v              v
-#                                  |      *************     --------
-#                                  |      * ipv6proxy *<--->| eth0 |<--+
-#                                  |      *************     --------   |
-#                                  |            ^              ^       |
-#                                  |            |              |       |
-#                                  |            v              |       |
-# ------------------   ---------   |        ---------          |       |
-# | wpa_supplicant |<->| wlan0 |<--+------->| wlan1 |<---------+       |
-# ------------------   ---------   |        ---------                  |
-#                                  |         ^     ^                   |
-#                                  |         |     |                   v
-#                                  |         v     v                --------
-#                                  | ***********  ***********       | host |
-#                                  | * hostapd *  * dnsmasq *       --------
-#                                  | ***********  ***********
-#
-
-NAMESPACE="router"
-rm -rf /data/vendor/var/run/netns/${NAMESPACE}
-rm -rf /data/vendor/var/run/netns/${NAMESPACE}.pid
-# Lower the MTU of the WiFi interface to prevent issues with packet injection.
-# The MTU of the WiFi monitor interface cannot be higher than 1500 but injection
-# requires extra space for injection headers which count against the MTU. So if
-# a 1500 byte payload needs to be injected it will fail because with the
-# additional headers the total amount of data will exceed 1500 bytes. This way
-# the payload is restricted to a smaller size that should leave room for the
-# injection headers.
-/system/bin/ip link set wlan0 mtu 1400
-
-createns ${NAMESPACE}
-
-# If this is a clean boot we need to copy the hostapd configuration file to the
-# data partition where netmgr can change it if needed. If it already exists we
-# need to preserve the existing settings.
-if [ ! -f /data/vendor/wifi/hostapd/hostapd.conf ]; then
-    cp /vendor/etc/simulated_hostapd.conf /data/vendor/wifi/hostapd/hostapd.conf
-    chown wifi:wifi /data/vendor/wifi/hostapd/hostapd.conf
-    chmod 660 /data/vendor/wifi/hostapd/hostapd.conf
-fi
-
-# createns will have created a file that contains the process id (pid) of a
-# process running in the network namespace. This pid is needed for some commands
-# to access the namespace.
-PID=$(cat /data/vendor/var/run/netns/${NAMESPACE}.pid)
-
-# Move the WiFi monitor interface to the other namespace and bring it up. This
-# is what we use for injecting WiFi frames from the outside world.
-/system/bin/ip link set hwsim0 netns ${PID}
-execns ${NAMESPACE} /system/bin/ip link set hwsim0 up
-
-# Start the network manager as soon as possible after the namespace is available.
-# This ensures that anything that follows is properly managed and monitored.
-setprop ctl.start netmgr
-
-/system/bin/ip link set eth0 netns ${PID}
-/system/bin/ip link add radio0 type veth peer name radio0-peer
-/system/bin/ip link set radio0-peer netns ${PID}
-# Enable privacy addresses for radio0, this is done by the framework for wlan0
-sysctl -wq net.ipv6.conf.radio0.use_tempaddr=2
-/system/bin/ip addr add 192.168.200.2/24 broadcast 192.168.200.255 dev radio0
-execns ${NAMESPACE} /system/bin/ip addr add 192.168.200.1/24 dev radio0-peer
-execns ${NAMESPACE} sysctl -wq net.ipv6.conf.all.forwarding=1
-execns ${NAMESPACE} /system/bin/ip link set radio0-peer up
-# Start the dhcp client for eth0 to acquire an address
-setprop ctl.start dhcpclient_rtr
-# Create iptables entries. -w will cause an indefinite wait for the exclusive
-# lock. Without this flag iptables can sporadically fail if something else is
-# modifying the iptables at the same time. -W indicates the number of micro-
-# seconds between each retry. The default is one second which seems like a long
-# time. Keep this short so we don't slow down startup too much.
-execns ${NAMESPACE} /system/bin/iptables -w -W 50000 -t nat -A POSTROUTING -s 192.168.232.0/21 -o eth0 -j MASQUERADE
-execns ${NAMESPACE} /system/bin/iptables -w -W 50000 -t nat -A POSTROUTING -s 192.168.200.0/24 -o eth0 -j MASQUERADE
-/vendor/bin/iw phy phy1 set netns $PID
-
-execns ${NAMESPACE} /system/bin/ip addr add 192.168.232.1/21 dev wlan1
-execns ${NAMESPACE} /system/bin/ip link set wlan1 mtu 1400
-execns ${NAMESPACE} /system/bin/ip link set wlan1 up
-# Start the IPv6 proxy that will enable use of IPv6 in the main namespace
-setprop ctl.start ipv6proxy
-execns ${NAMESPACE} sysctl -wq net.ipv4.ip_forward=1
-# Start hostapd, the access point software
-setprop ctl.start emu_hostapd
-# Start DHCP server for the wifi interface
-setprop ctl.start dhcpserver
-/system/bin/ip link set radio0 up
diff --git a/device/generic/goldfish/wifi/ipv6proxy/Android.mk b/device/generic/goldfish/wifi/ipv6proxy/Android.mk
deleted file mode 100644
index a1695d6..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/Android.mk
+++ /dev/null
@@ -1,24 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-	address.cpp \
-	interface.cpp \
-	log.cpp \
-	main.cpp \
-	namespace.cpp \
-	packet.cpp \
-	proxy.cpp \
-	router.cpp \
-	socket.cpp \
-
-
-LOCAL_CPPFLAGS += -Werror
-LOCAL_SHARED_LIBRARIES := libcutils liblog
-LOCAL_PROPRIETARY_MODULE := true
-LOCAL_MODULE := ipv6proxy
-
-LOCAL_MODULE_CLASS := EXECUTABLES
-
-include $(BUILD_EXECUTABLE)
diff --git a/device/generic/goldfish/wifi/ipv6proxy/address.cpp b/device/generic/goldfish/wifi/ipv6proxy/address.cpp
deleted file mode 100644
index def9c7b..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/address.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "address.h"
-
-#include <arpa/inet.h>
-#include <errno.h>
-#include <linux/if_ether.h>
-#include <linux/if_packet.h>
-#include <netdb.h>
-#include <net/if.h>
-#include <string.h>
-#include <sys/ioctl.h>
-
-#include "socket.h"
-
-std::string addrToStr(const struct in6_addr& addr) {
-    char buf[INET6_ADDRSTRLEN];
-    if (inet_ntop(AF_INET6, &addr, buf, sizeof(buf)) == nullptr) {
-        return "[unknown]";
-    }
-    return buf;
-}
-
-Address::Address() {
-    mStorage.reserve(sizeof(struct sockaddr_storage));
-}
-
-Address::Address(const struct sockaddr_nl& address)
-        : mStorage(sizeof(address)) {
-    memcpy(mStorage.data(), &address, sizeof(address));
-}
-Address::Address(const struct sockaddr_in6& address)
-        : mStorage(sizeof(address)) {
-    memcpy(mStorage.data(), &address, sizeof(address));
-}
-
-Address::Address(struct in6_addr address)
-        : mStorage(sizeof(struct sockaddr_in6)) {
-    auto sockaddr = reinterpret_cast<struct sockaddr_in6*>(mStorage.data());
-    sockaddr->sin6_family = AF_INET6;
-    sockaddr->sin6_addr = address;
-}
-
-void Address::reset() {
-    mStorage.resize(sizeof(struct sockaddr_storage));
-}
-
-Result Address::resolveInet(const std::string& address) {
-    struct addrinfo hints;
-    memset(&hints, 0, sizeof(hints));
-    hints.ai_family = AF_INET6;
-    hints.ai_socktype = SOCK_RAW;
-    struct addrinfo* addrinfo;
-    int res = ::getaddrinfo(address.c_str(), nullptr, &hints, &addrinfo);
-    if (res != 0) {
-        return Result::error(gai_strerror(res));
-    }
-    mStorage.resize(addrinfo->ai_addrlen);
-    memcpy(mStorage.data(), addrinfo->ai_addr, mStorage.size());
-    freeaddrinfo(addrinfo);
-
-    return Result::success();
-}
-
-Result Address::resolveEth(const std::string& interfaceName) {
-    mStorage.resize(sizeof(struct sockaddr_ll));
-    memset(mStorage.data(), 0, mStorage.size());
-    auto addr = reinterpret_cast<struct sockaddr_ll*>(mStorage.data());
-    addr->sll_family = AF_PACKET;
-    addr->sll_protocol = htons(ETH_P_IPV6);
-
-    unsigned int index = if_nametoindex(interfaceName.c_str());
-    if (index == 0) {
-        return Result::error(strerror(errno));
-    }
-    addr->sll_ifindex = index;
-
-    struct ifreq request;
-    memset(&request, 0, sizeof(request));
-    strncpy(request.ifr_name, interfaceName.c_str(), sizeof(request.ifr_name));
-    request.ifr_name[sizeof(request.ifr_name) - 1] = '\0';
-
-    Socket socket;
-    Result res = socket.open(AF_INET, SOCK_DGRAM, IPPROTO_IP);
-    if (!res) {
-        return res;
-    }
-    int status = ::ioctl(socket.get(), SIOCGIFHWADDR, &request);
-    if (status != 0) {
-        return Result::error(strerror(errno));
-    }
-    memcpy(addr->sll_addr, request.ifr_addr.sa_data, 6);
-
-    return Result::success();
-}
diff --git a/device/generic/goldfish/wifi/ipv6proxy/address.h b/device/generic/goldfish/wifi/ipv6proxy/address.h
deleted file mode 100644
index f9cec0b..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/address.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include "result.h"
-
-#include <linux/netlink.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-
-#include <string>
-#include <vector>
-
-// Convert an IPv6 address struct to a string for debugging purposes
-std::string addrToStr(const struct in6_addr& addr);
-
-// Represents any kind of address in a struct sockaddr.
-class Address {
-public:
-    Address();
-    explicit Address(const struct sockaddr_nl& address);
-    explicit Address(const struct sockaddr_in6& address);
-    explicit Address(struct in6_addr address);
-
-    template<typename T>
-    const T* get() const {
-        return reinterpret_cast<const T*>(mStorage.data());
-    }
-
-    template<typename T>
-    T* get() {
-        return reinterpret_cast<T*>(mStorage.data());
-    }
-
-    ssize_t size() const { return mStorage.size(); }
-
-    // Reset the address to be the max size possible for an address
-    void reset();
-
-    // Resolve |address| into an IPv6 address. |address| may be either a domain
-    // name or just a string containing a numeric address.
-    Result resolveInet(const std::string& address);
-    // Resolve |interfaceName| into a link layer address. This can be used to
-    // create a struct sockaddr_nl that can be used to listen on the given
-    // interface at the link layer.
-    Result resolveEth(const std::string& interfaceName);
-private:
-    std::vector<char> mStorage;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/interface.cpp b/device/generic/goldfish/wifi/ipv6proxy/interface.cpp
deleted file mode 100644
index e9597ab..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/interface.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "interface.h"
-
-#include <errno.h>
-#include <linux/if_ether.h>
-#include <net/if.h>
-#include <string.h>
-#include <sys/ioctl.h>
-
-#include "log.h"
-
-Interface::Interface(const std::string& name) : mName(name) {
-}
-
-bool Interface::init() {
-    // setAllMulti will set the ALLMULTI flag for the interface, this allows us
-    // to capture all the traffic needed to perform proxying.
-    return setAllMulti() &&
-           resolveAddresses() &&
-           configureIpSocket() &&
-           configureIcmpSocket();
-}
-
-bool Interface::setAllMulti() {
-    struct ifreq request;
-    memset(&request, 0, sizeof(request));
-    strncpy(request.ifr_name, mName.c_str(), sizeof(request.ifr_name));
-    request.ifr_name[sizeof(request.ifr_name) - 1] = '\0';
-
-    Socket socket;
-    Result res = socket.open(AF_INET, SOCK_DGRAM, IPPROTO_IP);
-    if (!res) {
-        loge("Failed to open IP socket for interface %s: %s\n",
-             mName.c_str(), strerror(errno));
-        return false;
-    }
-    int status = ::ioctl(socket.get(), SIOCGIFFLAGS, &request);
-    if (status != 0) {
-        loge("Failed to get interface flags for %s: %s\n",
-             mName.c_str(), strerror(errno));
-        return false;
-    }
-
-    if ((request.ifr_flags & IFF_ALLMULTI) != 0) {
-        // AllMulti is already enabled, nothing to do
-        return true;
-    }
-
-    request.ifr_flags |= IFF_ALLMULTI;
-
-    status = ::ioctl(socket.get(), SIOCSIFFLAGS, &request);
-    if (status != 0) {
-        loge("Failed to enable AllMulti flag for %s: %s\n",
-             mName.c_str(), strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-bool Interface::resolveAddresses() {
-    Result res = mLinkAddr.resolveEth(mName);
-    if (!res) {
-        loge("Unable to resolve interface %s: %s\n",
-             mName.c_str(), res.c_str());
-        return false;
-    }
-    mIndex = if_nametoindex(mName.c_str());
-    if (mIndex == 0) {
-        loge("Unable to get interface index for '%s': %s\n",
-             mName.c_str(), strerror(errno));
-        return false;
-    }
-    return true;
-}
-
-bool Interface::configureIcmpSocket() {
-    Result res = mIcmpSocket.open(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);
-    if (!res) {
-        loge("Error opening socket: %s\n", res.c_str());
-        return false;
-    }
-
-    // The ICMP messages we are going to send need a hop limit of 255 to be
-    // accepted.
-    res = mIcmpSocket.setMulticastHopLimit(255);
-    if (!res) {
-        loge("Error setting socket hop limit: %s\n", res.c_str());
-        return false;
-    }
-    res = mIcmpSocket.setUnicastHopLimit(255);
-    if (!res) {
-        loge("Error setting socket hop limit: %s\n", res.c_str());
-        return false;
-    }
-
-    // We only care about one specific interface
-    res = mIcmpSocket.setInterface(mName);
-    if (!res) {
-        loge("Error socket interface: %s\n", res.c_str());
-        return false;
-    }
-
-    // Make sure the socket allows transparent proxying, this allows sending of
-    // packets with a source address that is different from the interface.
-    res = mIcmpSocket.setTransparent(true);
-    if (!res) {
-        loge("Error socket interface: %s\n", res.c_str());
-        return false;
-    }
-
-    return true;
-}
-
-bool Interface::configureIpSocket() {
-    Result res = mIpSocket.open(AF_PACKET, SOCK_DGRAM, ETH_P_IPV6);
-    if (!res) {
-        loge("Error opening socket: %s\n", res.c_str());
-        return false;
-    }
-
-    res = mIpSocket.bind(mLinkAddr);
-    if (!res) {
-        loge("Error binding socket: %s\n", res.c_str());
-        return false;
-    }
-    return true;
-}
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/interface.h b/device/generic/goldfish/wifi/ipv6proxy/interface.h
deleted file mode 100644
index e6e5d78..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/interface.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include <stdint.h>
-#include <string>
-
-#include "address.h"
-#include "socket.h"
-
-// A class that contains the information used by the proxy that is specific to a
-// single interface. This includes the name and index of the interface as well
-// as the sockets used to send and receive data on the interface.
-//
-// The class also contains the functionality needed to initialized and configure
-// the interface, sockets and addresses.
-class Interface {
-public:
-    explicit Interface(const std::string& name);
-
-    bool init();
-
-    const std::string& name() const { return mName; }
-    uint32_t index() const { return mIndex; }
-    Socket& ipSocket() { return mIpSocket; }
-    Socket& icmpSocket() { return mIcmpSocket; }
-    const Address& linkAddr() const { return mLinkAddr; }
-
-private:
-    bool setAllMulti();
-    bool resolveAddresses();
-    bool configureIcmpSocket();
-    bool configureIpSocket();
-
-    std::string mName;
-    uint32_t mIndex;
-    Socket mIpSocket;
-    Socket mIcmpSocket;
-    Address mLinkAddr;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/log.cpp b/device/generic/goldfish/wifi/ipv6proxy/log.cpp
deleted file mode 100644
index a23b062..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/log.cpp
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "log.h"
-
-#ifndef ANDROID
-#include <stdarg.h>
-#ifdef USE_LOG_TIMESTAMPS
-#include <time.h>
-#endif  // USE_LOG_TIMESTAMPS
-
-static void vlogf(FILE* stream, const char* fmt, va_list args) {
-#ifdef USE_LOG_TIMESTAMPS
-    struct timespec ts;
-    struct tm localTime;
-    static bool newLine = true;
-    if (newLine && clock_gettime(CLOCK_REALTIME, &ts) == 0) {
-        time_t now = ts.tv_sec;
-        if (localtime_r(&now, &localTime)) {
-            char format[32];
-            char timestamp[1024];
-            snprintf(format, sizeof(format), "[%%T.%03lld] ", (long long)(ts.tv_nsec) / 1000000);
-            strftime(timestamp, sizeof(timestamp), format, &localTime);
-            fprintf(stream, "%s ", timestamp);
-        }
-    }
-    newLine = (fmt[strlen(fmt) - 1] == '\n');
-#endif  // USE_LOG_TIMESTAMPS
-    vfprintf(stream, fmt, args);
-}
-
-static void logf(FILE* stream, const char* fmt, ...) {
-    va_list args;
-    va_start(args, fmt);
-    vlogf(stream, fmt, args);
-    va_end(args);
-}
-
-void loge(const char* fmt, ...) {
-    va_list args;
-    va_start(args, fmt);
-    vlogf(stderr, fmt, args);
-    va_end(args);
-}
-
-void logd(const char* fmt, ...) {
-    va_list args;
-    va_start(args, fmt);
-    vlogf(stdout, fmt, args);
-    va_end(args);
-}
-#endif  // !ANDROID
diff --git a/device/generic/goldfish/wifi/ipv6proxy/log.h b/device/generic/goldfish/wifi/ipv6proxy/log.h
deleted file mode 100644
index 53e8935..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/log.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#ifdef ANDROID
-
-#define LOG_TAG "ipv6proxy"
-#include <log/log.h>
-
-#define loge(...) ALOGE(__VA_ARGS__)
-#define logd(...) ALOGD(__VA_ARGS__)
-
-#else
-#include <stdio.h>
-
-void loge(const char* fmt, ...);
-void logd(const char* fmt, ...);
-
-#endif
diff --git a/device/generic/goldfish/wifi/ipv6proxy/main.cpp b/device/generic/goldfish/wifi/ipv6proxy/main.cpp
deleted file mode 100644
index 91445ca..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/main.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <vector>
-
-#include <string.h>
-
-#include "log.h"
-#include "namespace.h"
-#include "proxy.h"
-
-void usage(const char* program) {
-    loge("Usage: %s -n [namespace|pid] -o <outer if> -i <inner ifs>\n",
-         program);
-    loge("  -o   Outer interface that connects to an existing IPv6 network.\n"
-         "  -i   Comma separated list of inner interfaces that would like\n"
-         "       to access the IPv6 network available on the outer interface.\n"
-         "  -n   Optional parameter that causes the proxy to run in the given\n"
-         "       network namespace. If a name is given instead of a PID the\n"
-         "       namespace is expected to be set up by iproute2 or with a\n"
-         "       similar approach where the namespace is linked in\n"
-         "       /var/run/netns. A PID is assumed if the argument is numeric.\n"
-         "       If providing a PID the same namespace that the PID is\n"
-         "       running in will be used. In this scenario there is no\n"
-         "       requirement for a file in /var/run/netns.\n"
-         "\n"
-         "       The proxy will ensure that router solicitations from inner\n"
-         "       interfaces are forwarded to the outer interface and that\n"
-         "       router advertisements from the outer interface are forwarded\n"
-         "       to the inner interfaces. In addition to this neighbor\n"
-         "       solicitations and advertisements will also be forwarded in a\n"
-         "       way that enables IPv6 connectivity and routes will be set up\n"
-         "       for source addresses on the inner interfaces so that replies\n"
-         "       can reach those sources as expected.\n"
-    );
-}
-
-static std::vector<const char*> splitString(char* str, char delimiter) {
-    std::vector<const char*> parts;
-    char* part = nullptr;
-    do {
-        parts.push_back(str);
-        part = strchr(str, delimiter);
-        if (part != nullptr) {
-            *part = '\0';
-            str = part + 1;
-        }
-    } while (part != nullptr);
-    return parts;
-}
-
-int main(int argc, char* argv[]) {
-    char* inner = nullptr;
-    const char* outer = nullptr;
-    const char* netNamespace = nullptr;
-    for (int i = 1; i < argc; ++i) {
-        if (strcmp(argv[i], "-o") == 0) {
-            outer = argv[++i];
-        } else if (strcmp(argv[i], "-i") == 0) {
-            inner = argv[++i];
-        } else if (strcmp(argv[i], "-h") == 0 ||
-                   strcmp(argv[i], "--help") == 0) {
-            usage(argv[0]);
-            return 1;
-        } else if (strcmp(argv[i], "-n") == 0) {
-            netNamespace = argv[++i];
-        } else {
-            loge("ERROR: Unknown argument '%s'\n\n", argv[i]);
-            usage(argv[0]);
-            return 1;
-        }
-    }
-    bool error = false;
-    if (inner == nullptr) {
-        loge("ERROR: Missing inner interface\n");
-        error = true;
-    }
-    if (outer == nullptr) {
-        loge("ERROR: Missing outer interface\n");
-        error = true;
-    }
-    if (netNamespace) {
-        if (!setNetworkNamespace(netNamespace)) {
-            error = true;
-        }
-    }
-    if (error) {
-        usage(argv[0]);
-        return 1;
-    }
-
-    std::vector<const char*> innerInterfaces = splitString(inner, ',');
-
-    Proxy proxy(outer, innerInterfaces.begin(), innerInterfaces.end());
-
-    return proxy.run();
-}
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/message.h b/device/generic/goldfish/wifi/ipv6proxy/message.h
deleted file mode 100644
index 9b35dae..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/message.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-class Message {
-public:
-
-    size_t size() const { return mSize; }
-    size_t capacity() const { return sizeof(mData); }
-    const char* data() const { return mData; }
-    char* data() { return mData; }
-
-    void setSize(size_t size) { mSize = size; }
-
-protected:
-    char mData[8192];
-    size_t mSize;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/namespace.cpp b/device/generic/goldfish/wifi/ipv6proxy/namespace.cpp
deleted file mode 100644
index 04841c2..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/namespace.cpp
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "namespace.h"
-
-#include <errno.h>
-#include <fcntl.h>
-#include <linux/limits.h>
-#include <sched.h>
-#include <stdio.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <unistd.h>
-
-#include "log.h"
-
-static const char kNetNsDir[] = "/data/vendor/var/run/netns";
-
-// Set the current namespace to that of the /proc/<pid>/ns/net provided in
-// |path|. This may be a link or mount point for that same file, anything that
-// when opened will be an fd usable by setns is fine.
-static bool setNamespaceFromPath(const char* path) {
-    int nsFd = open(path, O_RDONLY | O_CLOEXEC);
-    if (nsFd == -1) {
-        loge("Cannot open network namespace at '%s': %s\n",
-             path, strerror(errno));
-        return false;
-    }
-
-    if (setns(nsFd, CLONE_NEWNET) == -1) {
-        loge("Cannot set network namespace at '%s': %s\n",
-             path, strerror(errno));
-        close(nsFd);
-        return false;
-    }
-    close(nsFd);
-    return true;
-}
-
-bool setNetworkNamespace(const char* ns) {
-    // There is a file in the net namespace dir (usually /var/run/netns) with
-    // the same name as the namespace. This file is bound to /proc/<pid>/ns/net
-    // by the 'ip' command when the namespace is created. This allows us to
-    // access the file of a process running in that network namespace without
-    // knowing its pid, knowing the namespace name is enough.
-    //
-    // We are going to call setns which requires a file descriptor to that proc
-    // file in /proc/<pid>/net. The process has to already be running in that
-    // namespace. Since the file in the net namespace dir has been bound to
-    // such a file already we just have to open /var/run/netns/<namespace> and
-    // we have the required file descriptor.
-    char nsPath[PATH_MAX];
-    snprintf(nsPath, sizeof(nsPath), "%s/%s", kNetNsDir, ns);
-    return setNamespaceFromPath(nsPath);
-}
-
-bool setNetworkNamespace(pid_t pid) {
-    // If we know the pid we can create the path to the /proc file right away
-    // and use that when we call setns.
-    char nsPath[PATH_MAX];
-    static_assert(sizeof(pid_t) <= sizeof(unsigned long long),
-                  "Cast requires sizeof(pid_t) <= sizeof(unsigned long long)");
-    snprintf(nsPath, sizeof(nsPath), "/proc/%llu/ns/net/",
-             static_cast<unsigned long long>(pid));
-    return setNamespaceFromPath(nsPath);
-}
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/namespace.h b/device/generic/goldfish/wifi/ipv6proxy/namespace.h
deleted file mode 100644
index 8a70374..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/namespace.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include <sys/types.h>
-
-// Move the process into the namespace |ns|
-bool setNetworkNamespace(const char* ns);
-
-// Move the process into the same namespace as the process |pid| is in.
-bool setNetworkNamespace(pid_t pid);
diff --git a/device/generic/goldfish/wifi/ipv6proxy/packet.cpp b/device/generic/goldfish/wifi/ipv6proxy/packet.cpp
deleted file mode 100644
index fa15a75..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/packet.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "packet.h"
-
-#include "address.h"
-
-Packet::Packet(Message& message)
-    : mMessage(message),
-      mType(Type::Other),
-      mIp(nullptr),
-      mIcmp(nullptr),
-      mFirstOpt(nullptr) {
-    if (message.size() < sizeof(ip6_hdr) + sizeof(icmp6_hdr)) {
-        mType = Type::Other;
-        return;
-    }
-    mIp = reinterpret_cast<const ip6_hdr*>(message.data());
-    uint8_t version = (mIp->ip6_vfc & 0xF0) >> 4;
-    if (version != 6 || mIp->ip6_nxt != IPPROTO_ICMPV6) {
-        mType = Type::Other;
-        return;
-    }
-
-    size_t size = message.size() - sizeof(ip6_hdr);
-    char* data = message.data() + sizeof(ip6_hdr);
-    mIcmp = reinterpret_cast<const icmp6_hdr*>(data);
-    if (mIcmp->icmp6_code != 0) {
-        // All messages we care about have a code of zero
-        mType = Type::Other;
-        return;
-    }
-
-    size_t headerSize = 0;
-    switch (mIcmp->icmp6_type) {
-    case ND_ROUTER_SOLICIT:
-        headerSize = sizeof(nd_router_solicit);
-        mType = Type::RouterSolicitation;
-        break;
-    case ND_ROUTER_ADVERT:
-        headerSize = sizeof(nd_router_advert);
-        mType = Type::RouterAdvertisement;
-        break;
-    case ND_NEIGHBOR_SOLICIT:
-        headerSize = sizeof(nd_neighbor_solicit);
-        mType = Type::NeighborSolicitation;
-        break;
-    case ND_NEIGHBOR_ADVERT:
-        headerSize = sizeof(nd_neighbor_advert);
-        mType = Type::NeighborAdvertisement;
-        break;
-    default:
-        mType = Type::Other;
-        return;
-    }
-    if (size < headerSize) {
-        mType = Type::Other;
-        return;
-    }
-
-    // We might have options
-    char* options = data + headerSize;
-    if (options + sizeof(nd_opt_hdr) < data + size) {
-        nd_opt_hdr* option = reinterpret_cast<nd_opt_hdr*>(options);
-        // Option length is in units of 8 bytes, multiply by 8 to get bytes
-        if (options + option->nd_opt_len * 8u <= data + size) {
-            mFirstOpt = option;
-        }
-    }
-}
-
-std::string Packet::description() const {
-    char buffer[256];
-    switch (mType) {
-        case Type::NeighborSolicitation: {
-                auto ns = reinterpret_cast<const nd_neighbor_solicit*>(icmp());
-                snprintf(buffer, sizeof(buffer), "Neighbor Solicitation for %s",
-                         addrToStr(ns->nd_ns_target).c_str());
-                return buffer;
-            }
-        case Type::NeighborAdvertisement: {
-                auto na = reinterpret_cast<const nd_neighbor_advert*>(icmp());
-                snprintf(buffer, sizeof(buffer),
-                         "Neighbor Advertisement for %s",
-                         addrToStr(na->nd_na_target).c_str());
-                return buffer;
-            }
-        case Type::RouterSolicitation:
-            return "Router Solicitation";
-        case Type::RouterAdvertisement:
-            return "Router Advertisement";
-        default:
-            break;
-    }
-    return "[unknown]";
-}
-
-nd_opt_hdr* Packet::firstOpt() {
-    return mFirstOpt;
-}
-
-nd_opt_hdr* Packet::nextOpt(nd_opt_hdr* currentHeader) {
-    char* end = mMessage.data() + mMessage.size();
-    char* current = reinterpret_cast<char*>(currentHeader);
-    if (currentHeader < mFirstOpt || current >= end) {
-        // The provided header does not belong to this packet info.
-        return nullptr;
-    }
-    char* next = current + currentHeader->nd_opt_len * 8u;
-    if (next >= end) {
-        // The next header points passed the message data
-        return nullptr;
-    }
-    nd_opt_hdr* nextHeader = reinterpret_cast<nd_opt_hdr*>(next);
-    if (next + nextHeader->nd_opt_len * 8u > end) {
-        // The next option extends beyond the message data
-        return nullptr;
-    }
-    return nextHeader;
-}
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/packet.h b/device/generic/goldfish/wifi/ipv6proxy/packet.h
deleted file mode 100644
index 49e69d4..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/packet.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include <netinet/icmp6.h>
-#include <netinet/ip6.h>
-
-#include <string>
-#include <vector>
-
-#include "message.h"
-
-class Packet {
-public:
-    enum class Type {
-        NeighborSolicitation,
-        NeighborAdvertisement,
-        RouterSolicitation,
-        RouterAdvertisement,
-        Other
-    };
-
-    explicit Packet(Message& message);
-
-    // Create a string that can be used for debug purposes to describe
-    // what type of packet and potentially its target for certain types.
-    std::string description() const;
-
-    // Full size including IP header
-    size_t fullSize() const {
-        return mMessage.size();
-    }
-    // Remaining size including ICMPv6 header but excluding IP header
-    size_t icmpSize() const {
-        return mMessage.size() - sizeof(ip6_hdr);
-    }
-
-    Type type() const {
-        return mType;
-    }
-    const ip6_hdr* ip() const {
-        return mIp;
-    }
-    const icmp6_hdr* icmp() const {
-        return mIcmp;
-    }
-
-    nd_opt_hdr* firstOpt();
-    nd_opt_hdr* nextOpt(nd_opt_hdr* currentHeader);
-
-private:
-    Message& mMessage;
-    Type mType;
-
-    const ip6_hdr* mIp;
-    const icmp6_hdr* mIcmp;
-    nd_opt_hdr* mFirstOpt;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/proxy.cpp b/device/generic/goldfish/wifi/ipv6proxy/proxy.cpp
deleted file mode 100644
index cb19ff7..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/proxy.cpp
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "proxy.h"
-
-#include <arpa/inet.h>
-#include <errno.h>
-#include <linux/if_packet.h>
-#include <poll.h>
-#include <signal.h>
-
-#include <cutils/properties.h>
-
-#include "log.h"
-#include "message.h"
-#include "packet.h"
-#include "result.h"
-
-// The prefix length for an address of a single unique node
-static const uint8_t kNodePrefixLength = 128;
-static const size_t kLinkAddressSize = 6;
-static const size_t kRecursiveDnsOptHeaderSize = 8;
-
-// Rewrite the link address of a neighbor discovery option to the link address
-// of |interface|. This can be either a source or target link address as
-// specified by |optionType|. The valid values are ND_OPT_TARGET_LINKADDR and
-// ND_OPT_SOURCE_LINKADDR. This will modify the message data inside |packet|.
-static void rewriteLinkAddressOption(Packet& packet,
-                                     const Interface& interface,
-                                     int optionType) {
-    for (nd_opt_hdr* opt = packet.firstOpt(); opt; opt = packet.nextOpt(opt)) {
-        if (opt->nd_opt_type == optionType) {
-            auto src = interface.linkAddr().get<sockaddr_ll>();
-            auto dest = reinterpret_cast<char*>(opt) + sizeof(nd_opt_hdr);
-            memcpy(dest, src->sll_addr, kLinkAddressSize);
-        }
-    }
-}
-
-static void extractRecursiveDnsServers(Packet& packet) {
-    for (nd_opt_hdr* opt = packet.firstOpt(); opt; opt = packet.nextOpt(opt)) {
-        if (opt->nd_opt_type != 25 || opt->nd_opt_len < 1) {
-            // Not a RNDSS option, skip it
-            continue;
-        }
-        size_t numEntries = (opt->nd_opt_len - 1) / 2;
-        //Found number of entries, dump  each address
-        const char* option = reinterpret_cast<const char*>(opt);
-        option += kRecursiveDnsOptHeaderSize;
-        auto dnsServers = reinterpret_cast<const struct in6_addr*>(option);
-
-        std::vector<std::string> validServers;
-        for (size_t i = 0; i < numEntries; ++i) {
-            char buffer[INET6_ADDRSTRLEN];
-            if (inet_ntop(AF_INET6, &dnsServers[i], buffer, sizeof(buffer))) {
-                validServers.push_back(buffer);
-            } else {
-                loge("Failed to convert RDNSS to string\n");
-            }
-        }
-
-        auto server = validServers.begin();
-        char propName[PROP_NAME_MAX];
-        char propValue[PROP_VALUE_MAX];
-        for (int i = 1; i <= 4; ++i) {
-            snprintf(propName, sizeof(propName), "net.eth0.ipv6dns%d", i);
-            if (server != validServers.end()) {
-                property_set(propName, server->c_str());
-                ++server;
-            } else {
-                // Clear the property if it's no longer a valid server, don't
-                // want to leave old servers around
-                property_set(propName, "");
-            }
-        }
-    }
-}
-
-int Proxy::run() {
-    sigset_t blockMask, originalMask;
-    int status = ::sigfillset(&blockMask);
-    if (status != 0) {
-        loge("Unable to fill signal set: %s\n", strerror(errno));
-        return 1;
-    }
-    status = ::sigprocmask(SIG_SETMASK, &blockMask, &originalMask);
-    if (status != 0) {
-        loge("Unable to set signal mask: %s\n", strerror(errno));
-        return 1;
-    }
-    // Init outer interface and router
-    if (!mOuterIf.init() || !mRouter.init()) {
-        return 1;
-    }
-    // Init all inner interfaces
-    for (size_t i = 0; i < mInnerIfs.size(); ++i) {
-        if (!mInnerIfs[i].init()) {
-            return 1;
-        }
-    }
-
-    // Create list of FDs to poll, we're only looking for input (POLLIN)
-    std::vector<pollfd> fds(mInnerIfs.size() + 1);
-    fds[0].fd = mOuterIf.ipSocket().get();
-    fds[0].events = POLLIN;
-    for (size_t i = 0; i < mInnerIfs.size(); ++i) {
-        fds[i + 1].fd = mInnerIfs[i].ipSocket().get();
-        fds[i + 1].events = POLLIN;
-    }
-
-    Message message;
-    while (status >= 0) {
-        status = ::ppoll(fds.data(), fds.size(), nullptr, &originalMask);
-        if (status > 0) {
-            // Something available to read
-            for (const struct pollfd& fd : fds) {
-                if (receiveIfPossible(fd, mOuterIf.ipSocket(), &message)) {
-                    // Received a message on the outer interface
-                    handleOuterMessage(message);
-                } else {
-                    for (auto& inner : mInnerIfs) {
-                        if (receiveIfPossible(fd, inner.ipSocket(), &message)) {
-                            // Received a message on the inner interface
-                            handleInnerMessage(inner, message);
-                        }
-                    }
-                }
-            }
-        }
-    }
-    loge("Polling failed: %s\n", strerror(errno));
-    return 1;
-}
-
-bool Proxy::receiveIfPossible(const pollfd& fd,
-                              Socket& socket,
-                              Message* message) {
-    // Check if it's actually the socket we're interested in
-    if (fd.fd != socket.get()) {
-        return false;
-    }
-    // Check if there is something to read on this socket
-    if ((fd.revents & POLLIN) == 0) {
-        return false;
-    }
-
-    // Receive the message and place the data in the message parameter
-    Result res = socket.receive(message);
-    if (!res) {
-        loge("Error receiving on socket: %s\n", res.c_str());
-        return false;
-    }
-    return true;
-}
-
-void Proxy::handleOuterMessage(Message& message) {
-    Packet packet(message);
-    uint32_t options = kForwardOnly;
-    switch (packet.type()) {
-        case Packet::Type::RouterAdvertisement:
-            extractRecursiveDnsServers(packet);
-            options = kRewriteSourceLink | kSetDefaultGateway;
-            break;
-        case Packet::Type::NeighborSolicitation:
-            options = kSpoofSource;
-            break;
-        case Packet::Type::NeighborAdvertisement:
-            options = kRewriteTargetLink;
-            break;
-        default:
-            return;
-    }
-    for (auto& inner : mInnerIfs) {
-        forward(mOuterIf, inner, packet, options);
-    }
-}
-
-void Proxy::handleInnerMessage(const Interface& inner, Message& message) {
-    Packet packet(message);
-    uint32_t options = kForwardOnly;
-    switch (packet.type()) {
-        case Packet::Type::RouterSolicitation:
-            options = kSpoofSource;
-            break;
-        case Packet::Type::NeighborSolicitation:
-            options = kSpoofSource | kAddRoute;
-            break;
-        case Packet::Type::NeighborAdvertisement:
-            options = kRewriteTargetLink | kSpoofSource | kAddRoute;
-            break;
-        default:
-            return;
-    }
-    forward(inner, mOuterIf, packet, options);
-}
-
-void Proxy::forward(const Interface& from,
-                    Interface& to,
-                    Packet& packet,
-                    uint32_t options) {
-    if (mLogDebug) {
-        logd("Forwarding %s from %s/%s to %s/%s\n",
-             packet.description().c_str(),
-             from.name().c_str(), addrToStr(packet.ip()->ip6_src).c_str(),
-             to.name().c_str(), addrToStr(packet.ip()->ip6_dst).c_str());
-    }
-
-    if (options & kRewriteTargetLink) {
-        rewriteLinkAddressOption(packet, to, ND_OPT_TARGET_LINKADDR);
-    }
-    if (options & kRewriteSourceLink) {
-        rewriteLinkAddressOption(packet, to, ND_OPT_SOURCE_LINKADDR);
-    }
-
-    Result res = Result::success();
-    if (options & kSpoofSource) {
-        // Spoof the source of the packet so that it appears to originate from
-        // the same source that we see.
-        res = to.icmpSocket().sendFrom(packet.ip()->ip6_src,
-                                       packet.ip()->ip6_dst,
-                                       packet.icmp(),
-                                       packet.icmpSize());
-    } else {
-        res = to.icmpSocket().sendTo(packet.ip()->ip6_dst,
-                                     packet.icmp(),
-                                     packet.icmpSize());
-    }
-    if (!res) {
-        loge("Failed to forward %s from %s to %s: %s\n",
-             packet.description().c_str(),
-             from.name().c_str(), to.name().c_str(),
-             res.c_str());
-    }
-
-    if (options & kAddRoute) {
-        mRouter.addRoute(packet.ip()->ip6_src, kNodePrefixLength, from.index());
-    }
-    if (packet.type() == Packet::Type::RouterAdvertisement &&
-        options & kSetDefaultGateway) {
-        // Set the default gateway from this router advertisement. This is
-        // needed so that packets that are forwarded as a result of proxying
-        // actually have somewhere to go.
-        if (!mRouter.setDefaultGateway(packet.ip()->ip6_src, from.index())) {
-            loge("Failed to set default gateway %s\n",
-                 addrToStr(packet.ip()->ip6_src).c_str());
-        }
-    }
-}
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/proxy.h b/device/generic/goldfish/wifi/ipv6proxy/proxy.h
deleted file mode 100644
index 5179137..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/proxy.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include <string>
-#include <vector>
-
-#include "interface.h"
-#include "router.h"
-
-struct pollfd;
-class Message;
-class Packet;
-class Socket;
-
-class Proxy {
-public:
-    template<typename Iter>
-    Proxy(std::string outerInterfaceName,
-          Iter innerInterfacesBegin, Iter innerInterfacesEnd)
-        : mOuterIf(outerInterfaceName),
-          mLogDebug(false) {
-
-        for (Iter i = innerInterfacesBegin; i != innerInterfacesEnd; ++i) {
-            mInnerIfs.emplace_back(*i);
-        }
-    }
-
-    int run();
-
-private:
-    enum ForwardOpt {
-        kForwardOnly = 0,
-        kRewriteTargetLink = (1 << 0),
-        kRewriteSourceLink = (1 << 1),
-        kSpoofSource = (1 << 2),
-        kAddRoute = (1 << 3),
-        kSetDefaultGateway = (1 << 4)
-    };
-
-    bool receiveIfPossible(const pollfd&, Socket& socket, Message* message);
-
-    void handleOuterMessage(Message& message);
-    void handleInnerMessage(const Interface& inner, Message& message);
-    void forward(const Interface& from, Interface& to,
-                 Packet& packet, uint32_t options);
-
-    std::vector<Interface> mInnerIfs;
-    Interface mOuterIf;
-
-    Router mRouter;
-    bool mLogDebug;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/result.h b/device/generic/goldfish/wifi/ipv6proxy/result.h
deleted file mode 100644
index 5cd2b03..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/result.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-class Result {
-public:
-    static Result success() {
-        return Result(true);
-    }
-    // Construct a result indicating an error. NOTE: the data in |message| will
-    // NOT be copied. It must be kept alive for as long as its intended to be
-    // used. This way the object is kept light-weight.
-    static Result error(const char* message) {
-        return Result(message);
-    }
-
-    bool isSuccess() const { return mSuccess; }
-    bool operator!() const { return !mSuccess; }
-
-    const char* c_str() const { return mMessage; }
-private:
-    explicit Result(bool success) : mSuccess(success) { }
-    explicit Result(const char* message)
-        : mMessage(message), mSuccess(false) {
-    }
-    const char* mMessage;
-    bool mSuccess;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/router.cpp b/device/generic/goldfish/wifi/ipv6proxy/router.cpp
deleted file mode 100644
index be505c9..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/router.cpp
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "router.h"
-
-#include <linux/rtnetlink.h>
-#include <stddef.h>
-#include <string.h>
-
-#include "address.h"
-#include "log.h"
-
-template<class Request>
-static void addRouterAttribute(Request& r,
-                               int type,
-                               const void* data,
-                               size_t size) {
-    // Calculate the offset into the character buffer where the RTA data lives
-    // We use offsetof on the buffer to get it. This avoids undefined behavior
-    // by casting the buffer (which is safe because it's char) instead of the
-    // Request struct.(which is undefined because of aliasing)
-    size_t offset = NLMSG_ALIGN(r.hdr.nlmsg_len) - offsetof(Request, buf);
-    auto attr = reinterpret_cast<struct rtattr*>(r.buf + offset);
-    attr->rta_type = type;
-    attr->rta_len = RTA_LENGTH(size);
-    memcpy(RTA_DATA(attr), data, size);
-
-    // Update the message length to include the router attribute.
-    r.hdr.nlmsg_len = NLMSG_ALIGN(r.hdr.nlmsg_len) + RTA_ALIGN(attr->rta_len);
-}
-
-bool Router::init() {
-    // Create a netlink socket to the router
-    Result res = mSocket.open(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
-    if (!res) {
-        loge("Unable to open netlink socket: %s\n", res.c_str());
-        return false;
-    }
-    return true;
-}
-
-bool Router::addNeighbor(const struct in6_addr& address,
-                         unsigned int interfaceIndex) {
-    struct Request {
-        struct nlmsghdr hdr;
-        struct ndmsg msg;
-        char buf[256];
-    } request;
-
-    memset(&request, 0, sizeof(request));
-
-    unsigned short msgLen = NLMSG_LENGTH(sizeof(request.msg));
-    // Set up a request to create a new neighbor
-    request.hdr.nlmsg_len = msgLen;
-    request.hdr.nlmsg_type = RTM_NEWNEIGH;
-    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
-
-    // The neighbor is a permanent IPv6 proxy
-    request.msg.ndm_family = AF_INET6;
-    request.msg.ndm_state = NUD_PERMANENT;
-    request.msg.ndm_flags = NTF_PROXY;
-    request.msg.ndm_ifindex = interfaceIndex;
-
-    addRouterAttribute(request, NDA_DST, &address, sizeof(address));
-
-    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
-}
-
-bool Router::addRoute(const struct in6_addr& address,
-                      uint8_t bits,
-                      uint32_t ifaceIndex) {
-    struct Request {
-        struct nlmsghdr hdr;
-        struct rtmsg msg;
-        char buf[256];
-    } request;
-
-    memset(&request, 0, sizeof(request));
-
-    // Set up a request to create a new route
-    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
-    request.hdr.nlmsg_type = RTM_NEWROUTE;
-    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
-
-    request.msg.rtm_family = AF_INET6;
-    request.msg.rtm_dst_len = bits;
-    request.msg.rtm_table = RT_TABLE_MAIN;
-    request.msg.rtm_protocol = RTPROT_RA;
-    request.msg.rtm_scope = RT_SCOPE_UNIVERSE;
-    request.msg.rtm_type = RTN_UNICAST;
-
-    addRouterAttribute(request, RTA_DST, &address, sizeof(address));
-    addRouterAttribute(request, RTA_OIF, &ifaceIndex, sizeof(ifaceIndex));
-
-    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
-}
-
-bool Router::setDefaultGateway(const struct in6_addr& address,
-                               unsigned int ifaceIndex) {
-    struct Request {
-        struct nlmsghdr hdr;
-        struct rtmsg msg;
-        char buf[256];
-    } request;
-
-    memset(&request, 0, sizeof(request));
-
-    // Set up a request to create a new route
-    request.hdr.nlmsg_len = NLMSG_LENGTH(sizeof(request.msg));
-    request.hdr.nlmsg_type = RTM_NEWROUTE;
-    request.hdr.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE;
-
-    request.msg.rtm_family = AF_INET6;
-    request.msg.rtm_dst_len = 0;
-    request.msg.rtm_src_len = 0;
-    request.msg.rtm_table = RT_TABLE_MAIN;
-    request.msg.rtm_protocol = RTPROT_RA;
-    request.msg.rtm_scope = RT_SCOPE_UNIVERSE;
-    request.msg.rtm_type = RTN_UNICAST;
-
-    struct in6_addr anyAddress;
-    memset(&anyAddress, 0, sizeof(anyAddress));
-    addRouterAttribute(request, RTA_GATEWAY, &address, sizeof(address));
-    addRouterAttribute(request, RTA_OIF, &ifaceIndex, sizeof(ifaceIndex));
-    addRouterAttribute(request, RTA_SRC, &anyAddress, sizeof(anyAddress));
-
-    return sendNetlinkMessage(&request, request.hdr.nlmsg_len);
-}
-
-bool Router::sendNetlinkMessage(const void* data, size_t size) {
-    struct sockaddr_nl netlinkAddress;
-    memset(&netlinkAddress, 0, sizeof(netlinkAddress));
-    netlinkAddress.nl_family = AF_NETLINK;
-    Result res = mSocket.sendTo(netlinkAddress, data, size);
-    if (!res) {
-        loge("Unable to send on netlink socket: %s\n", res.c_str());
-        return false;
-    }
-    return true;
-}
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/router.h b/device/generic/goldfish/wifi/ipv6proxy/router.h
deleted file mode 100644
index 66e896f..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/router.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include <stdint.h>
-
-#include <netinet/in.h>
-
-#include "socket.h"
-
-class Router {
-public:
-    // Initialize the router, this has to be called before any other methods can
-    // be called. It only needs to be called once.
-    bool init();
-
-    // Indicate that |address| is a neighbor to this node and that it is
-    // accessible on the interface with index |interfaceIndex|.
-    bool addNeighbor(const struct in6_addr& address, uint32_t interfaceIndex);
-
-    // Add a route to |address|/|bits| on interface |interfaceIndex|. The
-    // |bits| parameter indicates the bitmask of the address, for example in
-    // the routing entry 2001:db8::/32 the |bits| parameter would be 32.
-    bool addRoute(const struct in6_addr& address,
-                  uint8_t bits,
-                  uint32_t interfaceIndex);
-
-    // Set the default gateway route to |address| on interface with index
-    // |interfaceIndex|. Overwrites any existing default gateway with the same
-    // address.
-    bool setDefaultGateway(const struct in6_addr& address,
-                           unsigned int interfaceIndex);
-private:
-    bool sendNetlinkMessage(const void* data, size_t size);
-
-    // Netlink socket for setting up neighbors and routes
-    Socket mSocket;
-};
-
diff --git a/device/generic/goldfish/wifi/ipv6proxy/socket.cpp b/device/generic/goldfish/wifi/ipv6proxy/socket.cpp
deleted file mode 100644
index 3b67816..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/socket.cpp
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "socket.h"
-
-#include <errno.h>
-#include <string.h>
-
-#include <linux/in6.h>
-#include <net/ethernet.h>
-#include <netinet/in.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <unistd.h>
-
-#include "address.h"
-#include "message.h"
-
-Socket::Socket() : mState(State::New), mSocket(-1) {
-}
-
-Socket::Socket(Socket&& other) noexcept : mState(other.mState), mSocket(other.mSocket) {
-    other.mSocket = -1;
-    other.mState = State::Moved;
-}
-
-Socket::~Socket() {
-    if (mSocket != -1) {
-        close(mSocket);
-        mSocket = -1;
-    }
-    mState = State::Destructed;
-}
-
-Socket& Socket::operator=(Socket&& other) noexcept {
-    if (mSocket != -1) {
-        close(mSocket);
-    }
-    mSocket = other.mSocket;
-    mState = other.mState;
-    other.mSocket = -1;
-    other.mState = State::Moved;
-
-    return *this;
-}
-
-Result Socket::open(int domain, int type, int protocol) {
-    if (mState != State::New) {
-        return Result::error("open called on socket in invalid state");
-    }
-    mSocket = ::socket(domain, type | SOCK_CLOEXEC, protocol);
-    if (mSocket == -1) {
-        return Result::error(strerror(errno));
-    }
-    mState = State::Open;
-    return Result::success();
-}
-
-Result Socket::setInterface(const std::string& interface) {
-    if (mState != State::Open) {
-        return Result::error("attempting to set option in invalid state");
-    }
-    int res = ::setsockopt(mSocket, SOL_SOCKET, SO_BINDTODEVICE,
-                           interface.c_str(), interface.size());
-
-    return res == -1 ? Result::error(strerror(errno)) : Result::success();
-}
-
-Result Socket::setMulticastHopLimit(int hopLimit) {
-    if (mState != State::Open) {
-        return Result::error("attempting to set option in invalid state");
-    }
-    int res = ::setsockopt(mSocket, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,
-                           &hopLimit, sizeof(hopLimit));
-
-    return res == -1 ? Result::error(strerror(errno)) : Result::success();
-}
-
-Result Socket::setUnicastHopLimit(int hopLimit) {
-    if (mState != State::Open) {
-        return Result::error("attempting to set option in invalid state");
-    }
-    int res = ::setsockopt(mSocket, IPPROTO_IPV6, IPV6_UNICAST_HOPS,
-                           &hopLimit, sizeof(hopLimit));
-
-    return res == -1 ? Result::error(strerror(errno)) : Result::success();
-}
-
-Result Socket::setTransparent(bool transparent) {
-    if (mState != State::Open) {
-        return Result::error("attempting to set option in invalid state");
-    }
-    int v = transparent ? 1 : 0;
-    int res = ::setsockopt(mSocket, IPPROTO_IPV6, IPV6_TRANSPARENT,
-                           &v, sizeof(v));
-
-    return res == -1 ? Result::error(strerror(errno)) : Result::success();
-}
-
-Result Socket::bind(const Address& address) {
-    if (mState != State::Open) {
-        return Result::error("bind called on socket in invalid state");
-    }
-
-    int res = ::bind(mSocket, address.get<sockaddr>(), address.size());
-    if (res == -1) {
-        return Result::error(strerror(errno));
-    }
-
-    mState = State::Bound;
-    return Result::success();
-}
-
-Result Socket::receive(Message* receivingMessage) {
-    if (receivingMessage == nullptr) {
-        return Result::error("No receivingMessage provided");
-    }
-    if (mState != State::Bound) {
-        return Result::error("Attempt to receive on a socket that isn't bound");
-    }
-
-    ssize_t rxBytes = ::recv(mSocket,
-                             receivingMessage->data(),
-                             receivingMessage->capacity(),
-                             0);
-    if (rxBytes < 0) {
-        return Result::error(strerror(errno));
-    }
-
-    receivingMessage->setSize(static_cast<size_t>(rxBytes));
-    return Result::success();
-}
-
-Result Socket::receiveFrom(Message* receivingMessage, Address* from) {
-    if (receivingMessage == nullptr) {
-        return Result::error("No receivingMessage provided");
-    }
-    if (from == nullptr) {
-        return Result::error("No from address provided");
-    }
-    if (mState != State::Bound) {
-        return Result::error("Attempt to receive on a socket that isn't bound");
-    }
-
-    from->reset();
-    sockaddr* source = from->get<sockaddr>();
-    socklen_t sourceLen = from->size();
-    ssize_t rxBytes = ::recvfrom(mSocket,
-                                 receivingMessage->data(),
-                                 receivingMessage->capacity(),
-                                 0,
-                                 source,
-                                 &sourceLen);
-    if (rxBytes < 0) {
-        return Result::error(strerror(errno));
-    }
-
-    receivingMessage->setSize(static_cast<size_t>(rxBytes));
-    return Result::success();
-}
-
-Result Socket::send(const void* data, size_t size) {
-    if (mState != State::Bound && mState != State::Open) {
-        return Result::error("Attempt to send on a socket in invalid state");
-    }
-
-    int res = ::send(mSocket, data, size, 0);
-    if (res == -1) {
-        return Result::error(strerror(errno));
-    }
-    return Result::success();
-}
-
-Result Socket::sendTo(const sockaddr& destination,
-                      size_t destinationSize,
-                      const void* data,
-                      size_t size) {
-    if (mState != State::Bound && mState != State::Open) {
-        return Result::error("Attempt to send on a socket in invalid state");
-    }
-
-    int res = ::sendto(mSocket, data, size, 0, &destination, destinationSize);
-    if (res == -1) {
-        return Result::error(strerror(errno));
-    }
-    return Result::success();
-}
-
-Result Socket::sendTo(const in6_addr& destination,
-                      const void* data,
-                      size_t size) {
-    sockaddr_in6 addr;
-    memset(&addr, 0, sizeof(addr));
-    addr.sin6_family = AF_INET6;
-    addr.sin6_addr = destination;
-    return sendTo(*reinterpret_cast<sockaddr*>(&addr),
-                  sizeof(addr),
-                  data,
-                  size);
-}
-
-Result Socket::sendFrom(const struct in6_addr& fromAddress,
-                        const sockaddr& destination,
-                        size_t destinationSize,
-                        const void* data,
-                        size_t size) {
-    struct msghdr messageHeader;
-    memset(&messageHeader, 0, sizeof(messageHeader));
-    // Even when sending this struct requires a non-const pointer, even when
-    // it's only going to be read. Do a const_cast instead of creating a
-    // method signature with illogical const-behavior.
-    messageHeader.msg_name = const_cast<struct sockaddr*>(&destination);
-    messageHeader.msg_namelen = destinationSize;
-
-    struct iovec iov;
-    messageHeader.msg_iov = &iov;
-    messageHeader.msg_iovlen = 1;
-
-    memset(&iov, 0, sizeof(iov));
-    iov.iov_base = const_cast<void*>(data);
-    iov.iov_len = size;
-
-    char control[CMSG_SPACE(sizeof(struct in6_pktinfo))] = { 0 };
-    messageHeader.msg_control = control;
-    messageHeader.msg_controllen = sizeof(control);
-
-    struct cmsghdr* controlHeader = CMSG_FIRSTHDR(&messageHeader);
-    controlHeader->cmsg_level = IPPROTO_IPV6;
-    controlHeader->cmsg_type = IPV6_PKTINFO;
-    controlHeader->cmsg_len = CMSG_LEN(sizeof(struct in6_pktinfo));
-
-    auto packetInfoData = CMSG_DATA(controlHeader);
-    auto packetInfo = reinterpret_cast<struct in6_pktinfo*>(packetInfoData);
-    packetInfo->ipi6_addr = fromAddress;
-
-    int res = ::sendmsg(mSocket, &messageHeader, 0);
-    if (res == -1) {
-        int error = errno;
-        printf("sendmsg failed: %d\n", error);
-        return Result::error(strerror(error));
-    }
-    return Result::success();
-}
-
-Result Socket::sendFrom(const in6_addr& fromAddress,
-                        const in6_addr& destination,
-                        const void* data,
-                        size_t size) {
-    sockaddr_in6 addr;
-    memset(&addr, 0, sizeof(addr));
-    addr.sin6_family = AF_INET6;
-    addr.sin6_addr = destination;
-
-    return sendFrom(fromAddress,
-                    *reinterpret_cast<sockaddr*>(&addr),
-                    sizeof(addr),
-                    data,
-                    size);
-}
diff --git a/device/generic/goldfish/wifi/ipv6proxy/socket.h b/device/generic/goldfish/wifi/ipv6proxy/socket.h
deleted file mode 100644
index 9cbdda3..0000000
--- a/device/generic/goldfish/wifi/ipv6proxy/socket.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2017 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#pragma once
-
-#include "result.h"
-
-#include <netinet/in.h>
-
-#include <stdint.h>
-#include <string>
-
-class Address;
-class Message;
-
-class Socket {
-public:
-    enum class Domain {
-        IpV4,
-        IpV6,
-        Packet,
-    };
-
-    enum class Type {
-        Stream,   // A streaming protocol, use this with Infer for TCP
-        Datagram, // A datagram protocol, use this with Infer for UDP
-        Raw,      // A raw socket
-    };
-    enum class Protocol {
-        Infer,    // Infer the protocol from the type, such as TCP for Stream
-        Ip,       // Internet Protocol for raw sockets
-        IcmpV6,   // ICMPv6 control protocol for Raw sockets
-        EthIpV6,  // Ethernet packets containing IPV6, for packet sockets
-    };
-
-    // Construct an empty socket object, next use open() to start using it
-    Socket();
-    // Move construct a socket, The constructed socket will be in the same state
-    // that |other| is. After this |other| will be in an undefined state and
-    // should no longer be used.
-    Socket(Socket&& other) noexcept;
-    ~Socket();
-
-    // Move the |other| socket object into this one. If this object has an open
-    // socket it will be closed first. After that this object will have the
-    // same state that |other| did. |other| will be left in an undefined state
-    // and should not be used.
-    Socket& operator=(Socket&& other) noexcept;
-
-    int get() const { return mSocket; }
-
-    Result open(int domain, int type, int protocol);
-
-    /** Options, these must be called between open and bind **/
-
-    // Bind to a specific interface regardless of the address that the socket
-    // is going to bind to.
-    Result setInterface(const std::string& interface);
-
-    // Set the hop limit for multicast traffic on the socket. Each router hop
-    // decreases this value by one, when it reaches zero the packet is
-    // discarded.
-    Result setMulticastHopLimit(int hopLimit);
-
-    // Set the hop limit for unicast traffic on the socket. Each router hop
-    // decreases this value by one, when it reaches zero the packet is
-    // discarded.
-    Result setUnicastHopLimit(int hopLimit);
-
-    // Configure the socket to be transparent. This allows packets sent to have
-    // a source address that is different from the network interface's source
-    // address.
-    Result setTransparent(bool transparent);
-
-    /** Binding **/
-
-    Result bind(const Address& address);
-
-    /** Sending and receiving **/
-
-    Result receive(Message* receivingMessage);
-    Result receiveFrom(Message* receivingMessage, Address* from);
-
-    Result send(const void* data, size_t size);
-
-    // Send a packet to a specific |destination| of any address type.
-    Result sendTo(const sockaddr& destination,
-                  size_t destinationSize,
-                  const void* data,
-                  size_t size);
-    // Convenience function to send to a specific IPv6 address.
-    Result sendTo(const in6_addr& destination, const void* data, size_t size);
-    // Convenience method to use sendTo with a more specific sockaddr struct
-    // without having to specify the size or do the casting.
-    template<typename T>
-    Result sendTo(const T& destination, const void* data, size_t size) {
-        return sendTo(*reinterpret_cast<const sockaddr*>(&destination),
-                      sizeof(destination),
-                      data,
-                      size);
-    }
-
-    // Send a packet with a specific source IPv6 address to a given
-    // |destination|. Rewriting the source in this manner usually requires root.
-    Result sendFrom(const in6_addr& fromAddress,
-                    const sockaddr& destination,
-                    size_t destinationSize,
-                    const void* data,
-                    size_t size);
-    Result sendFrom(const in6_addr& fromAddress,
-                    const in6_addr& destination,
-                    const void* data,
-                    size_t size);
-    // Convenience method to use sendFrom with a more specific sockaddr struct
-    // without having to specify the size or do the casting.
-    template<typename T>
-    Result sendFrom(const in6_addr& fromAddress,
-                    const T& destination,
-                    const void* data,
-                    size_t size) {
-        return sendFrom(fromAddress,
-                        *reinterpret_cast<const sockaddr*>(&destination),
-                        sizeof(destination),
-                        data,
-                        size);
-    }
-
-private:
-    // No copy construction or assignment allowed, support move semantics only
-    Socket(const Socket&);
-    Socket& operator=(const Socket&);
-
-    enum class State {
-        New,
-        Open,
-        Bound,
-        Moved,
-        Destructed,
-    };
-
-    State mState;
-    int mSocket;
-};
-
diff --git a/device/generic/goldfish/wifi/simulated_hostapd.conf b/device/generic/goldfish/wifi/simulated_hostapd.conf
deleted file mode 100644
index b50bafd..0000000
--- a/device/generic/goldfish/wifi/simulated_hostapd.conf
+++ /dev/null
@@ -1,1764 +0,0 @@
-#
-#* Copyright (C) 2016 The Android Open Source Project
-#*
-#* Licensed under the Apache License, Version 2.0 (the "License");
-#* you may not use this file except in compliance with the License.
-#* You may obtain a copy of the License at
-#*
-#*      http://www.apache.org/licenses/LICENSE-2.0
-#*
-#* Unless required by applicable law or agreed to in writing, software
-#* distributed under the License is distributed on an "AS IS" BASIS,
-#* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-#* See the License for the specific language governing permissions and
-#* limitations under the License.
-#
-##### hostapd configuration file ##############################################
-# Empty lines and lines starting with # are ignored
-
-# AP netdevice name (without 'ap' postfix, i.e., wlan0 uses wlan0ap for
-# management frames); ath0 for madwifi
-interface=wlan1
-
-# In case of madwifi, atheros, and nl80211 driver interfaces, an additional
-# configuration parameter, bridge, may be used to notify hostapd if the
-# interface is included in a bridge. This parameter is not used with Host AP
-# driver. If the bridge parameter is not set, the drivers will automatically
-# figure out the bridge interface (assuming sysfs is enabled and mounted to
-# /sys) and this parameter may not be needed.
-#
-# For nl80211, this parameter can be used to request the AP interface to be
-# added to the bridge automatically (brctl may refuse to do this before hostapd
-# has been started to change the interface mode). If needed, the bridge
-# interface is also created.
-#bridge=br0
-
-# Driver interface type (hostap/wired/madwifi/test/none/nl80211/bsd);
-# default: hostap). nl80211 is used with all Linux mac80211 drivers.
-# Use driver=none if building hostapd as a standalone RADIUS server that does
-# not control any wireless/wired driver.
-# driver=hostap
-driver=nl80211
-# hostapd event logger configuration
-#
-# Two output method: syslog and stdout (only usable if not forking to
-# background).
-#
-# Module bitfield (ORed bitfield of modules that will be logged; -1 = all
-# modules):
-# bit 0 (1) = IEEE 802.11
-# bit 1 (2) = IEEE 802.1X
-# bit 2 (4) = RADIUS
-# bit 3 (8) = WPA
-# bit 4 (16) = driver interface
-# bit 5 (32) = IAPP
-# bit 6 (64) = MLME
-#
-# Levels (minimum value for logged events):
-#  0 = verbose debugging
-#  1 = debugging
-#  2 = informational messages
-#  3 = notification
-#  4 = warning
-#
-logger_syslog=-1
-logger_syslog_level=2
-logger_stdout=-1
-logger_stdout_level=2
-
-# Interface for separate control program. If this is specified, hostapd
-# will create this directory and a UNIX domain socket for listening to requests
-# from external programs (CLI/GUI, etc.) for status information and
-# configuration. The socket file will be named based on the interface name, so
-# multiple hostapd processes/interfaces can be run at the same time if more
-# than one interface is used.
-# /var/run/hostapd is the recommended directory for sockets and by default,
-# hostapd_cli will use it when trying to connect with hostapd.
-#ctrl_interface=/data/local/wifi/sockets
-
-# Access control for the control interface can be configured by setting the
-# directory to allow only members of a group to use sockets. This way, it is
-# possible to run hostapd as root (since it needs to change network
-# configuration and open raw sockets) and still allow GUI/CLI components to be
-# run as non-root users. However, since the control interface can be used to
-# change the network configuration, this access needs to be protected in many
-# cases. By default, hostapd is configured to use gid 0 (root). If you
-# want to allow non-root users to use the contron interface, add a new group
-# and change this value to match with that group. Add users that should have
-# control interface access to this group.
-#
-# This variable can be a group name or gid.
-#ctrl_interface_group=wheel
-ctrl_interface_group=0
-
-
-##### IEEE 802.11 related configuration #######################################
-
-# SSID to be used in IEEE 802.11 management frames
-ssid=AndroidWifi
-# Alternative formats for configuring SSID
-# (double quoted string, hexdump, printf-escaped string)
-#ssid2="test"
-#ssid2=74657374
-#ssid2=P"hello\nthere"
-
-# UTF-8 SSID: Whether the SSID is to be interpreted using UTF-8 encoding
-#utf8_ssid=1
-
-# Country code (ISO/IEC 3166-1). Used to set regulatory domain.
-# Set as needed to indicate country in which device is operating.
-# This can limit available channels and transmit power.
-country_code=US
-
-# Enable IEEE 802.11d. This advertises the country_code and the set of allowed
-# channels and transmit power levels based on the regulatory limits. The
-# country_code setting must be configured with the correct country for
-# IEEE 802.11d functions.
-# (default: 0 = disabled)
-#ieee80211d=1
-
-# Enable IEEE 802.11h. This enables radar detection and DFS support if
-# available. DFS support is required on outdoor 5 GHz channels in most countries
-# of the world. This can be used only with ieee80211d=1.
-# (default: 0 = disabled)
-#ieee80211h=1
-
-# Add Power Constraint element to Beacon and Probe Response frames
-# This config option adds Power Constraint element when applicable and Country
-# element is added. Power Constraint element is required by Transmit Power
-# Control. This can be used only with ieee80211d=1.
-# Valid values are 0..255.
-#local_pwr_constraint=3
-
-# Set Spectrum Management subfield in the Capability Information field.
-# This config option forces the Spectrum Management bit to be set. When this
-# option is not set, the value of the Spectrum Management bit depends on whether
-# DFS or TPC is required by regulatory authorities. This can be used only with
-# ieee80211d=1 and local_pwr_constraint configured.
-#spectrum_mgmt_required=1
-
-# Operation mode (a = IEEE 802.11a, b = IEEE 802.11b, g = IEEE 802.11g,
-# ad = IEEE 802.11ad (60 GHz); a/g options are used with IEEE 802.11n, too, to
-# specify band)
-# Default: IEEE 802.11b
-hw_mode=g
-
-# Channel number (IEEE 802.11)
-# (default: 0, i.e., not set)
-# Please note that some drivers do not use this value from hostapd and the
-# channel will need to be configured separately with iwconfig.
-#
-# If CONFIG_ACS build option is enabled, the channel can be selected
-# automatically at run time by setting channel=acs_survey or channel=0, both of
-# which will enable the ACS survey based algorithm.
-channel=8
-
-# ACS tuning - Automatic Channel Selection
-# See: http://wireless.kernel.org/en/users/Documentation/acs
-#
-# You can customize the ACS survey algorithm with following variables:
-#
-# acs_num_scans requirement is 1..100 - number of scans to be performed that
-# are used to trigger survey data gathering of an underlying device driver.
-# Scans are passive and typically take a little over 100ms (depending on the
-# driver) on each available channel for given hw_mode. Increasing this value
-# means sacrificing startup time and gathering more data wrt channel
-# interference that may help choosing a better channel. This can also help fine
-# tune the ACS scan time in case a driver has different scan dwell times.
-#
-# Defaults:
-#acs_num_scans=5
-
-# Channel list restriction. This option allows hostapd to select one of the
-# provided channels when a channel should be automatically selected. This
-# is currently only used for DFS when the current channels becomes unavailable
-# due to radar interference, and is currently only useful when ieee80211h=1 is
-# set.
-# Default: not set (allow any enabled channel to be selected)
-#chanlist=100 104 108 112 116
-
-# Beacon interval in kus (1.024 ms) (default: 100; range 15..65535)
-beacon_int=100
-
-# DTIM (delivery traffic information message) period (range 1..255):
-# number of beacons between DTIMs (1 = every beacon includes DTIM element)
-# (default: 2)
-dtim_period=2
-
-# Maximum number of stations allowed in station table. New stations will be
-# rejected after the station table is full. IEEE 802.11 has a limit of 2007
-# different association IDs, so this number should not be larger than that.
-# (default: 2007)
-max_num_sta=255
-
-# RTS/CTS threshold; 2347 = disabled (default); range 0..2347
-# If this field is not included in hostapd.conf, hostapd will not control
-# RTS threshold and 'iwconfig wlan# rts <val>' can be used to set it.
-rts_threshold=2347
-
-# Fragmentation threshold; 2346 = disabled (default); range 256..2346
-# If this field is not included in hostapd.conf, hostapd will not control
-# fragmentation threshold and 'iwconfig wlan# frag <val>' can be used to set
-# it.
-fragm_threshold=2346
-
-# Rate configuration
-# Default is to enable all rates supported by the hardware. This configuration
-# item allows this list be filtered so that only the listed rates will be left
-# in the list. If the list is empty, all rates are used. This list can have
-# entries that are not in the list of rates the hardware supports (such entries
-# are ignored). The entries in this list are in 100 kbps, i.e., 11 Mbps = 110.
-# If this item is present, at least one rate have to be matching with the rates
-# hardware supports.
-# default: use the most common supported rate setting for the selected
-# hw_mode (i.e., this line can be removed from configuration file in most
-# cases)
-#supported_rates=10 20 55 110 60 90 120 180 240 360 480 540
-
-# Basic rate set configuration
-# List of rates (in 100 kbps) that are included in the basic rate set.
-# If this item is not included, usually reasonable default set is used.
-#basic_rates=10 20
-#basic_rates=10 20 55 110
-#basic_rates=60 120 240
-
-# Short Preamble
-# This parameter can be used to enable optional use of short preamble for
-# frames sent at 2 Mbps, 5.5 Mbps, and 11 Mbps to improve network performance.
-# This applies only to IEEE 802.11b-compatible networks and this should only be
-# enabled if the local hardware supports use of short preamble. If any of the
-# associated STAs do not support short preamble, use of short preamble will be
-# disabled (and enabled when such STAs disassociate) dynamically.
-# 0 = do not allow use of short preamble (default)
-# 1 = allow use of short preamble
-#preamble=1
-
-# Station MAC address -based authentication
-# Please note that this kind of access control requires a driver that uses
-# hostapd to take care of management frame processing and as such, this can be
-# used with driver=hostap or driver=nl80211, but not with driver=madwifi.
-# 0 = accept unless in deny list
-# 1 = deny unless in accept list
-# 2 = use external RADIUS server (accept/deny lists are searched first)
-macaddr_acl=0
-
-# Accept/deny lists are read from separate files (containing list of
-# MAC addresses, one per line). Use absolute path name to make sure that the
-# files can be read on SIGHUP configuration reloads.
-#accept_mac_file=/etc/hostapd.accept
-#deny_mac_file=/etc/hostapd.deny
-
-# IEEE 802.11 specifies two authentication algorithms. hostapd can be
-# configured to allow both of these or only one. Open system authentication
-# should be used with IEEE 802.1X.
-# Bit fields of allowed authentication algorithms:
-# bit 0 = Open System Authentication
-# bit 1 = Shared Key Authentication (requires WEP)
-auth_algs=3
-
-# Send empty SSID in beacons and ignore probe request frames that do not
-# specify full SSID, i.e., require stations to know SSID.
-# default: disabled (0)
-# 1 = send empty (length=0) SSID in beacon and ignore probe request for
-#     broadcast SSID
-# 2 = clear SSID (ASCII 0), but keep the original length (this may be required
-#     with some clients that do not support empty SSID) and ignore probe
-#     requests for broadcast SSID
-ignore_broadcast_ssid=0
-
-# Additional vendor specfic elements for Beacon and Probe Response frames
-# This parameter can be used to add additional vendor specific element(s) into
-# the end of the Beacon and Probe Response frames. The format for these
-# element(s) is a hexdump of the raw information elements (id+len+payload for
-# one or more elements)
-#vendor_elements=dd0411223301
-
-# TX queue parameters (EDCF / bursting)
-# tx_queue_<queue name>_<param>
-# queues: data0, data1, data2, data3, after_beacon, beacon
-#		(data0 is the highest priority queue)
-# parameters:
-#   aifs: AIFS (default 2)
-#   cwmin: cwMin (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023)
-#   cwmax: cwMax (1, 3, 7, 15, 31, 63, 127, 255, 511, 1023); cwMax >= cwMin
-#   burst: maximum length (in milliseconds with precision of up to 0.1 ms) for
-#          bursting
-#
-# Default WMM parameters (IEEE 802.11 draft; 11-03-0504-03-000e):
-# These parameters are used by the access point when transmitting frames
-# to the clients.
-#
-# Low priority / AC_BK = background
-#tx_queue_data3_aifs=7
-#tx_queue_data3_cwmin=15
-#tx_queue_data3_cwmax=1023
-#tx_queue_data3_burst=0
-# Note: for IEEE 802.11b mode: cWmin=31 cWmax=1023 burst=0
-#
-# Normal priority / AC_BE = best effort
-#tx_queue_data2_aifs=3
-#tx_queue_data2_cwmin=15
-#tx_queue_data2_cwmax=63
-#tx_queue_data2_burst=0
-# Note: for IEEE 802.11b mode: cWmin=31 cWmax=127 burst=0
-#
-# High priority / AC_VI = video
-#tx_queue_data1_aifs=1
-#tx_queue_data1_cwmin=7
-#tx_queue_data1_cwmax=15
-#tx_queue_data1_burst=3.0
-# Note: for IEEE 802.11b mode: cWmin=15 cWmax=31 burst=6.0
-#
-# Highest priority / AC_VO = voice
-#tx_queue_data0_aifs=1
-#tx_queue_data0_cwmin=3
-#tx_queue_data0_cwmax=7
-#tx_queue_data0_burst=1.5
-# Note: for IEEE 802.11b mode: cWmin=7 cWmax=15 burst=3.3
-
-# 802.1D Tag (= UP) to AC mappings
-# WMM specifies following mapping of data frames to different ACs. This mapping
-# can be configured using Linux QoS/tc and sch_pktpri.o module.
-# 802.1D Tag	802.1D Designation	Access Category	WMM Designation
-# 1		BK			AC_BK		Background
-# 2		-			AC_BK		Background
-# 0		BE			AC_BE		Best Effort
-# 3		EE			AC_BE		Best Effort
-# 4		CL			AC_VI		Video
-# 5		VI			AC_VI		Video
-# 6		VO			AC_VO		Voice
-# 7		NC			AC_VO		Voice
-# Data frames with no priority information: AC_BE
-# Management frames: AC_VO
-# PS-Poll frames: AC_BE
-
-# Default WMM parameters (IEEE 802.11 draft; 11-03-0504-03-000e):
-# for 802.11a or 802.11g networks
-# These parameters are sent to WMM clients when they associate.
-# The parameters will be used by WMM clients for frames transmitted to the
-# access point.
-#
-# note - txop_limit is in units of 32microseconds
-# note - acm is admission control mandatory flag. 0 = admission control not
-# required, 1 = mandatory
-# note - here cwMin and cmMax are in exponent form. the actual cw value used
-# will be (2^n)-1 where n is the value given here
-#
-wmm_enabled=1
-#
-# WMM-PS Unscheduled Automatic Power Save Delivery [U-APSD]
-# Enable this flag if U-APSD supported outside hostapd (eg., Firmware/driver)
-#uapsd_advertisement_enabled=1
-#
-# Low priority / AC_BK = background
-wmm_ac_bk_cwmin=4
-wmm_ac_bk_cwmax=10
-wmm_ac_bk_aifs=7
-wmm_ac_bk_txop_limit=0
-wmm_ac_bk_acm=0
-# Note: for IEEE 802.11b mode: cWmin=5 cWmax=10
-#
-# Normal priority / AC_BE = best effort
-wmm_ac_be_aifs=3
-wmm_ac_be_cwmin=4
-wmm_ac_be_cwmax=10
-wmm_ac_be_txop_limit=0
-wmm_ac_be_acm=0
-# Note: for IEEE 802.11b mode: cWmin=5 cWmax=7
-#
-# High priority / AC_VI = video
-wmm_ac_vi_aifs=2
-wmm_ac_vi_cwmin=3
-wmm_ac_vi_cwmax=4
-wmm_ac_vi_txop_limit=94
-wmm_ac_vi_acm=0
-# Note: for IEEE 802.11b mode: cWmin=4 cWmax=5 txop_limit=188
-#
-# Highest priority / AC_VO = voice
-wmm_ac_vo_aifs=2
-wmm_ac_vo_cwmin=2
-wmm_ac_vo_cwmax=3
-wmm_ac_vo_txop_limit=47
-wmm_ac_vo_acm=0
-# Note: for IEEE 802.11b mode: cWmin=3 cWmax=4 burst=102
-
-# Static WEP key configuration
-#
-# The key number to use when transmitting.
-# It must be between 0 and 3, and the corresponding key must be set.
-# default: not set
-#wep_default_key=0
-# The WEP keys to use.
-# A key may be a quoted string or unquoted hexadecimal digits.
-# The key length should be 5, 13, or 16 characters, or 10, 26, or 32
-# digits, depending on whether 40-bit (64-bit), 104-bit (128-bit), or
-# 128-bit (152-bit) WEP is used.
-# Only the default key must be supplied; the others are optional.
-# default: not set
-#wep_key0=123456789a
-#wep_key1="vwxyz"
-#wep_key2=0102030405060708090a0b0c0d
-#wep_key3=".2.4.6.8.0.23"
-
-# Station inactivity limit
-#
-# If a station does not send anything in ap_max_inactivity seconds, an
-# empty data frame is sent to it in order to verify whether it is
-# still in range. If this frame is not ACKed, the station will be
-# disassociated and then deauthenticated. This feature is used to
-# clear station table of old entries when the STAs move out of the
-# range.
-#
-# The station can associate again with the AP if it is still in range;
-# this inactivity poll is just used as a nicer way of verifying
-# inactivity; i.e., client will not report broken connection because
-# disassociation frame is not sent immediately without first polling
-# the STA with a data frame.
-# default: 300 (i.e., 5 minutes)
-#ap_max_inactivity=300
-#
-# The inactivity polling can be disabled to disconnect stations based on
-# inactivity timeout so that idle stations are more likely to be disconnected
-# even if they are still in range of the AP. This can be done by setting
-# skip_inactivity_poll to 1 (default 0).
-#skip_inactivity_poll=0
-
-# Disassociate stations based on excessive transmission failures or other
-# indications of connection loss. This depends on the driver capabilities and
-# may not be available with all drivers.
-#disassoc_low_ack=1
-
-# Maximum allowed Listen Interval (how many Beacon periods STAs are allowed to
-# remain asleep). Default: 65535 (no limit apart from field size)
-#max_listen_interval=100
-
-# WDS (4-address frame) mode with per-station virtual interfaces
-# (only supported with driver=nl80211)
-# This mode allows associated stations to use 4-address frames to allow layer 2
-# bridging to be used.
-#wds_sta=1
-
-# If bridge parameter is set, the WDS STA interface will be added to the same
-# bridge by default. This can be overridden with the wds_bridge parameter to
-# use a separate bridge.
-#wds_bridge=wds-br0
-
-# Start the AP with beaconing disabled by default.
-#start_disabled=0
-
-# Client isolation can be used to prevent low-level bridging of frames between
-# associated stations in the BSS. By default, this bridging is allowed.
-#ap_isolate=1
-
-# Fixed BSS Load value for testing purposes
-# This field can be used to configure hostapd to add a fixed BSS Load element
-# into Beacon and Probe Response frames for testing purposes. The format is
-# <station count>:<channel utilization>:<available admission capacity>
-#bss_load_test=12:80:20000
-
-##### IEEE 802.11n related configuration ######################################
-
-# ieee80211n: Whether IEEE 802.11n (HT) is enabled
-# 0 = disabled (default)
-# 1 = enabled
-# Note: You will also need to enable WMM for full HT functionality.
-ieee80211n=1
-
-# ht_capab: HT capabilities (list of flags)
-# LDPC coding capability: [LDPC] = supported
-# Supported channel width set: [HT40-] = both 20 MHz and 40 MHz with secondary
-#	channel below the primary channel; [HT40+] = both 20 MHz and 40 MHz
-#	with secondary channel above the primary channel
-#	(20 MHz only if neither is set)
-#	Note: There are limits on which channels can be used with HT40- and
-#	HT40+. Following table shows the channels that may be available for
-#	HT40- and HT40+ use per IEEE 802.11n Annex J:
-#	freq		HT40-		HT40+
-#	2.4 GHz		5-13		1-7 (1-9 in Europe/Japan)
-#	5 GHz		40,48,56,64	36,44,52,60
-#	(depending on the location, not all of these channels may be available
-#	for use)
-#	Please note that 40 MHz channels may switch their primary and secondary
-#	channels if needed or creation of 40 MHz channel maybe rejected based
-#	on overlapping BSSes. These changes are done automatically when hostapd
-#	is setting up the 40 MHz channel.
-# Spatial Multiplexing (SM) Power Save: [SMPS-STATIC] or [SMPS-DYNAMIC]
-#	(SMPS disabled if neither is set)
-# HT-greenfield: [GF] (disabled if not set)
-# Short GI for 20 MHz: [SHORT-GI-20] (disabled if not set)
-# Short GI for 40 MHz: [SHORT-GI-40] (disabled if not set)
-# Tx STBC: [TX-STBC] (disabled if not set)
-# Rx STBC: [RX-STBC1] (one spatial stream), [RX-STBC12] (one or two spatial
-#	streams), or [RX-STBC123] (one, two, or three spatial streams); Rx STBC
-#	disabled if none of these set
-# HT-delayed Block Ack: [DELAYED-BA] (disabled if not set)
-# Maximum A-MSDU length: [MAX-AMSDU-7935] for 7935 octets (3839 octets if not
-#	set)
-# DSSS/CCK Mode in 40 MHz: [DSSS_CCK-40] = allowed (not allowed if not set)
-# 40 MHz intolerant [40-INTOLERANT] (not advertised if not set)
-# L-SIG TXOP protection support: [LSIG-TXOP-PROT] (disabled if not set)
-ht_capab=[HT40-][DSSS_CCK-40][SHORT-GI-40]
-
-# Require stations to support HT PHY (reject association if they do not)
-#require_ht=1
-
-# If set non-zero, require stations to perform scans of overlapping
-# channels to test for stations which would be affected by 40 MHz traffic.
-# This parameter sets the interval in seconds between these scans. This
-# is useful only for testing that stations properly set the OBSS interval,
-# since the other parameters in the OBSS scan parameters IE are set to 0.
-#obss_interval=0
-
-##### IEEE 802.11ac related configuration #####################################
-
-# ieee80211ac: Whether IEEE 802.11ac (VHT) is enabled
-# 0 = disabled (default)
-# 1 = enabled
-# Note: You will also need to enable WMM for full VHT functionality.
-#ieee80211ac=1
-
-# vht_capab: VHT capabilities (list of flags)
-#
-# vht_max_mpdu_len: [MAX-MPDU-7991] [MAX-MPDU-11454]
-# Indicates maximum MPDU length
-# 0 = 3895 octets (default)
-# 1 = 7991 octets
-# 2 = 11454 octets
-# 3 = reserved
-#
-# supported_chan_width: [VHT160] [VHT160-80PLUS80]
-# Indicates supported Channel widths
-# 0 = 160 MHz & 80+80 channel widths are not supported (default)
-# 1 = 160 MHz channel width is supported
-# 2 = 160 MHz & 80+80 channel widths are supported
-# 3 = reserved
-#
-# Rx LDPC coding capability: [RXLDPC]
-# Indicates support for receiving LDPC coded pkts
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Short GI for 80 MHz: [SHORT-GI-80]
-# Indicates short GI support for reception of packets transmitted with TXVECTOR
-# params format equal to VHT and CBW = 80Mhz
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Short GI for 160 MHz: [SHORT-GI-160]
-# Indicates short GI support for reception of packets transmitted with TXVECTOR
-# params format equal to VHT and CBW = 160Mhz
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Tx STBC: [TX-STBC-2BY1]
-# Indicates support for the transmission of at least 2x1 STBC
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Rx STBC: [RX-STBC-1] [RX-STBC-12] [RX-STBC-123] [RX-STBC-1234]
-# Indicates support for the reception of PPDUs using STBC
-# 0 = Not supported (default)
-# 1 = support of one spatial stream
-# 2 = support of one and two spatial streams
-# 3 = support of one, two and three spatial streams
-# 4 = support of one, two, three and four spatial streams
-# 5,6,7 = reserved
-#
-# SU Beamformer Capable: [SU-BEAMFORMER]
-# Indicates support for operation as a single user beamformer
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# SU Beamformee Capable: [SU-BEAMFORMEE]
-# Indicates support for operation as a single user beamformee
-# 0 = Not supported (default)
-# 1 = Supported
-#
-# Compressed Steering Number of Beamformer Antennas Supported: [BF-ANTENNA-2]
-#   Beamformee's capability indicating the maximum number of beamformer
-#   antennas the beamformee can support when sending compressed beamforming
-#   feedback
-# If SU beamformer capable, set to maximum value minus 1
-# else reserved (default)
-#
-# Number of Sounding Dimensions: [SOUNDING-DIMENSION-2]
-# Beamformer's capability indicating the maximum value of the NUM_STS parameter
-# in the TXVECTOR of a VHT NDP
-# If SU beamformer capable, set to maximum value minus 1
-# else reserved (default)
-#
-# MU Beamformer Capable: [MU-BEAMFORMER]
-# Indicates support for operation as an MU beamformer
-# 0 = Not supported or sent by Non-AP STA (default)
-# 1 = Supported
-#
-# MU Beamformee Capable: [MU-BEAMFORMEE]
-# Indicates support for operation as an MU beamformee
-# 0 = Not supported or sent by AP (default)
-# 1 = Supported
-#
-# VHT TXOP PS: [VHT-TXOP-PS]
-# Indicates whether or not the AP supports VHT TXOP Power Save Mode
-#  or whether or not the STA is in VHT TXOP Power Save mode
-# 0 = VHT AP doesnt support VHT TXOP PS mode (OR) VHT Sta not in VHT TXOP PS
-#  mode
-# 1 = VHT AP supports VHT TXOP PS mode (OR) VHT Sta is in VHT TXOP power save
-#  mode
-#
-# +HTC-VHT Capable: [HTC-VHT]
-# Indicates whether or not the STA supports receiving a VHT variant HT Control
-# field.
-# 0 = Not supported (default)
-# 1 = supported
-#
-# Maximum A-MPDU Length Exponent: [MAX-A-MPDU-LEN-EXP0]..[MAX-A-MPDU-LEN-EXP7]
-# Indicates the maximum length of A-MPDU pre-EOF padding that the STA can recv
-# This field is an integer in the range of 0 to 7.
-# The length defined by this field is equal to
-# 2 pow(13 + Maximum A-MPDU Length Exponent) -1 octets
-#
-# VHT Link Adaptation Capable: [VHT-LINK-ADAPT2] [VHT-LINK-ADAPT3]
-# Indicates whether or not the STA supports link adaptation using VHT variant
-# HT Control field
-# If +HTC-VHTcapable is 1
-#  0 = (no feedback) if the STA does not provide VHT MFB (default)
-#  1 = reserved
-#  2 = (Unsolicited) if the STA provides only unsolicited VHT MFB
-#  3 = (Both) if the STA can provide VHT MFB in response to VHT MRQ and if the
-#      STA provides unsolicited VHT MFB
-# Reserved if +HTC-VHTcapable is 0
-#
-# Rx Antenna Pattern Consistency: [RX-ANTENNA-PATTERN]
-# Indicates the possibility of Rx antenna pattern change
-# 0 = Rx antenna pattern might change during the lifetime of an association
-# 1 = Rx antenna pattern does not change during the lifetime of an association
-#
-# Tx Antenna Pattern Consistency: [TX-ANTENNA-PATTERN]
-# Indicates the possibility of Tx antenna pattern change
-# 0 = Tx antenna pattern might change during the lifetime of an association
-# 1 = Tx antenna pattern does not change during the lifetime of an association
-#vht_capab=[SHORT-GI-80][HTC-VHT]
-#
-# Require stations to support VHT PHY (reject association if they do not)
-#require_vht=1
-
-# 0 = 20 or 40 MHz operating Channel width
-# 1 = 80 MHz channel width
-# 2 = 160 MHz channel width
-# 3 = 80+80 MHz channel width
-#vht_oper_chwidth=1
-#
-# center freq = 5 GHz + (5 * index)
-# So index 42 gives center freq 5.210 GHz
-# which is channel 42 in 5G band
-#
-#vht_oper_centr_freq_seg0_idx=42
-#
-# center freq = 5 GHz + (5 * index)
-# So index 159 gives center freq 5.795 GHz
-# which is channel 159 in 5G band
-#
-#vht_oper_centr_freq_seg1_idx=159
-
-##### IEEE 802.1X-2004 related configuration ##################################
-
-# Require IEEE 802.1X authorization
-#ieee8021x=1
-
-# IEEE 802.1X/EAPOL version
-# hostapd is implemented based on IEEE Std 802.1X-2004 which defines EAPOL
-# version 2. However, there are many client implementations that do not handle
-# the new version number correctly (they seem to drop the frames completely).
-# In order to make hostapd interoperate with these clients, the version number
-# can be set to the older version (1) with this configuration value.
-#eapol_version=2
-
-# Optional displayable message sent with EAP Request-Identity. The first \0
-# in this string will be converted to ASCII-0 (nul). This can be used to
-# separate network info (comma separated list of attribute=value pairs); see,
-# e.g., RFC 4284.
-#eap_message=hello
-#eap_message=hello\0networkid=netw,nasid=foo,portid=0,NAIRealms=example.com
-
-# WEP rekeying (disabled if key lengths are not set or are set to 0)
-# Key lengths for default/broadcast and individual/unicast keys:
-# 5 = 40-bit WEP (also known as 64-bit WEP with 40 secret bits)
-# 13 = 104-bit WEP (also known as 128-bit WEP with 104 secret bits)
-#wep_key_len_broadcast=5
-#wep_key_len_unicast=5
-# Rekeying period in seconds. 0 = do not rekey (i.e., set keys only once)
-#wep_rekey_period=300
-
-# EAPOL-Key index workaround (set bit7) for WinXP Supplicant (needed only if
-# only broadcast keys are used)
-eapol_key_index_workaround=0
-
-# EAP reauthentication period in seconds (default: 3600 seconds; 0 = disable
-# reauthentication).
-#eap_reauth_period=3600
-
-# Use PAE group address (01:80:c2:00:00:03) instead of individual target
-# address when sending EAPOL frames with driver=wired. This is the most common
-# mechanism used in wired authentication, but it also requires that the port
-# is only used by one station.
-#use_pae_group_addr=1
-
-##### Integrated EAP server ###################################################
-
-# Optionally, hostapd can be configured to use an integrated EAP server
-# to process EAP authentication locally without need for an external RADIUS
-# server. This functionality can be used both as a local authentication server
-# for IEEE 802.1X/EAPOL and as a RADIUS server for other devices.
-
-# Use integrated EAP server instead of external RADIUS authentication
-# server. This is also needed if hostapd is configured to act as a RADIUS
-# authentication server.
-eap_server=0
-
-# Path for EAP server user database
-# If SQLite support is included, this can be set to "sqlite:/path/to/sqlite.db"
-# to use SQLite database instead of a text file.
-#eap_user_file=/etc/hostapd.eap_user
-
-# CA certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
-#ca_cert=/etc/hostapd.ca.pem
-
-# Server certificate (PEM or DER file) for EAP-TLS/PEAP/TTLS
-#server_cert=/etc/hostapd.server.pem
-
-# Private key matching with the server certificate for EAP-TLS/PEAP/TTLS
-# This may point to the same file as server_cert if both certificate and key
-# are included in a single file. PKCS#12 (PFX) file (.p12/.pfx) can also be
-# used by commenting out server_cert and specifying the PFX file as the
-# private_key.
-#private_key=/etc/hostapd.server.prv
-
-# Passphrase for private key
-#private_key_passwd=secret passphrase
-
-# Server identity
-# EAP methods that provide mechanism for authenticated server identity delivery
-# use this value. If not set, "hostapd" is used as a default.
-#server_id=server.example.com
-
-# Enable CRL verification.
-# Note: hostapd does not yet support CRL downloading based on CDP. Thus, a
-# valid CRL signed by the CA is required to be included in the ca_cert file.
-# This can be done by using PEM format for CA certificate and CRL and
-# concatenating these into one file. Whenever CRL changes, hostapd needs to be
-# restarted to take the new CRL into use.
-# 0 = do not verify CRLs (default)
-# 1 = check the CRL of the user certificate
-# 2 = check all CRLs in the certificate path
-#check_crl=1
-
-# Cached OCSP stapling response (DER encoded)
-# If set, this file is sent as a certificate status response by the EAP server
-# if the EAP peer requests certificate status in the ClientHello message.
-# This cache file can be updated, e.g., by running following command
-# periodically to get an update from the OCSP responder:
-# openssl ocsp \
-#	-no_nonce \
-#	-CAfile /etc/hostapd.ca.pem \
-#	-issuer /etc/hostapd.ca.pem \
-#	-cert /etc/hostapd.server.pem \
-#	-url http://ocsp.example.com:8888/ \
-#	-respout /tmp/ocsp-cache.der
-#ocsp_stapling_response=/tmp/ocsp-cache.der
-
-# dh_file: File path to DH/DSA parameters file (in PEM format)
-# This is an optional configuration file for setting parameters for an
-# ephemeral DH key exchange. In most cases, the default RSA authentication does
-# not use this configuration. However, it is possible setup RSA to use
-# ephemeral DH key exchange. In addition, ciphers with DSA keys always use
-# ephemeral DH keys. This can be used to achieve forward secrecy. If the file
-# is in DSA parameters format, it will be automatically converted into DH
-# params. This parameter is required if anonymous EAP-FAST is used.
-# You can generate DH parameters file with OpenSSL, e.g.,
-# "openssl dhparam -out /etc/hostapd.dh.pem 1024"
-#dh_file=/etc/hostapd.dh.pem
-
-# Fragment size for EAP methods
-#fragment_size=1400
-
-# Finite cyclic group for EAP-pwd. Number maps to group of domain parameters
-# using the IANA repository for IKE (RFC 2409).
-#pwd_group=19
-
-# Configuration data for EAP-SIM database/authentication gateway interface.
-# This is a text string in implementation specific format. The example
-# implementation in eap_sim_db.c uses this as the UNIX domain socket name for
-# the HLR/AuC gateway (e.g., hlr_auc_gw). In this case, the path uses "unix:"
-# prefix. If hostapd is built with SQLite support (CONFIG_SQLITE=y in .config),
-# database file can be described with an optional db=<path> parameter.
-#eap_sim_db=unix:/tmp/hlr_auc_gw.sock
-#eap_sim_db=unix:/tmp/hlr_auc_gw.sock db=/tmp/hostapd.db
-
-# Encryption key for EAP-FAST PAC-Opaque values. This key must be a secret,
-# random value. It is configured as a 16-octet value in hex format. It can be
-# generated, e.g., with the following command:
-# od -tx1 -v -N16 /dev/random | colrm 1 8 | tr -d ' '
-#pac_opaque_encr_key=000102030405060708090a0b0c0d0e0f
-
-# EAP-FAST authority identity (A-ID)
-# A-ID indicates the identity of the authority that issues PACs. The A-ID
-# should be unique across all issuing servers. In theory, this is a variable
-# length field, but due to some existing implementations requiring A-ID to be
-# 16 octets in length, it is strongly recommended to use that length for the
-# field to provid interoperability with deployed peer implementations. This
-# field is configured in hex format.
-#eap_fast_a_id=101112131415161718191a1b1c1d1e1f
-
-# EAP-FAST authority identifier information (A-ID-Info)
-# This is a user-friendly name for the A-ID. For example, the enterprise name
-# and server name in a human-readable format. This field is encoded as UTF-8.
-#eap_fast_a_id_info=test server
-
-# Enable/disable different EAP-FAST provisioning modes:
-#0 = provisioning disabled
-#1 = only anonymous provisioning allowed
-#2 = only authenticated provisioning allowed
-#3 = both provisioning modes allowed (default)
-#eap_fast_prov=3
-
-# EAP-FAST PAC-Key lifetime in seconds (hard limit)
-#pac_key_lifetime=604800
-
-# EAP-FAST PAC-Key refresh time in seconds (soft limit on remaining hard
-# limit). The server will generate a new PAC-Key when this number of seconds
-# (or fewer) of the lifetime remains.
-#pac_key_refresh_time=86400
-
-# EAP-SIM and EAP-AKA protected success/failure indication using AT_RESULT_IND
-# (default: 0 = disabled).
-#eap_sim_aka_result_ind=1
-
-# Trusted Network Connect (TNC)
-# If enabled, TNC validation will be required before the peer is allowed to
-# connect. Note: This is only used with EAP-TTLS and EAP-FAST. If any other
-# EAP method is enabled, the peer will be allowed to connect without TNC.
-#tnc=1
-
-
-##### IEEE 802.11f - Inter-Access Point Protocol (IAPP) #######################
-
-# Interface to be used for IAPP broadcast packets
-#iapp_interface=eth0
-
-
-##### RADIUS client configuration #############################################
-# for IEEE 802.1X with external Authentication Server, IEEE 802.11
-# authentication with external ACL for MAC addresses, and accounting
-
-# The own IP address of the access point (used as NAS-IP-Address)
-own_ip_addr=192.168.100.1
-
-# Optional NAS-Identifier string for RADIUS messages. When used, this should be
-# a unique to the NAS within the scope of the RADIUS server. For example, a
-# fully qualified domain name can be used here.
-# When using IEEE 802.11r, nas_identifier must be set and must be between 1 and
-# 48 octets long.
-#nas_identifier=ap.example.com
-
-# RADIUS authentication server
-#auth_server_addr=127.0.0.1
-#auth_server_port=1812
-#auth_server_shared_secret=secret
-
-# RADIUS accounting server
-#acct_server_addr=127.0.0.1
-#acct_server_port=1813
-#acct_server_shared_secret=secret
-
-# Secondary RADIUS servers; to be used if primary one does not reply to
-# RADIUS packets. These are optional and there can be more than one secondary
-# server listed.
-#auth_server_addr=127.0.0.2
-#auth_server_port=1812
-#auth_server_shared_secret=secret2
-#
-#acct_server_addr=127.0.0.2
-#acct_server_port=1813
-#acct_server_shared_secret=secret2
-
-# Retry interval for trying to return to the primary RADIUS server (in
-# seconds). RADIUS client code will automatically try to use the next server
-# when the current server is not replying to requests. If this interval is set,
-# primary server will be retried after configured amount of time even if the
-# currently used secondary server is still working.
-#radius_retry_primary_interval=600
-
-
-# Interim accounting update interval
-# If this is set (larger than 0) and acct_server is configured, hostapd will
-# send interim accounting updates every N seconds. Note: if set, this overrides
-# possible Acct-Interim-Interval attribute in Access-Accept message. Thus, this
-# value should not be configured in hostapd.conf, if RADIUS server is used to
-# control the interim interval.
-# This value should not be less 600 (10 minutes) and must not be less than
-# 60 (1 minute).
-#radius_acct_interim_interval=600
-
-# Request Chargeable-User-Identity (RFC 4372)
-# This parameter can be used to configure hostapd to request CUI from the
-# RADIUS server by including Chargeable-User-Identity attribute into
-# Access-Request packets.
-#radius_request_cui=1
-
-# Dynamic VLAN mode; allow RADIUS authentication server to decide which VLAN
-# is used for the stations. This information is parsed from following RADIUS
-# attributes based on RFC 3580 and RFC 2868: Tunnel-Type (value 13 = VLAN),
-# Tunnel-Medium-Type (value 6 = IEEE 802), Tunnel-Private-Group-ID (value
-# VLANID as a string). Optionally, the local MAC ACL list (accept_mac_file) can
-# be used to set static client MAC address to VLAN ID mapping.
-# 0 = disabled (default)
-# 1 = option; use default interface if RADIUS server does not include VLAN ID
-# 2 = required; reject authentication if RADIUS server does not include VLAN ID
-#dynamic_vlan=0
-
-# VLAN interface list for dynamic VLAN mode is read from a separate text file.
-# This list is used to map VLAN ID from the RADIUS server to a network
-# interface. Each station is bound to one interface in the same way as with
-# multiple BSSIDs or SSIDs. Each line in this text file is defining a new
-# interface and the line must include VLAN ID and interface name separated by
-# white space (space or tab).
-# If no entries are provided by this file, the station is statically mapped
-# to <bss-iface>.<vlan-id> interfaces.
-#vlan_file=/etc/hostapd.vlan
-
-# Interface where 802.1q tagged packets should appear when a RADIUS server is
-# used to determine which VLAN a station is on.  hostapd creates a bridge for
-# each VLAN.  Then hostapd adds a VLAN interface (associated with the interface
-# indicated by 'vlan_tagged_interface') and the appropriate wireless interface
-# to the bridge.
-#vlan_tagged_interface=eth0
-
-# Bridge (prefix) to add the wifi and the tagged interface to. This gets the
-# VLAN ID appended. It defaults to brvlan%d if no tagged interface is given
-# and br%s.%d if a tagged interface is given, provided %s = tagged interface
-# and %d = VLAN ID.
-#vlan_bridge=brvlan
-
-# When hostapd creates a VLAN interface on vlan_tagged_interfaces, it needs
-# to know how to name it.
-# 0 = vlan<XXX>, e.g., vlan1
-# 1 = <vlan_tagged_interface>.<XXX>, e.g. eth0.1
-#vlan_naming=0
-
-# Arbitrary RADIUS attributes can be added into Access-Request and
-# Accounting-Request packets by specifying the contents of the attributes with
-# the following configuration parameters. There can be multiple of these to
-# add multiple attributes. These parameters can also be used to override some
-# of the attributes added automatically by hostapd.
-# Format: <attr_id>[:<syntax:value>]
-# attr_id: RADIUS attribute type (e.g., 26 = Vendor-Specific)
-# syntax: s = string (UTF-8), d = integer, x = octet string
-# value: attribute value in format indicated by the syntax
-# If syntax and value parts are omitted, a null value (single 0x00 octet) is
-# used.
-#
-# Additional Access-Request attributes
-# radius_auth_req_attr=<attr_id>[:<syntax:value>]
-# Examples:
-# Operator-Name = "Operator"
-#radius_auth_req_attr=126:s:Operator
-# Service-Type = Framed (2)
-#radius_auth_req_attr=6:d:2
-# Connect-Info = "testing" (this overrides the automatically generated value)
-#radius_auth_req_attr=77:s:testing
-# Same Connect-Info value set as a hexdump
-#radius_auth_req_attr=77:x:74657374696e67
-
-#
-# Additional Accounting-Request attributes
-# radius_acct_req_attr=<attr_id>[:<syntax:value>]
-# Examples:
-# Operator-Name = "Operator"
-#radius_acct_req_attr=126:s:Operator
-
-# Dynamic Authorization Extensions (RFC 5176)
-# This mechanism can be used to allow dynamic changes to user session based on
-# commands from a RADIUS server (or some other disconnect client that has the
-# needed session information). For example, Disconnect message can be used to
-# request an associated station to be disconnected.
-#
-# This is disabled by default. Set radius_das_port to non-zero UDP port
-# number to enable.
-#radius_das_port=3799
-#
-# DAS client (the host that can send Disconnect/CoA requests) and shared secret
-#radius_das_client=192.168.1.123 shared secret here
-#
-# DAS Event-Timestamp time window in seconds
-#radius_das_time_window=300
-#
-# DAS require Event-Timestamp
-#radius_das_require_event_timestamp=1
-
-##### RADIUS authentication server configuration ##############################
-
-# hostapd can be used as a RADIUS authentication server for other hosts. This
-# requires that the integrated EAP server is also enabled and both
-# authentication services are sharing the same configuration.
-
-# File name of the RADIUS clients configuration for the RADIUS server. If this
-# commented out, RADIUS server is disabled.
-#radius_server_clients=/etc/hostapd.radius_clients
-
-# The UDP port number for the RADIUS authentication server
-#radius_server_auth_port=1812
-
-# The UDP port number for the RADIUS accounting server
-# Commenting this out or setting this to 0 can be used to disable RADIUS
-# accounting while still enabling RADIUS authentication.
-#radius_server_acct_port=1813
-
-# Use IPv6 with RADIUS server (IPv4 will also be supported using IPv6 API)
-#radius_server_ipv6=1
-
-
-##### WPA/IEEE 802.11i configuration ##########################################
-
-# Enable WPA. Setting this variable configures the AP to require WPA (either
-# WPA-PSK or WPA-RADIUS/EAP based on other configuration). For WPA-PSK, either
-# wpa_psk or wpa_passphrase must be set and wpa_key_mgmt must include WPA-PSK.
-# Instead of wpa_psk / wpa_passphrase, wpa_psk_radius might suffice.
-# For WPA-RADIUS/EAP, ieee8021x must be set (but without dynamic WEP keys),
-# RADIUS authentication server must be configured, and WPA-EAP must be included
-# in wpa_key_mgmt.
-# This field is a bit field that can be used to enable WPA (IEEE 802.11i/D3.0)
-# and/or WPA2 (full IEEE 802.11i/RSN):
-# bit0 = WPA
-# bit1 = IEEE 802.11i/RSN (WPA2) (dot11RSNAEnabled)
-#wpa=1
-
-# WPA pre-shared keys for WPA-PSK. This can be either entered as a 256-bit
-# secret in hex format (64 hex digits), wpa_psk, or as an ASCII passphrase
-# (8..63 characters) that will be converted to PSK. This conversion uses SSID
-# so the PSK changes when ASCII passphrase is used and the SSID is changed.
-# wpa_psk (dot11RSNAConfigPSKValue)
-# wpa_passphrase (dot11RSNAConfigPSKPassPhrase)
-#wpa_psk=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
-#wpa_passphrase=secret passphrase
-
-# Optionally, WPA PSKs can be read from a separate text file (containing list
-# of (PSK,MAC address) pairs. This allows more than one PSK to be configured.
-# Use absolute path name to make sure that the files can be read on SIGHUP
-# configuration reloads.
-#wpa_psk_file=/etc/hostapd.wpa_psk
-
-# Optionally, WPA passphrase can be received from RADIUS authentication server
-# This requires macaddr_acl to be set to 2 (RADIUS)
-# 0 = disabled (default)
-# 1 = optional; use default passphrase/psk if RADIUS server does not include
-#	Tunnel-Password
-# 2 = required; reject authentication if RADIUS server does not include
-#	Tunnel-Password
-#wpa_psk_radius=0
-
-# Set of accepted key management algorithms (WPA-PSK, WPA-EAP, or both). The
-# entries are separated with a space. WPA-PSK-SHA256 and WPA-EAP-SHA256 can be
-# added to enable SHA256-based stronger algorithms.
-# (dot11RSNAConfigAuthenticationSuitesTable)
-#wpa_key_mgmt=WPA-PSK WPA-EAP
-
-# Set of accepted cipher suites (encryption algorithms) for pairwise keys
-# (unicast packets). This is a space separated list of algorithms:
-# CCMP = AES in Counter mode with CBC-MAC [RFC 3610, IEEE 802.11i/D7.0]
-# TKIP = Temporal Key Integrity Protocol [IEEE 802.11i/D7.0]
-# Group cipher suite (encryption algorithm for broadcast and multicast frames)
-# is automatically selected based on this configuration. If only CCMP is
-# allowed as the pairwise cipher, group cipher will also be CCMP. Otherwise,
-# TKIP will be used as the group cipher.
-# (dot11RSNAConfigPairwiseCiphersTable)
-# Pairwise cipher for WPA (v1) (default: TKIP)
-#wpa_pairwise=TKIP CCMP
-# Pairwise cipher for RSN/WPA2 (default: use wpa_pairwise value)
-#rsn_pairwise=CCMP
-
-# Time interval for rekeying GTK (broadcast/multicast encryption keys) in
-# seconds. (dot11RSNAConfigGroupRekeyTime)
-#wpa_group_rekey=600
-
-# Rekey GTK when any STA that possesses the current GTK is leaving the BSS.
-# (dot11RSNAConfigGroupRekeyStrict)
-#wpa_strict_rekey=1
-
-# Time interval for rekeying GMK (master key used internally to generate GTKs
-# (in seconds).
-#wpa_gmk_rekey=86400
-
-# Maximum lifetime for PTK in seconds. This can be used to enforce rekeying of
-# PTK to mitigate some attacks against TKIP deficiencies.
-#wpa_ptk_rekey=600
-
-# Enable IEEE 802.11i/RSN/WPA2 pre-authentication. This is used to speed up
-# roaming be pre-authenticating IEEE 802.1X/EAP part of the full RSN
-# authentication and key handshake before actually associating with a new AP.
-# (dot11RSNAPreauthenticationEnabled)
-#rsn_preauth=1
-#
-# Space separated list of interfaces from which pre-authentication frames are
-# accepted (e.g., 'eth0' or 'eth0 wlan0wds0'. This list should include all
-# interface that are used for connections to other APs. This could include
-# wired interfaces and WDS links. The normal wireless data interface towards
-# associated stations (e.g., wlan0) should not be added, since
-# pre-authentication is only used with APs other than the currently associated
-# one.
-#rsn_preauth_interfaces=eth0
-
-# peerkey: Whether PeerKey negotiation for direct links (IEEE 802.11e) is
-# allowed. This is only used with RSN/WPA2.
-# 0 = disabled (default)
-# 1 = enabled
-#peerkey=1
-
-# ieee80211w: Whether management frame protection (MFP) is enabled
-# 0 = disabled (default)
-# 1 = optional
-# 2 = required
-#ieee80211w=0
-
-# Group management cipher suite
-# Default: AES-128-CMAC (BIP)
-# Other options (depending on driver support):
-# BIP-GMAC-128
-# BIP-GMAC-256
-# BIP-CMAC-256
-# Note: All the stations connecting to the BSS will also need to support the
-# selected cipher. The default AES-128-CMAC is the only option that is commonly
-# available in deployed devices.
-#group_mgmt_cipher=AES-128-CMAC
-
-# Association SA Query maximum timeout (in TU = 1.024 ms; for MFP)
-# (maximum time to wait for a SA Query response)
-# dot11AssociationSAQueryMaximumTimeout, 1...4294967295
-#assoc_sa_query_max_timeout=1000
-
-# Association SA Query retry timeout (in TU = 1.024 ms; for MFP)
-# (time between two subsequent SA Query requests)
-# dot11AssociationSAQueryRetryTimeout, 1...4294967295
-#assoc_sa_query_retry_timeout=201
-
-# disable_pmksa_caching: Disable PMKSA caching
-# This parameter can be used to disable caching of PMKSA created through EAP
-# authentication. RSN preauthentication may still end up using PMKSA caching if
-# it is enabled (rsn_preauth=1).
-# 0 = PMKSA caching enabled (default)
-# 1 = PMKSA caching disabled
-#disable_pmksa_caching=0
-
-# okc: Opportunistic Key Caching (aka Proactive Key Caching)
-# Allow PMK cache to be shared opportunistically among configured interfaces
-# and BSSes (i.e., all configurations within a single hostapd process).
-# 0 = disabled (default)
-# 1 = enabled
-#okc=1
-
-# SAE threshold for anti-clogging mechanism (dot11RSNASAEAntiCloggingThreshold)
-# This parameter defines how many open SAE instances can be in progress at the
-# same time before the anti-clogging mechanism is taken into use.
-#sae_anti_clogging_threshold=5
-
-# Enabled SAE finite cyclic groups
-# SAE implementation are required to support group 19 (ECC group defined over a
-# 256-bit prime order field). All groups that are supported by the
-# implementation are enabled by default. This configuration parameter can be
-# used to specify a limited set of allowed groups. The group values are listed
-# in the IANA registry:
-# http://www.iana.org/assignments/ipsec-registry/ipsec-registry.xml#ipsec-registry-9
-#sae_groups=19 20 21 25 26
-
-##### IEEE 802.11r configuration ##############################################
-
-# Mobility Domain identifier (dot11FTMobilityDomainID, MDID)
-# MDID is used to indicate a group of APs (within an ESS, i.e., sharing the
-# same SSID) between which a STA can use Fast BSS Transition.
-# 2-octet identifier as a hex string.
-#mobility_domain=a1b2
-
-# PMK-R0 Key Holder identifier (dot11FTR0KeyHolderID)
-# 1 to 48 octet identifier.
-# This is configured with nas_identifier (see RADIUS client section above).
-
-# Default lifetime of the PMK-RO in minutes; range 1..65535
-# (dot11FTR0KeyLifetime)
-#r0_key_lifetime=10000
-
-# PMK-R1 Key Holder identifier (dot11FTR1KeyHolderID)
-# 6-octet identifier as a hex string.
-#r1_key_holder=000102030405
-
-# Reassociation deadline in time units (TUs / 1.024 ms; range 1000..65535)
-# (dot11FTReassociationDeadline)
-#reassociation_deadline=1000
-
-# List of R0KHs in the same Mobility Domain
-# format: <MAC address> <NAS Identifier> <128-bit key as hex string>
-# This list is used to map R0KH-ID (NAS Identifier) to a destination MAC
-# address when requesting PMK-R1 key from the R0KH that the STA used during the
-# Initial Mobility Domain Association.
-#r0kh=02:01:02:03:04:05 r0kh-1.example.com 000102030405060708090a0b0c0d0e0f
-#r0kh=02:01:02:03:04:06 r0kh-2.example.com 00112233445566778899aabbccddeeff
-# And so on.. One line per R0KH.
-
-# List of R1KHs in the same Mobility Domain
-# format: <MAC address> <R1KH-ID> <128-bit key as hex string>
-# This list is used to map R1KH-ID to a destination MAC address when sending
-# PMK-R1 key from the R0KH. This is also the list of authorized R1KHs in the MD
-# that can request PMK-R1 keys.
-#r1kh=02:01:02:03:04:05 02:11:22:33:44:55 000102030405060708090a0b0c0d0e0f
-#r1kh=02:01:02:03:04:06 02:11:22:33:44:66 00112233445566778899aabbccddeeff
-# And so on.. One line per R1KH.
-
-# Whether PMK-R1 push is enabled at R0KH
-# 0 = do not push PMK-R1 to all configured R1KHs (default)
-# 1 = push PMK-R1 to all configured R1KHs whenever a new PMK-R0 is derived
-#pmk_r1_push=1
-
-##### Neighbor table ##########################################################
-# Maximum number of entries kept in AP table (either for neigbor table or for
-# detecting Overlapping Legacy BSS Condition). The oldest entry will be
-# removed when adding a new entry that would make the list grow over this
-# limit. Note! WFA certification for IEEE 802.11g requires that OLBC is
-# enabled, so this field should not be set to 0 when using IEEE 802.11g.
-# default: 255
-#ap_table_max_size=255
-
-# Number of seconds of no frames received after which entries may be deleted
-# from the AP table. Since passive scanning is not usually performed frequently
-# this should not be set to very small value. In addition, there is no
-# guarantee that every scan cycle will receive beacon frames from the
-# neighboring APs.
-# default: 60
-#ap_table_expiration_time=3600
-
-
-##### Wi-Fi Protected Setup (WPS) #############################################
-
-# WPS state
-# 0 = WPS disabled (default)
-# 1 = WPS enabled, not configured
-# 2 = WPS enabled, configured
-#wps_state=2
-
-# Whether to manage this interface independently from other WPS interfaces
-# By default, a single hostapd process applies WPS operations to all configured
-# interfaces. This parameter can be used to disable that behavior for a subset
-# of interfaces. If this is set to non-zero for an interface, WPS commands
-# issued on that interface do not apply to other interfaces and WPS operations
-# performed on other interfaces do not affect this interface.
-#wps_independent=0
-
-# AP can be configured into a locked state where new WPS Registrar are not
-# accepted, but previously authorized Registrars (including the internal one)
-# can continue to add new Enrollees.
-#ap_setup_locked=1
-
-# Universally Unique IDentifier (UUID; see RFC 4122) of the device
-# This value is used as the UUID for the internal WPS Registrar. If the AP
-# is also using UPnP, this value should be set to the device's UPnP UUID.
-# If not configured, UUID will be generated based on the local MAC address.
-#uuid=12345678-9abc-def0-1234-56789abcdef0
-
-# Note: If wpa_psk_file is set, WPS is used to generate random, per-device PSKs
-# that will be appended to the wpa_psk_file. If wpa_psk_file is not set, the
-# default PSK (wpa_psk/wpa_passphrase) will be delivered to Enrollees. Use of
-# per-device PSKs is recommended as the more secure option (i.e., make sure to
-# set wpa_psk_file when using WPS with WPA-PSK).
-
-# When an Enrollee requests access to the network with PIN method, the Enrollee
-# PIN will need to be entered for the Registrar. PIN request notifications are
-# sent to hostapd ctrl_iface monitor. In addition, they can be written to a
-# text file that could be used, e.g., to populate the AP administration UI with
-# pending PIN requests. If the following variable is set, the PIN requests will
-# be written to the configured file.
-#wps_pin_requests=/var/run/hostapd_wps_pin_requests
-
-# Device Name
-# User-friendly description of device; up to 32 octets encoded in UTF-8
-#device_name=Wireless AP
-
-# Manufacturer
-# The manufacturer of the device (up to 64 ASCII characters)
-#manufacturer=Company
-
-# Model Name
-# Model of the device (up to 32 ASCII characters)
-#model_name=WAP
-
-# Model Number
-# Additional device description (up to 32 ASCII characters)
-#model_number=123
-
-# Serial Number
-# Serial number of the device (up to 32 characters)
-#serial_number=12345
-
-# Primary Device Type
-# Used format: <categ>-<OUI>-<subcateg>
-# categ = Category as an integer value
-# OUI = OUI and type octet as a 4-octet hex-encoded value; 0050F204 for
-#       default WPS OUI
-# subcateg = OUI-specific Sub Category as an integer value
-# Examples:
-#   1-0050F204-1 (Computer / PC)
-#   1-0050F204-2 (Computer / Server)
-#   5-0050F204-1 (Storage / NAS)
-#   6-0050F204-1 (Network Infrastructure / AP)
-#device_type=6-0050F204-1
-
-# OS Version
-# 4-octet operating system version number (hex string)
-#os_version=01020300
-
-# Config Methods
-# List of the supported configuration methods
-# Available methods: usba ethernet label display ext_nfc_token int_nfc_token
-#	nfc_interface push_button keypad virtual_display physical_display
-#	virtual_push_button physical_push_button
-#config_methods=label virtual_display virtual_push_button keypad
-
-# WPS capability discovery workaround for PBC with Windows 7
-# Windows 7 uses incorrect way of figuring out AP's WPS capabilities by acting
-# as a Registrar and using M1 from the AP. The config methods attribute in that
-# message is supposed to indicate only the configuration method supported by
-# the AP in Enrollee role, i.e., to add an external Registrar. For that case,
-# PBC shall not be used and as such, the PushButton config method is removed
-# from M1 by default. If pbc_in_m1=1 is included in the configuration file,
-# the PushButton config method is left in M1 (if included in config_methods
-# parameter) to allow Windows 7 to use PBC instead of PIN (e.g., from a label
-# in the AP).
-#pbc_in_m1=1
-
-# Static access point PIN for initial configuration and adding Registrars
-# If not set, hostapd will not allow external WPS Registrars to control the
-# access point. The AP PIN can also be set at runtime with hostapd_cli
-# wps_ap_pin command. Use of temporary (enabled by user action) and random
-# AP PIN is much more secure than configuring a static AP PIN here. As such,
-# use of the ap_pin parameter is not recommended if the AP device has means for
-# displaying a random PIN.
-#ap_pin=12345670
-
-# Skip building of automatic WPS credential
-# This can be used to allow the automatically generated Credential attribute to
-# be replaced with pre-configured Credential(s).
-#skip_cred_build=1
-
-# Additional Credential attribute(s)
-# This option can be used to add pre-configured Credential attributes into M8
-# message when acting as a Registrar. If skip_cred_build=1, this data will also
-# be able to override the Credential attribute that would have otherwise been
-# automatically generated based on network configuration. This configuration
-# option points to an external file that much contain the WPS Credential
-# attribute(s) as binary data.
-#extra_cred=hostapd.cred
-
-# Credential processing
-#   0 = process received credentials internally (default)
-#   1 = do not process received credentials; just pass them over ctrl_iface to
-#	external program(s)
-#   2 = process received credentials internally and pass them over ctrl_iface
-#	to external program(s)
-# Note: With wps_cred_processing=1, skip_cred_build should be set to 1 and
-# extra_cred be used to provide the Credential data for Enrollees.
-#
-# wps_cred_processing=1 will disabled automatic updates of hostapd.conf file
-# both for Credential processing and for marking AP Setup Locked based on
-# validation failures of AP PIN. An external program is responsible on updating
-# the configuration appropriately in this case.
-#wps_cred_processing=0
-
-# AP Settings Attributes for M7
-# By default, hostapd generates the AP Settings Attributes for M7 based on the
-# current configuration. It is possible to override this by providing a file
-# with pre-configured attributes. This is similar to extra_cred file format,
-# but the AP Settings attributes are not encapsulated in a Credential
-# attribute.
-#ap_settings=hostapd.ap_settings
-
-# WPS UPnP interface
-# If set, support for external Registrars is enabled.
-#upnp_iface=br0
-
-# Friendly Name (required for UPnP)
-# Short description for end use. Should be less than 64 characters.
-#friendly_name=WPS Access Point
-
-# Manufacturer URL (optional for UPnP)
-#manufacturer_url=http://www.example.com/
-
-# Model Description (recommended for UPnP)
-# Long description for end user. Should be less than 128 characters.
-#model_description=Wireless Access Point
-
-# Model URL (optional for UPnP)
-#model_url=http://www.example.com/model/
-
-# Universal Product Code (optional for UPnP)
-# 12-digit, all-numeric code that identifies the consumer package.
-#upc=123456789012
-
-# WPS RF Bands (a = 5G, b = 2.4G, g = 2.4G, ag = dual band)
-# This value should be set according to RF band(s) supported by the AP if
-# hw_mode is not set. For dual band dual concurrent devices, this needs to be
-# set to ag to allow both RF bands to be advertized.
-#wps_rf_bands=ag
-
-# NFC password token for WPS
-# These parameters can be used to configure a fixed NFC password token for the
-# AP. This can be generated, e.g., with nfc_pw_token from wpa_supplicant. When
-# these parameters are used, the AP is assumed to be deployed with a NFC tag
-# that includes the matching NFC password token (e.g., written based on the
-# NDEF record from nfc_pw_token).
-#
-#wps_nfc_dev_pw_id: Device Password ID (16..65535)
-#wps_nfc_dh_pubkey: Hexdump of DH Public Key
-#wps_nfc_dh_privkey: Hexdump of DH Private Key
-#wps_nfc_dev_pw: Hexdump of Device Password
-
-##### Wi-Fi Direct (P2P) ######################################################
-
-# Enable P2P Device management
-#manage_p2p=1
-
-# Allow cross connection
-#allow_cross_connection=1
-
-#### TDLS (IEEE 802.11z-2010) #################################################
-
-# Prohibit use of TDLS in this BSS
-#tdls_prohibit=1
-
-# Prohibit use of TDLS Channel Switching in this BSS
-#tdls_prohibit_chan_switch=1
-
-##### IEEE 802.11v-2011 #######################################################
-
-# Time advertisement
-# 0 = disabled (default)
-# 2 = UTC time at which the TSF timer is 0
-#time_advertisement=2
-
-# Local time zone as specified in 8.3 of IEEE Std 1003.1-2004:
-# stdoffset[dst[offset][,start[/time],end[/time]]]
-#time_zone=EST5
-
-# WNM-Sleep Mode (extended sleep mode for stations)
-# 0 = disabled (default)
-# 1 = enabled (allow stations to use WNM-Sleep Mode)
-#wnm_sleep_mode=1
-
-# BSS Transition Management
-# 0 = disabled (default)
-# 1 = enabled
-#bss_transition=1
-
-##### IEEE 802.11u-2011 #######################################################
-
-# Enable Interworking service
-#interworking=1
-
-# Access Network Type
-# 0 = Private network
-# 1 = Private network with guest access
-# 2 = Chargeable public network
-# 3 = Free public network
-# 4 = Personal device network
-# 5 = Emergency services only network
-# 14 = Test or experimental
-# 15 = Wildcard
-#access_network_type=0
-
-# Whether the network provides connectivity to the Internet
-# 0 = Unspecified
-# 1 = Network provides connectivity to the Internet
-#internet=1
-
-# Additional Step Required for Access
-# Note: This is only used with open network, i.e., ASRA shall ne set to 0 if
-# RSN is used.
-#asra=0
-
-# Emergency services reachable
-#esr=0
-
-# Unauthenticated emergency service accessible
-#uesa=0
-
-# Venue Info (optional)
-# The available values are defined in IEEE Std 802.11u-2011, 7.3.1.34.
-# Example values (group,type):
-# 0,0 = Unspecified
-# 1,7 = Convention Center
-# 1,13 = Coffee Shop
-# 2,0 = Unspecified Business
-# 7,1  Private Residence
-#venue_group=7
-#venue_type=1
-
-# Homogeneous ESS identifier (optional; dot11HESSID)
-# If set, this shall be identifical to one of the BSSIDs in the homogeneous
-# ESS and this shall be set to the same value across all BSSs in homogeneous
-# ESS.
-#hessid=02:03:04:05:06:07
-
-# Roaming Consortium List
-# Arbitrary number of Roaming Consortium OIs can be configured with each line
-# adding a new OI to the list. The first three entries are available through
-# Beacon and Probe Response frames. Any additional entry will be available only
-# through ANQP queries. Each OI is between 3 and 15 octets and is configured as
-# a hexstring.
-#roaming_consortium=021122
-#roaming_consortium=2233445566
-
-# Venue Name information
-# This parameter can be used to configure one or more Venue Name Duples for
-# Venue Name ANQP information. Each entry has a two or three character language
-# code (ISO-639) separated by colon from the venue name string.
-# Note that venue_group and venue_type have to be set for Venue Name
-# information to be complete.
-#venue_name=eng:Example venue
-#venue_name=fin:Esimerkkipaikka
-# Alternative format for language:value strings:
-# (double quoted string, printf-escaped string)
-#venue_name=P"eng:Example\nvenue"
-
-# Network Authentication Type
-# This parameter indicates what type of network authentication is used in the
-# network.
-# format: <network auth type indicator (1-octet hex str)> [redirect URL]
-# Network Authentication Type Indicator values:
-# 00 = Acceptance of terms and conditions
-# 01 = On-line enrollment supported
-# 02 = http/https redirection
-# 03 = DNS redirection
-#network_auth_type=00
-#network_auth_type=02http://www.example.com/redirect/me/here/
-
-# IP Address Type Availability
-# format: <1-octet encoded value as hex str>
-# (ipv4_type & 0x3f) << 2 | (ipv6_type & 0x3)
-# ipv4_type:
-# 0 = Address type not available
-# 1 = Public IPv4 address available
-# 2 = Port-restricted IPv4 address available
-# 3 = Single NATed private IPv4 address available
-# 4 = Double NATed private IPv4 address available
-# 5 = Port-restricted IPv4 address and single NATed IPv4 address available
-# 6 = Port-restricted IPv4 address and double NATed IPv4 address available
-# 7 = Availability of the address type is not known
-# ipv6_type:
-# 0 = Address type not available
-# 1 = Address type available
-# 2 = Availability of the address type not known
-#ipaddr_type_availability=14
-
-# Domain Name
-# format: <variable-octet str>[,<variable-octet str>]
-#domain_name=example.com,another.example.com,yet-another.example.com
-
-# 3GPP Cellular Network information
-# format: <MCC1,MNC1>[;<MCC2,MNC2>][;...]
-#anqp_3gpp_cell_net=244,91;310,026;234,56
-
-# NAI Realm information
-# One or more realm can be advertised. Each nai_realm line adds a new realm to
-# the set. These parameters provide information for stations using Interworking
-# network selection to allow automatic connection to a network based on
-# credentials.
-# format: <encoding>,<NAI Realm(s)>[,<EAP Method 1>][,<EAP Method 2>][,...]
-# encoding:
-#	0 = Realm formatted in accordance with IETF RFC 4282
-#	1 = UTF-8 formatted character string that is not formatted in
-#	    accordance with IETF RFC 4282
-# NAI Realm(s): Semi-colon delimited NAI Realm(s)
-# EAP Method: <EAP Method>[:<[AuthParam1:Val1]>][<[AuthParam2:Val2]>][...]
-# EAP Method types, see:
-# http://www.iana.org/assignments/eap-numbers/eap-numbers.xhtml#eap-numbers-4
-# AuthParam (Table 8-188 in IEEE Std 802.11-2012):
-# ID 2 = Non-EAP Inner Authentication Type
-#	1 = PAP, 2 = CHAP, 3 = MSCHAP, 4 = MSCHAPV2
-# ID 3 = Inner authentication EAP Method Type
-# ID 5 = Credential Type
-#	1 = SIM, 2 = USIM, 3 = NFC Secure Element, 4 = Hardware Token,
-#	5 = Softoken, 6 = Certificate, 7 = username/password, 9 = Anonymous,
-#	10 = Vendor Specific
-#nai_realm=0,example.com;example.net
-# EAP methods EAP-TLS with certificate and EAP-TTLS/MSCHAPv2 with
-# username/password
-#nai_realm=0,example.org,13[5:6],21[2:4][5:7]
-
-# QoS Map Set configuration
-#
-# Comma delimited QoS Map Set in decimal values
-# (see IEEE Std 802.11-2012, 8.4.2.97)
-#
-# format:
-# [<DSCP Exceptions[DSCP,UP]>,]<UP 0 range[low,high]>,...<UP 7 range[low,high]>
-#
-# There can be up to 21 optional DSCP Exceptions which are pairs of DSCP Value
-# (0..63 or 255) and User Priority (0..7). This is followed by eight DSCP Range
-# descriptions with DSCP Low Value and DSCP High Value pairs (0..63 or 255) for
-# each UP starting from 0. If both low and high value are set to 255, the
-# corresponding UP is not used.
-#
-# default: not set
-#qos_map_set=53,2,22,6,8,15,0,7,255,255,16,31,32,39,255,255,40,47,255,255
-
-##### Hotspot 2.0 #############################################################
-
-# Enable Hotspot 2.0 support
-#hs20=1
-
-# Disable Downstream Group-Addressed Forwarding (DGAF)
-# This can be used to configure a network where no group-addressed frames are
-# allowed. The AP will not forward any group-address frames to the stations and
-# random GTKs are issued for each station to prevent associated stations from
-# forging such frames to other stations in the BSS.
-#disable_dgaf=1
-
-# OSU Server-Only Authenticated L2 Encryption Network
-#osen=1
-
-# ANQP Domain ID (0..65535)
-# An identifier for a set of APs in an ESS that share the same common ANQP
-# information. 0 = Some of the ANQP information is unique to this AP (default).
-#anqp_domain_id=1234
-
-# Deauthentication request timeout
-# If the RADIUS server indicates that the station is not allowed to connect to
-# the BSS/ESS, the AP can allow the station some time to download a
-# notification page (URL included in the message). This parameter sets that
-# timeout in seconds.
-#hs20_deauth_req_timeout=60
-
-# Operator Friendly Name
-# This parameter can be used to configure one or more Operator Friendly Name
-# Duples. Each entry has a two or three character language code (ISO-639)
-# separated by colon from the operator friendly name string.
-#hs20_oper_friendly_name=eng:Example operator
-#hs20_oper_friendly_name=fin:Esimerkkioperaattori
-
-# Connection Capability
-# This can be used to advertise what type of IP traffic can be sent through the
-# hotspot (e.g., due to firewall allowing/blocking protocols/ports).
-# format: <IP Protocol>:<Port Number>:<Status>
-# IP Protocol: 1 = ICMP, 6 = TCP, 17 = UDP
-# Port Number: 0..65535
-# Status: 0 = Closed, 1 = Open, 2 = Unknown
-# Each hs20_conn_capab line is added to the list of advertised tuples.
-#hs20_conn_capab=1:0:2
-#hs20_conn_capab=6:22:1
-#hs20_conn_capab=17:5060:0
-
-# WAN Metrics
-# format: <WAN Info>:<DL Speed>:<UL Speed>:<DL Load>:<UL Load>:<LMD>
-# WAN Info: B0-B1: Link Status, B2: Symmetric Link, B3: At Capabity
-#    (encoded as two hex digits)
-#    Link Status: 1 = Link up, 2 = Link down, 3 = Link in test state
-# Downlink Speed: Estimate of WAN backhaul link current downlink speed in kbps;
-#	1..4294967295; 0 = unknown
-# Uplink Speed: Estimate of WAN backhaul link current uplink speed in kbps
-#	1..4294967295; 0 = unknown
-# Downlink Load: Current load of downlink WAN connection (scaled to 255 = 100%)
-# Uplink Load: Current load of uplink WAN connection (scaled to 255 = 100%)
-# Load Measurement Duration: Duration for measuring downlink/uplink load in
-# tenths of a second (1..65535); 0 if load cannot be determined
-#hs20_wan_metrics=01:8000:1000:80:240:3000
-
-# Operating Class Indication
-# List of operating classes the BSSes in this ESS use. The Global operating
-# classes in Table E-4 of IEEE Std 802.11-2012 Annex E define the values that
-# can be used in this.
-# format: hexdump of operating class octets
-# for example, operating classes 81 (2.4 GHz channels 1-13) and 115 (5 GHz
-# channels 36-48):
-#hs20_operating_class=5173
-
-# OSU icons
-# <Icon Width>:<Icon Height>:<Language code>:<Icon Type>:<Name>:<file path>
-#hs20_icon=32:32:eng:image/png:icon32:/tmp/icon32.png
-#hs20_icon=64:64:eng:image/png:icon64:/tmp/icon64.png
-
-# OSU SSID (see ssid2 for format description)
-# This is the SSID used for all OSU connections to all the listed OSU Providers.
-#osu_ssid="example"
-
-# OSU Providers
-# One or more sets of following parameter. Each OSU provider is started by the
-# mandatory osu_server_uri item. The other parameters add information for the
-# last added OSU provider.
-#
-#osu_server_uri=https://example.com/osu/
-#osu_friendly_name=eng:Example operator
-#osu_friendly_name=fin:Esimerkkipalveluntarjoaja
-#osu_nai=anonymous@example.com
-#osu_method_list=1 0
-#osu_icon=icon32
-#osu_icon=icon64
-#osu_service_desc=eng:Example services
-#osu_service_desc=fin:Esimerkkipalveluja
-#
-#osu_server_uri=...
-
-##### TESTING OPTIONS #########################################################
-#
-# The options in this section are only available when the build configuration
-# option CONFIG_TESTING_OPTIONS is set while compiling hostapd. They allow
-# testing some scenarios that are otherwise difficult to reproduce.
-#
-# Ignore probe requests sent to hostapd with the given probability, must be a
-# floating point number in the range [0, 1).
-#ignore_probe_probability=0.0
-#
-# Ignore authentication frames with the given probability
-#ignore_auth_probability=0.0
-#
-# Ignore association requests with the given probability
-#ignore_assoc_probability=0.0
-#
-# Ignore reassociation requests with the given probability
-#ignore_reassoc_probability=0.0
-#
-# Corrupt Key MIC in GTK rekey EAPOL-Key frames with the given probability
-#corrupt_gtk_rekey_mic_probability=0.0
-
-##### Multiple BSSID support ##################################################
-#
-# Above configuration is using the default interface (wlan#, or multi-SSID VLAN
-# interfaces). Other BSSIDs can be added by using separator 'bss' with
-# default interface name to be allocated for the data packets of the new BSS.
-#
-# hostapd will generate BSSID mask based on the BSSIDs that are
-# configured. hostapd will verify that dev_addr & MASK == dev_addr. If this is
-# not the case, the MAC address of the radio must be changed before starting
-# hostapd (ifconfig wlan0 hw ether <MAC addr>). If a BSSID is configured for
-# every secondary BSS, this limitation is not applied at hostapd and other
-# masks may be used if the driver supports them (e.g., swap the locally
-# administered bit)
-#
-# BSSIDs are assigned in order to each BSS, unless an explicit BSSID is
-# specified using the 'bssid' parameter.
-# If an explicit BSSID is specified, it must be chosen such that it:
-# - results in a valid MASK that covers it and the dev_addr
-# - is not the same as the MAC address of the radio
-# - is not the same as any other explicitly specified BSSID
-#
-# Not all drivers support multiple BSSes. The exact mechanism for determining
-# the driver capabilities is driver specific. With the current (i.e., a recent
-# kernel) drivers using nl80211, this information can be checked with "iw list"
-# (search for "valid interface combinations").
-#
-# Please note that hostapd uses some of the values configured for the first BSS
-# as the defaults for the following BSSes. However, it is recommended that all
-# BSSes include explicit configuration of all relevant configuration items.
-#
-#bss=wlan0_0
-#ssid=test2
-# most of the above items can be used here (apart from radio interface specific
-# items, like channel)
-
-#bss=wlan0_1
-#bssid=00:13:10:95:fe:0b
-# ...
diff --git a/device/generic/goldfish/wifi/wifi_hal/Android.mk b/device/generic/goldfish/wifi/wifi_hal/Android.mk
index 9ca600e..aeb4143 100644
--- a/device/generic/goldfish/wifi/wifi_hal/Android.mk
+++ b/device/generic/goldfish/wifi/wifi_hal/Android.mk
@@ -38,7 +38,7 @@ LOCAL_SHARED_LIBRARIES += \
 LOCAL_HEADER_LIBRARIES += \
 	libcutils_headers \
 
-LOCAL_MODULE := libwifi-hal-emu
+LOCAL_MODULE := libwifi-hal-brcmfmac
 LOCAL_PROPRIETARY_MODULE := true
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/device/generic/goldfish/wifi/wpa_supplicant_8_lib/Android.mk b/device/generic/goldfish/wifi/wpa_supplicant_8_lib/Android.mk
deleted file mode 100644
index d6ee953..0000000
--- a/device/generic/goldfish/wifi/wpa_supplicant_8_lib/Android.mk
+++ /dev/null
@@ -1,84 +0,0 @@
-#
-# Copyright (C) 2008 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-LOCAL_PATH := $(call my-dir)
-
-ifeq ($(WPA_SUPPLICANT_VERSION),VER_0_8_X)
-
-ifneq ($(BOARD_WPA_SUPPLICANT_DRIVER),)
-  CONFIG_DRIVER_$(BOARD_WPA_SUPPLICANT_DRIVER) := y
-endif
-
-# Use a custom libnl on releases before N
-ifeq (0, $(shell test $(PLATFORM_SDK_VERSION) -lt 24; echo $$?))
-EXTERNAL_GCE_LIBNL_INCLUDE := external/gce/libnl/include
-else
-EXTERNAL_GCE_LIBNL_INCLUDE :=
-endif
-
-
-WPA_SUPPL_DIR = external/wpa_supplicant_8
-WPA_SRC_FILE :=
-
-include $(WPA_SUPPL_DIR)/wpa_supplicant/android.config
-
-WPA_SUPPL_DIR_INCLUDE = $(WPA_SUPPL_DIR)/src \
-	$(WPA_SUPPL_DIR)/src/common \
-	$(WPA_SUPPL_DIR)/src/drivers \
-	$(WPA_SUPPL_DIR)/src/l2_packet \
-	$(WPA_SUPPL_DIR)/src/utils \
-	$(WPA_SUPPL_DIR)/src/wps \
-	$(WPA_SUPPL_DIR)/wpa_supplicant \
-	$(EXTERNAL_GCE_LIBNL_INCLUDE)
-
-WPA_SUPPL_DIR_INCLUDE += external/libnl/include
-
-ifdef CONFIG_DRIVER_NL80211
-WPA_SRC_FILE += driver_cmd_nl80211.c
-endif
-
-ifeq ($(TARGET_ARCH),arm)
-# To force sizeof(enum) = 4
-L_CFLAGS += -mabi=aapcs-linux
-endif
-
-ifdef CONFIG_ANDROID_LOG
-L_CFLAGS += -DCONFIG_ANDROID_LOG
-endif
-
-L_CFLAGS += -Wno-unused-parameter
-
-########################
-
-include $(CLEAR_VARS)
-LOCAL_MODULE := lib_driver_cmd_simulated
-LOCAL_VENDOR_MODULE := true
-LOCAL_SHARED_LIBRARIES := libc libcutils liblog
-LOCAL_HEADER_LIBRARIES := libcutils_headers
-
-LOCAL_CFLAGS := $(L_CFLAGS) \
-    $(GCE_VERSION_CFLAGS)
-
-LOCAL_SRC_FILES := $(WPA_SRC_FILE)
-
-LOCAL_C_INCLUDES := \
-  device/google/gce/include \
-  $(WPA_SUPPL_DIR_INCLUDE)\
-
-include $(BUILD_STATIC_LIBRARY)
-
-########################
-
-endif
diff --git a/device/generic/goldfish/wifi/wpa_supplicant_8_lib/driver_cmd_nl80211.c b/device/generic/goldfish/wifi/wpa_supplicant_8_lib/driver_cmd_nl80211.c
deleted file mode 100644
index 9589e85..0000000
--- a/device/generic/goldfish/wifi/wpa_supplicant_8_lib/driver_cmd_nl80211.c
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Driver interaction with extended Linux CFG8021
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * Alternatively, this software may be distributed under the terms of BSD
- * license.
- */
-
-#include "driver_cmd_nl80211.h"
-
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-//#if GCE_PLATFORM_SDK_AFTER(L_MR1)
-// Android M exposes headers more directly.
-#include <netinet/in.h>
-#include <linux/if.h>
-#include "driver_nl80211.h"
-/*
-#elif GCE_PLATFORM_SDK_AFTER(J_MR2)
-// Android versions K and L put structures in hardware_legacy
-#include "hardware_legacy/driver_nl80211.h"
-#else
-// Android version J does not expose structures directly. These structures are
-// manually defined later.
-#include <netinet/in.h>
-#include <linux/if.h>
-#endif
-*/
-
-#include "common.h"
-#include "wpa_supplicant_i.h"
-#include "config.h"
-#include "android_drv.h"
-#include "linux_ioctl.h"
-
-
-int wpa_driver_nl80211_driver_cmd(
-    void* priv, char* cmd, char* buf, size_t buf_len) {
-  struct i802_bss* bss = priv;
-  struct wpa_driver_nl80211_data* drv = bss->drv;
-  int ret = 0;
-
-  D("%s: called", __FUNCTION__);
-  if (os_strcasecmp(cmd, "STOP") == 0) {
-    linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 0);
-    wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STOPPED");
-  } else if (os_strcasecmp(cmd, "START") == 0) {
-    linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
-    wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "STARTED");
-  } else if (os_strcasecmp(cmd, "MACADDR") == 0) {
-    u8 macaddr[ETH_ALEN] = {};
-
-    ret = linux_get_ifhwaddr(drv->global->ioctl_sock, bss->ifname, macaddr);
-    if (!ret)
-      ret = os_snprintf(
-          buf, buf_len, "Macaddr = " MACSTR "\n", MAC2STR(macaddr));
-  } else if (os_strcasecmp(cmd, "RELOAD") == 0) {
-    wpa_msg(drv->ctx, MSG_INFO, WPA_EVENT_DRIVER_STATE "HANGED");
-  } else {  // Use private command
-    return 0;
-  }
-  return ret;
-}
-
-
-int wpa_driver_set_p2p_noa(
-    __attribute__((__unused__)) void* priv,
-    __attribute__((__unused__)) u8 count,
-    __attribute__((__unused__)) int start,
-    __attribute__((__unused__)) int duration) {
-  D("%s: called", __FUNCTION__);
-  return 0;
-}
-
-
-int wpa_driver_get_p2p_noa(
-    __attribute__((__unused__)) void* priv,
-    __attribute__((__unused__)) u8* buf,
-    __attribute__((__unused__)) size_t len) {
-  D("%s: called", __FUNCTION__);
-  return 0;
-}
-
-
-int wpa_driver_set_p2p_ps(
-    __attribute__((__unused__)) void* priv,
-    __attribute__((__unused__)) int legacy_ps,
-    __attribute__((__unused__)) int opp_ps,
-    __attribute__((__unused__)) int ctwindow) {
-  D("%s: called", __FUNCTION__);
-  return -1;
-}
-
-
-int wpa_driver_set_ap_wps_p2p_ie(
-    __attribute__((__unused__)) void* priv,
-    __attribute__((__unused__)) const struct wpabuf* beacon,
-    __attribute__((__unused__)) const struct wpabuf* proberesp,
-    __attribute__((__unused__)) const struct wpabuf* assocresp) {
-  D("%s: called", __FUNCTION__);
-  return 0;
-}
diff --git a/device/generic/goldfish/wifi/wpa_supplicant_8_lib/driver_cmd_nl80211.h b/device/generic/goldfish/wifi/wpa_supplicant_8_lib/driver_cmd_nl80211.h
deleted file mode 100644
index f879596..0000000
--- a/device/generic/goldfish/wifi/wpa_supplicant_8_lib/driver_cmd_nl80211.h
+++ /dev/null
@@ -1,97 +0,0 @@
-#ifndef __DEVICE_GOOGLE_GCE_WPA_SUPPLICANT_8_H__
-#define __DEVICE_GOOGLE_GCE_WPA_SUPPLICANT_8_H__
-
-#include <stddef.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "common.h"
-#include "wpa_supplicant_i.h"
-
-#define LOG_TAG "GceWpaSupplicant8Driver"
-
-#include "log/log.h"
-
-/*
-#define GCE_WPA_SUPPLICANT_DEBUG 0
-*/
-
-#if GCE_WPA_SUPPLICANT_DEBUG
-#  define D(...) ALOGD(__VA_ARGS__)
-#else
-#  define D(...) ((void)0)
-#endif
-
-
-typedef struct android_wifi_priv_cmd {
-  char* buf;
-  int used_len;
-  int total_len;
-} android_wifi_priv_cmd;
-
-/*
-#if GCE_PLATFORM_SDK_BEFORE(K)
-
-#include "driver.h"
-#include "linux_ioctl.h"
-
-struct i802_bss {
-  struct wpa_driver_nl80211_data* drv;
-  struct i802_bss* next;
-  int ifindex;
-  char ifname[IFNAMSIZ + 1];
-  char brname[IFNAMSIZ];
-
-  unsigned int beacon_set:1;
-  unsigned int added_if_into_bridge:1;
-  unsigned int added_bridge:1;
-  unsigned int in_deinit:1;
-
-  u8 addr[ETH_ALEN];
-
-  int freq;
-
-  void* ctx;
-  struct nl_handle* nl_preq;
-  struct nl_handle* nl_mgmt;
-  struct nl_cb* nl_cb;
-
-  struct nl80211_wiphy_data *wiphy_data;
-  struct dl_list wiphy_list;
-};
-
-struct nl80211_global {
-  struct dl_list interfaces;
-  int if_add_ifindex;
-  struct netlink_data *netlink;
-  struct nl_cb* nl_cb;
-  struct nl_handle* nl;
-  int nl80211_id;
-  int ioctl_sock;  // socket for ioctl() use
-
-  struct nl_handle* nl_event;
-};
-
-struct wpa_driver_nl80211_data {
-  struct nl80211_global* global;
-  struct dl_list list;
-  struct dl_list wiphy_list;
-  char phyname[32];
-  void* ctx;
-  int ifindex;
-  int if_removed;
-  int if_disabled;
-  int ignore_if_down_event;
-  struct rfkill_data* rfkill;
-  struct wpa_driver_capa capa;
-  u8* extended_capa;
-  u8* extended_capa_mask;
-  unsigned int extended_capa_len;
-  int has_capability;
-  // More internal data follows.
-};
-
-#endif  // GCE_PLATFORM_SDK_AFTER(J)
-*/
-
-#endif  // __DEVICE_GOOGLE_GCE_WPA_SUPPLICANT_8_H__
diff --git a/device/generic/goldfish/wpa_supplicant_overlay.conf b/device/generic/goldfish/wpa_supplicant_overlay.conf
new file mode 100644
index 0000000..acbcff7
--- /dev/null
+++ b/device/generic/goldfish/wpa_supplicant_overlay.conf
@@ -0,0 +1,6 @@
+disable_scan_offload=1
+p2p_disabled=1
+tdls_external_control=1
+interworking=1
+hs20=1
+auto_interworking=0

project device/generic/goldfish-opengl/
diff --git a/device/generic/goldfish-opengl/system/hwc2/EmuHWC2.cpp b/device/generic/goldfish-opengl/system/hwc2/EmuHWC2.cpp
index 84fd7b6..786e06d 100644
--- a/device/generic/goldfish-opengl/system/hwc2/EmuHWC2.cpp
+++ b/device/generic/goldfish-opengl/system/hwc2/EmuHWC2.cpp
@@ -27,6 +27,9 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include <sys/socket.h>
+#include <sys/un.h>
+
 #include "../egl/goldfish_sync.h"
 
 #include "ThreadInfo.h"
@@ -44,28 +47,6 @@ static hwc2_function_pointer_t asFP(T function)
     return reinterpret_cast<hwc2_function_pointer_t>(function);
 }
 
-static HostConnection *sHostCon = nullptr;
-
-static HostConnection* createOrGetHostConnection() {
-    if (!sHostCon) {
-        sHostCon = HostConnection::createUnique();
-    }
-    return sHostCon;
-}
-
-#define DEFINE_AND_VALIDATE_HOST_CONNECTION \
-    HostConnection *hostCon = createOrGetHostConnection(); \
-    if (!hostCon) { \
-        ALOGE("EmuHWC2: Failed to get host connection\n"); \
-        return Error::NoResources; \
-    } \
-    ExtendedRCEncoderContext *rcEnc = hostCon->rcEncoder(); \
-    if (!rcEnc) { \
-        ALOGE("EmuHWC2: Failed to get renderControl encoder context\n"); \
-        return Error::NoResources; \
-    }
-
-
 using namespace HWC2;
 
 namespace android {
@@ -693,136 +674,11 @@ Error EmuHWC2::Display::present(int32_t* outRetireFence) {
     }
     mChanges.reset();
 
-    DEFINE_AND_VALIDATE_HOST_CONNECTION
-    hostCon->lock();
-    bool hostCompositionV1 = rcEnc->hasHostCompositionV1();
-    hostCon->unlock();
-
-    if (hostCompositionV1) {
-        uint32_t numLayer = 0;
-        for (auto layer: mLayers) {
-            if (layer->getCompositionType() == Composition::Device ||
-                layer->getCompositionType() == Composition::SolidColor) {
-                numLayer++;
-            }
-        }
-
-        ALOGVV("present %d layers total %u layers",
-              numLayer, (uint32_t)mLayers.size());
-
-        mReleaseLayerIds.clear();
-        mReleaseFences.clear();
-
-        if (numLayer == 0) {
-            ALOGVV("No layers, exit");
-            mGralloc->getFb()->post(mGralloc->getFb(), mClientTarget.getBuffer());
-            *outRetireFence = mClientTarget.getFence();
-            return Error::None;
-        }
-
-        if (mComposeMsg == nullptr || mComposeMsg->getLayerCnt() < numLayer) {
-            mComposeMsg.reset(new ComposeMsg(numLayer));
-        }
-
-        // Handle the composition
-        ComposeDevice* p = mComposeMsg->get();
-        ComposeLayer* l = p->layer;
-
-        for (auto layer: mLayers) {
-            if (layer->getCompositionType() != Composition::Device &&
-                layer->getCompositionType() != Composition::SolidColor) {
-                ALOGE("%s: Unsupported composition types %d layer %u",
-                      __FUNCTION__, layer->getCompositionType(),
-                      (uint32_t)layer->getId());
-                continue;
-            }
-            // send layer composition command to host
-            if (layer->getCompositionType() == Composition::Device) {
-                int fence = layer->getLayerBuffer().getFence();
-                mReleaseLayerIds.push_back(layer->getId());
-                if (fence != -1) {
-                    int err = sync_wait(fence, 3000);
-                    if (err < 0 && errno == ETIME) {
-                        ALOGE("%s waited on fence %d for 3000 ms",
-                            __FUNCTION__, fence);
-                    }
-                    close(fence);
-                }
-                else {
-                    ALOGV("%s: acquire fence not set for layer %u",
-                          __FUNCTION__, (uint32_t)layer->getId());
-                }
-                cb_handle_t *cb =
-                    (cb_handle_t *)layer->getLayerBuffer().getBuffer();
-                if (cb != nullptr) {
-                    l->cbHandle = cb->hostHandle;
-                }
-                else {
-                    ALOGE("%s null buffer for layer %d", __FUNCTION__,
-                          (uint32_t)layer->getId());
-                }
-            }
-            else {
-                // solidcolor has no buffer
-                l->cbHandle = 0;
-            }
-            l->composeMode = (hwc2_composition_t)layer->getCompositionType();
-            l->displayFrame = layer->getDisplayFrame();
-            l->crop = layer->getSourceCrop();
-            l->blendMode = layer->getBlendMode();
-            l->alpha = layer->getPlaneAlpha();
-            l->color = layer->getColor();
-            l->transform = layer->getTransform();
-            ALOGV("   cb %d blendmode %d alpha %f %d %d %d %d z %d"
-                  " composeMode %d, transform %d",
-                  l->cbHandle, l->blendMode, l->alpha,
-                  l->displayFrame.left, l->displayFrame.top,
-                  l->displayFrame.right, l->displayFrame.bottom,
-                  layer->getZ(), l->composeMode, l->transform);
-            l++;
-        }
-        p->version = 1;
-        p->targetHandle = mGralloc->getTargetCb();
-        p->numLayers = numLayer;
-
-        hostCon->lock();
-        rcEnc->rcCompose(rcEnc,
-                         sizeof(ComposeDevice) + numLayer * sizeof(ComposeLayer),
-                         (void *)p);
-        hostCon->unlock();
-
-        // Send a retire fence and use it as the release fence for all layers,
-        // since media expects it
-        EGLint attribs[] = { EGL_SYNC_NATIVE_FENCE_ANDROID, EGL_NO_NATIVE_FENCE_FD_ANDROID };
-
-        uint64_t sync_handle, thread_handle;
-        int retire_fd;
-
-        hostCon->lock();
-        rcEnc->rcCreateSyncKHR(rcEnc, EGL_SYNC_NATIVE_FENCE_ANDROID,
-                attribs, 2 * sizeof(EGLint), true /* destroy when signaled */,
-                &sync_handle, &thread_handle);
-        hostCon->unlock();
-
-        goldfish_sync_queue_work(mSyncDeviceFd,
-                sync_handle, thread_handle, &retire_fd);
-
-        for (size_t i = 0; i < mReleaseLayerIds.size(); ++i) {
-            mReleaseFences.push_back(dup(retire_fd));
-        }
-
-        *outRetireFence = dup(retire_fd);
-        close(retire_fd);
-        hostCon->lock();
-        rcEnc->rcDestroySyncKHR(rcEnc, sync_handle);
-        hostCon->unlock();
-    } else {
-        // we set all layers Composition::Client, so do nothing.
-        mGralloc->getFb()->post(mGralloc->getFb(), mClientTarget.getBuffer());
-        *outRetireFence = mClientTarget.getFence();
-        ALOGV("%s fallback to post, returns outRetireFence %d",
-              __FUNCTION__, *outRetireFence);
-    }
+    // we set all layers Composition::Client, so do nothing.
+    mGralloc->getFb()->post(mGralloc->getFb(), mClientTarget.getBuffer());
+    *outRetireFence = mClientTarget.getFence();
+    ALOGV("%s fallback to post, returns outRetireFence %d",
+          __FUNCTION__, *outRetireFence);
 
     return Error::None;
 }
@@ -908,6 +764,43 @@ static bool isValid(PowerMode mode) {
     }
 }
 
+static void notify_hx_touchd(int enable)
+{
+    static const char *socket_name = "/dev/socket/hx-touchd-ctrl";
+    struct sockaddr_un saddr;
+    int fd;
+
+    fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if(fd < 0) {
+        ALOGE("failed to create UNIX socket for hx-touchd notification");
+        return;
+    }
+
+    memset(&saddr, 0, sizeof(saddr));
+    saddr.sun_family = AF_UNIX;
+    strncpy(saddr.sun_path, socket_name, sizeof(saddr.sun_path) - 1);
+    if(connect(fd, (struct sockaddr *)&saddr, sizeof(saddr)) < 0) {
+        close(fd);
+        ALOGE("failed to connect UNIX socket to hx-touchd");
+        return;
+    }
+
+    if(write(fd, enable ? "1" : "0", 1) != 1) {
+        close(fd);
+        ALOGE("failed to send state notification to hx-touchd");
+        return;
+    }
+
+    close(fd);
+}
+
+static void set_cpu_speed(int enable)
+{
+    FILE *f = fopen("/sys/devices/system/cpu/cpufreq/policy0/scaling_max_freq", "w");
+    fprintf(f, "%d\n", enable ? 2340000 : 1356000);
+    fclose(f);
+}
+
 Error EmuHWC2::Display::setPowerMode(int32_t intMode) {
     ALOGVV("%s", __FUNCTION__);
     // Emulator always set screen ON
@@ -920,6 +813,21 @@ Error EmuHWC2::Display::setPowerMode(int32_t intMode) {
     }
     std::unique_lock<std::mutex> lock(mStateMutex);
 
+    framebuffer_device_t* fbDev = NULL;
+    if(mGralloc)
+        fbDev = mGralloc->getFb();
+    if(fbDev && fbDev->enableScreen) {
+        if(mode == PowerMode::Off) {
+            notify_hx_touchd(0);
+            fbDev->enableScreen(fbDev, 0);
+            set_cpu_speed(0);
+        } else {
+            set_cpu_speed(1);
+            fbDev->enableScreen(fbDev, 1);
+            notify_hx_touchd(1);
+        }
+    }
+
     ALOGV("%s: (display %u mode %s)", __FUNCTION__,
           (uint32_t)mId, to_string(mode).c_str());
     mPowerMode = mode;
@@ -957,53 +865,11 @@ Error EmuHWC2::Display::validate(uint32_t* outNumTypes,
 
     if (!mChanges) {
         mChanges.reset(new Changes);
-        DEFINE_AND_VALIDATE_HOST_CONNECTION
-        hostCon->lock();
-        bool hostCompositionV1 = rcEnc->hasHostCompositionV1();
-        hostCon->unlock();
-
-        if (hostCompositionV1) {
-            // Support Device and SolidColor, otherwise, fallback all layers
-            // to Client
-            bool fallBack = false;
-            for (auto& layer : mLayers) {
-                if (layer->getCompositionType() == Composition::Invalid) {
-                    // Log error for unused layers, layer leak?
-                    ALOGE("%s layer %u CompositionType(%d) not set",
-                          __FUNCTION__, (uint32_t)layer->getId(),
-                          layer->getCompositionType());
-                    continue;
-                }
-                if (layer->getCompositionType() == Composition::Client ||
-                    layer->getCompositionType() == Composition::Cursor ||
-                    layer->getCompositionType() == Composition::Sideband) {
-                    ALOGW("%s: layer %u CompositionType %d, fallback", __FUNCTION__,
-                         (uint32_t)layer->getId(), layer->getCompositionType());
-                    fallBack = true;
-                    break;
-                }
-            }
-            if (mSetColorTransform) {
-                fallBack = true;
-            }
-            if (fallBack) {
-                for (auto& layer : mLayers) {
-                    if (layer->getCompositionType() == Composition::Invalid) {
-                        continue;
-                    }
-                    if (layer->getCompositionType() != Composition::Client) {
-                        mChanges->addTypeChange(layer->getId(),
-                                                Composition::Client);
-                    }
-                }
-            }
-       }
-       else {
-            for (auto& layer : mLayers) {
-                if (layer->getCompositionType() != Composition::Client) {
-                    mChanges->addTypeChange(layer->getId(),
-                                            Composition::Client);
-                }
+
+        for (auto& layer : mLayers) {
+            if (layer->getCompositionType() != Composition::Client) {
+                mChanges->addTypeChange(layer->getId(),
+                                        Composition::Client);
             }
         }
     }

project external/chromium-webview/
diff --git a/external/chromium-webview/prebuilt/arm64/webview.apk b/external/chromium-webview/prebuilt/arm64/webview.apk
index eafceff..5b952b3 100644
Binary files a/external/chromium-webview/prebuilt/arm64/webview.apk and b/external/chromium-webview/prebuilt/arm64/webview.apk differ

project external/jemalloc/
diff --git a/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h b/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h
index 03d537e..8a94d00 100644
--- a/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h
+++ b/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h
@@ -201,7 +201,7 @@
 /* #undef LG_QUANTUM */
 
 /* One page is 2^LG_PAGE bytes. */
-#define LG_PAGE 12
+#define LG_PAGE 14
 
 /*
  * If defined, adjacent virtual memory mappings with identical attributes
diff --git a/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs_host.h b/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs_host.h
index 789e8a4..2337a7e 100644
--- a/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs_host.h
+++ b/external/jemalloc/include/jemalloc/internal/jemalloc_internal_defs_host.h
@@ -202,7 +202,7 @@
 /* #undef LG_QUANTUM */
 
 /* One page is 2^LG_PAGE bytes. */
-#define LG_PAGE 12
+#define LG_PAGE 14
 
 /*
  * If defined, adjacent virtual memory mappings with identical attributes
diff --git a/external/jemalloc/include/jemalloc/internal/size_classes.h b/external/jemalloc/include/jemalloc/internal/size_classes.h
index e4edc4b..6592270 100644
--- a/external/jemalloc/include/jemalloc/internal/size_classes.h
+++ b/external/jemalloc/include/jemalloc/internal/size_classes.h
@@ -181,6 +181,156 @@
 #define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 14)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      3,        3,      2,  no, yes,  3) \
+    SC(  3,      3,        3,      3,  no, yes,  3) \
+                                                         \
+    SC(  4,      5,        3,      1,  no, yes,  3) \
+    SC(  5,      5,        3,      2,  no, yes,  3) \
+    SC(  6,      5,        3,      3,  no, yes,  3) \
+    SC(  7,      5,        3,      4,  no, yes,  3) \
+                                                         \
+    SC(  8,      6,        4,      1,  no, yes,  4) \
+    SC(  9,      6,        4,      2,  no, yes,  4) \
+    SC( 10,      6,        4,      3,  no, yes,  4) \
+    SC( 11,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC( 12,      7,        5,      1,  no, yes,  5) \
+    SC( 13,      7,        5,      2,  no, yes,  5) \
+    SC( 14,      7,        5,      3,  no, yes,  5) \
+    SC( 15,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 16,      8,        6,      1,  no, yes,  6) \
+    SC( 17,      8,        6,      2,  no, yes,  6) \
+    SC( 18,      8,        6,      3,  no, yes,  6) \
+    SC( 19,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 20,      9,        7,      1,  no, yes,  7) \
+    SC( 21,      9,        7,      2,  no, yes,  7) \
+    SC( 22,      9,        7,      3,  no, yes,  7) \
+    SC( 23,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 24,     10,        8,      1,  no, yes,  8) \
+    SC( 25,     10,        8,      2,  no, yes,  8) \
+    SC( 26,     10,        8,      3,  no, yes,  8) \
+    SC( 27,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 28,     11,        9,      1,  no, yes,  9) \
+    SC( 29,     11,        9,      2,  no, yes,  9) \
+    SC( 30,     11,        9,      3,  no, yes,  9) \
+    SC( 31,     11,        9,      4,  no, yes,  9) \
+                                                         \
+    SC( 32,     12,       10,      1,  no, yes, no) \
+    SC( 33,     12,       10,      2,  no, yes, no) \
+    SC( 34,     12,       10,      3,  no, yes, no) \
+    SC( 35,     12,       10,      4,  no, yes, no) \
+                                                         \
+    SC( 36,     13,       11,      1,  no, yes, no) \
+    SC( 37,     13,       11,      2,  no, yes, no) \
+    SC( 38,     13,       11,      3,  no, yes, no) \
+    SC( 39,     13,       11,      4, yes, yes, no) \
+                                                         \
+    SC( 40,     14,       12,      1,  no, yes, no) \
+    SC( 41,     14,       12,      2,  no, yes, no) \
+    SC( 42,     14,       12,      3,  no, yes, no) \
+    SC( 43,     14,       12,      4, yes, yes, no) \
+                                                         \
+    SC( 44,     15,       13,      1,  no, yes, no) \
+    SC( 45,     15,       13,      2, yes, yes, no) \
+    SC( 46,     15,       13,      3,  no, yes, no) \
+    SC( 47,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 48,     16,       14,      1, yes,  no, no) \
+    SC( 49,     16,       14,      2, yes,  no, no) \
+    SC( 50,     16,       14,      3, yes,  no, no) \
+    SC( 51,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 52,     17,       15,      1, yes,  no, no) \
+    SC( 53,     17,       15,      2, yes,  no, no) \
+    SC( 54,     17,       15,      3, yes,  no, no) \
+    SC( 55,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 56,     18,       16,      1, yes,  no, no) \
+    SC( 57,     18,       16,      2, yes,  no, no) \
+    SC( 58,     18,       16,      3, yes,  no, no) \
+    SC( 59,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 60,     19,       17,      1, yes,  no, no) \
+    SC( 61,     19,       17,      2, yes,  no, no) \
+    SC( 62,     19,       17,      3, yes,  no, no) \
+    SC( 63,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     20,       18,      1, yes,  no, no) \
+    SC( 65,     20,       18,      2, yes,  no, no) \
+    SC( 66,     20,       18,      3, yes,  no, no) \
+    SC( 67,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     21,       19,      1, yes,  no, no) \
+    SC( 69,     21,       19,      2, yes,  no, no) \
+    SC( 70,     21,       19,      3, yes,  no, no) \
+    SC( 71,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 72,     22,       20,      1, yes,  no, no) \
+    SC( 73,     22,       20,      2, yes,  no, no) \
+    SC( 74,     22,       20,      3, yes,  no, no) \
+    SC( 75,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 76,     23,       21,      1, yes,  no, no) \
+    SC( 77,     23,       21,      2, yes,  no, no) \
+    SC( 78,     23,       21,      3, yes,  no, no) \
+    SC( 79,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 80,     24,       22,      1, yes,  no, no) \
+    SC( 81,     24,       22,      2, yes,  no, no) \
+    SC( 82,     24,       22,      3, yes,  no, no) \
+    SC( 83,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 84,     25,       23,      1, yes,  no, no) \
+    SC( 85,     25,       23,      2, yes,  no, no) \
+    SC( 86,     25,       23,      3, yes,  no, no) \
+    SC( 87,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 88,     26,       24,      1, yes,  no, no) \
+    SC( 89,     26,       24,      2, yes,  no, no) \
+    SC( 90,     26,       24,      3, yes,  no, no) \
+    SC( 91,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 92,     27,       25,      1, yes,  no, no) \
+    SC( 93,     27,       25,      2, yes,  no, no) \
+    SC( 94,     27,       25,      3, yes,  no, no) \
+    SC( 95,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 96,     28,       26,      1, yes,  no, no) \
+    SC( 97,     28,       26,      2, yes,  no, no) \
+    SC( 98,     28,       26,      3, yes,  no, no) \
+    SC( 99,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC(100,     29,       27,      1, yes,  no, no) \
+    SC(101,     29,       27,      2, yes,  no, no) \
+    SC(102,     29,       27,      3, yes,  no, no) \
+    SC(103,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(104,     30,       28,      1, yes,  no, no) \
+    SC(105,     30,       28,      2, yes,  no, no) \
+    SC(106,     30,       28,      3, yes,  no, no) \
+
+#define	SIZE_CLASSES_DEFINED
+#define	NTBINS			0
+#define	NLBINS			32
+#define	NBINS			47
+#define	NSIZES			107
+#define	NPSIZES			63
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define	LG_LARGE_MINCLASS	16
+#define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
+#endif
+
 #if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
 #define	SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
@@ -328,96 +478,243 @@
 #define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
-#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define	SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
-    SC(  0,      4,        4,      0,  no, yes,  4) \
-    SC(  1,      4,        4,      1,  no, yes,  4) \
-    SC(  2,      4,        4,      2,  no, yes,  4) \
-    SC(  3,      4,        4,      3,  no, yes,  4) \
-                                                         \
-    SC(  4,      6,        4,      1,  no, yes,  4) \
-    SC(  5,      6,        4,      2,  no, yes,  4) \
-    SC(  6,      6,        4,      3,  no, yes,  4) \
-    SC(  7,      6,        4,      4,  no, yes,  4) \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
                                                          \
-    SC(  8,      7,        5,      1,  no, yes,  5) \
-    SC(  9,      7,        5,      2,  no, yes,  5) \
-    SC( 10,      7,        5,      3,  no, yes,  5) \
-    SC( 11,      7,        5,      4,  no, yes,  5) \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      4,        4,      1,  no, yes,  4) \
+    SC(  3,      4,        4,      2,  no, yes,  4) \
+    SC(  4,      4,        4,      3,  no, yes,  4) \
                                                          \
-    SC( 12,      8,        6,      1,  no, yes,  6) \
-    SC( 13,      8,        6,      2,  no, yes,  6) \
-    SC( 14,      8,        6,      3,  no, yes,  6) \
-    SC( 15,      8,        6,      4,  no, yes,  6) \
+    SC(  5,      6,        4,      1,  no, yes,  4) \
+    SC(  6,      6,        4,      2,  no, yes,  4) \
+    SC(  7,      6,        4,      3,  no, yes,  4) \
+    SC(  8,      6,        4,      4,  no, yes,  4) \
                                                          \
-    SC( 16,      9,        7,      1,  no, yes,  7) \
-    SC( 17,      9,        7,      2,  no, yes,  7) \
-    SC( 18,      9,        7,      3,  no, yes,  7) \
-    SC( 19,      9,        7,      4,  no, yes,  7) \
+    SC(  9,      7,        5,      1,  no, yes,  5) \
+    SC( 10,      7,        5,      2,  no, yes,  5) \
+    SC( 11,      7,        5,      3,  no, yes,  5) \
+    SC( 12,      7,        5,      4,  no, yes,  5) \
                                                          \
-    SC( 20,     10,        8,      1,  no, yes,  8) \
-    SC( 21,     10,        8,      2,  no, yes,  8) \
-    SC( 22,     10,        8,      3,  no, yes,  8) \
-    SC( 23,     10,        8,      4,  no, yes,  8) \
+    SC( 13,      8,        6,      1,  no, yes,  6) \
+    SC( 14,      8,        6,      2,  no, yes,  6) \
+    SC( 15,      8,        6,      3,  no, yes,  6) \
+    SC( 16,      8,        6,      4,  no, yes,  6) \
                                                          \
-    SC( 24,     11,        9,      1,  no, yes,  9) \
-    SC( 25,     11,        9,      2,  no, yes,  9) \
-    SC( 26,     11,        9,      3,  no, yes,  9) \
-    SC( 27,     11,        9,      4, yes, yes,  9) \
+    SC( 17,      9,        7,      1,  no, yes,  7) \
+    SC( 18,      9,        7,      2,  no, yes,  7) \
+    SC( 19,      9,        7,      3,  no, yes,  7) \
+    SC( 20,      9,        7,      4,  no, yes,  7) \
                                                          \
-    SC( 28,     12,       10,      1,  no, yes, no) \
-    SC( 29,     12,       10,      2,  no, yes, no) \
-    SC( 30,     12,       10,      3,  no, yes, no) \
-    SC( 31,     12,       10,      4, yes, yes, no) \
+    SC( 21,     10,        8,      1,  no, yes,  8) \
+    SC( 22,     10,        8,      2,  no, yes,  8) \
+    SC( 23,     10,        8,      3,  no, yes,  8) \
+    SC( 24,     10,        8,      4,  no, yes,  8) \
                                                          \
-    SC( 32,     13,       11,      1,  no, yes, no) \
-    SC( 33,     13,       11,      2, yes, yes, no) \
-    SC( 34,     13,       11,      3,  no, yes, no) \
-    SC( 35,     13,       11,      4, yes,  no, no) \
+    SC( 25,     11,        9,      1,  no, yes,  9) \
+    SC( 26,     11,        9,      2,  no, yes,  9) \
+    SC( 27,     11,        9,      3,  no, yes,  9) \
+    SC( 28,     11,        9,      4,  no, yes,  9) \
                                                          \
-    SC( 36,     14,       12,      1, yes,  no, no) \
-    SC( 37,     14,       12,      2, yes,  no, no) \
-    SC( 38,     14,       12,      3, yes,  no, no) \
-    SC( 39,     14,       12,      4, yes,  no, no) \
+    SC( 29,     12,       10,      1,  no, yes, no) \
+    SC( 30,     12,       10,      2,  no, yes, no) \
+    SC( 31,     12,       10,      3,  no, yes, no) \
+    SC( 32,     12,       10,      4,  no, yes, no) \
                                                          \
-    SC( 40,     15,       13,      1, yes,  no, no) \
-    SC( 41,     15,       13,      2, yes,  no, no) \
-    SC( 42,     15,       13,      3, yes,  no, no) \
-    SC( 43,     15,       13,      4, yes,  no, no) \
+    SC( 33,     13,       11,      1,  no, yes, no) \
+    SC( 34,     13,       11,      2,  no, yes, no) \
+    SC( 35,     13,       11,      3,  no, yes, no) \
+    SC( 36,     13,       11,      4, yes, yes, no) \
                                                          \
-    SC( 44,     16,       14,      1, yes,  no, no) \
-    SC( 45,     16,       14,      2, yes,  no, no) \
-    SC( 46,     16,       14,      3, yes,  no, no) \
-    SC( 47,     16,       14,      4, yes,  no, no) \
+    SC( 37,     14,       12,      1,  no, yes, no) \
+    SC( 38,     14,       12,      2,  no, yes, no) \
+    SC( 39,     14,       12,      3,  no, yes, no) \
+    SC( 40,     14,       12,      4, yes, yes, no) \
                                                          \
-    SC( 48,     17,       15,      1, yes,  no, no) \
-    SC( 49,     17,       15,      2, yes,  no, no) \
-    SC( 50,     17,       15,      3, yes,  no, no) \
-    SC( 51,     17,       15,      4, yes,  no, no) \
+    SC( 41,     15,       13,      1,  no, yes, no) \
+    SC( 42,     15,       13,      2, yes, yes, no) \
+    SC( 43,     15,       13,      3,  no, yes, no) \
+    SC( 44,     15,       13,      4, yes,  no, no) \
                                                          \
-    SC( 52,     18,       16,      1, yes,  no, no) \
-    SC( 53,     18,       16,      2, yes,  no, no) \
-    SC( 54,     18,       16,      3, yes,  no, no) \
-    SC( 55,     18,       16,      4, yes,  no, no) \
+    SC( 45,     16,       14,      1, yes,  no, no) \
+    SC( 46,     16,       14,      2, yes,  no, no) \
+    SC( 47,     16,       14,      3, yes,  no, no) \
+    SC( 48,     16,       14,      4, yes,  no, no) \
                                                          \
-    SC( 56,     19,       17,      1, yes,  no, no) \
-    SC( 57,     19,       17,      2, yes,  no, no) \
-    SC( 58,     19,       17,      3, yes,  no, no) \
-    SC( 59,     19,       17,      4, yes,  no, no) \
+    SC( 49,     17,       15,      1, yes,  no, no) \
+    SC( 50,     17,       15,      2, yes,  no, no) \
+    SC( 51,     17,       15,      3, yes,  no, no) \
+    SC( 52,     17,       15,      4, yes,  no, no) \
                                                          \
-    SC( 60,     20,       18,      1, yes,  no, no) \
-    SC( 61,     20,       18,      2, yes,  no, no) \
-    SC( 62,     20,       18,      3, yes,  no, no) \
-    SC( 63,     20,       18,      4, yes,  no, no) \
+    SC( 53,     18,       16,      1, yes,  no, no) \
+    SC( 54,     18,       16,      2, yes,  no, no) \
+    SC( 55,     18,       16,      3, yes,  no, no) \
+    SC( 56,     18,       16,      4, yes,  no, no) \
                                                          \
-    SC( 64,     21,       19,      1, yes,  no, no) \
-    SC( 65,     21,       19,      2, yes,  no, no) \
-    SC( 66,     21,       19,      3, yes,  no, no) \
-    SC( 67,     21,       19,      4, yes,  no, no) \
+    SC( 57,     19,       17,      1, yes,  no, no) \
+    SC( 58,     19,       17,      2, yes,  no, no) \
+    SC( 59,     19,       17,      3, yes,  no, no) \
+    SC( 60,     19,       17,      4, yes,  no, no) \
                                                          \
-    SC( 68,     22,       20,      1, yes,  no, no) \
-    SC( 69,     22,       20,      2, yes,  no, no) \
+    SC( 61,     20,       18,      1, yes,  no, no) \
+    SC( 62,     20,       18,      2, yes,  no, no) \
+    SC( 63,     20,       18,      3, yes,  no, no) \
+    SC( 64,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 65,     21,       19,      1, yes,  no, no) \
+    SC( 66,     21,       19,      2, yes,  no, no) \
+    SC( 67,     21,       19,      3, yes,  no, no) \
+    SC( 68,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 69,     22,       20,      1, yes,  no, no) \
+    SC( 70,     22,       20,      2, yes,  no, no) \
+    SC( 71,     22,       20,      3, yes,  no, no) \
+    SC( 72,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 73,     23,       21,      1, yes,  no, no) \
+    SC( 74,     23,       21,      2, yes,  no, no) \
+    SC( 75,     23,       21,      3, yes,  no, no) \
+    SC( 76,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 77,     24,       22,      1, yes,  no, no) \
+    SC( 78,     24,       22,      2, yes,  no, no) \
+    SC( 79,     24,       22,      3, yes,  no, no) \
+    SC( 80,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 81,     25,       23,      1, yes,  no, no) \
+    SC( 82,     25,       23,      2, yes,  no, no) \
+    SC( 83,     25,       23,      3, yes,  no, no) \
+    SC( 84,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 85,     26,       24,      1, yes,  no, no) \
+    SC( 86,     26,       24,      2, yes,  no, no) \
+    SC( 87,     26,       24,      3, yes,  no, no) \
+    SC( 88,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 89,     27,       25,      1, yes,  no, no) \
+    SC( 90,     27,       25,      2, yes,  no, no) \
+    SC( 91,     27,       25,      3, yes,  no, no) \
+    SC( 92,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 93,     28,       26,      1, yes,  no, no) \
+    SC( 94,     28,       26,      2, yes,  no, no) \
+    SC( 95,     28,       26,      3, yes,  no, no) \
+    SC( 96,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC( 97,     29,       27,      1, yes,  no, no) \
+    SC( 98,     29,       27,      2, yes,  no, no) \
+    SC( 99,     29,       27,      3, yes,  no, no) \
+    SC(100,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(101,     30,       28,      1, yes,  no, no) \
+    SC(102,     30,       28,      2, yes,  no, no) \
+    SC(103,     30,       28,      3, yes,  no, no) \
+
+#define	SIZE_CLASSES_DEFINED
+#define	NTBINS			1
+#define	NLBINS			29
+#define	NBINS			44
+#define	NSIZES			104
+#define	NPSIZES			63
+#define	LG_TINY_MAXCLASS	3
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define	LG_LARGE_MINCLASS	16
+#define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
+#endif
+
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      4,        4,      0,  no, yes,  4) \
+    SC(  1,      4,        4,      1,  no, yes,  4) \
+    SC(  2,      4,        4,      2,  no, yes,  4) \
+    SC(  3,      4,        4,      3,  no, yes,  4) \
+                                                         \
+    SC(  4,      6,        4,      1,  no, yes,  4) \
+    SC(  5,      6,        4,      2,  no, yes,  4) \
+    SC(  6,      6,        4,      3,  no, yes,  4) \
+    SC(  7,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC(  8,      7,        5,      1,  no, yes,  5) \
+    SC(  9,      7,        5,      2,  no, yes,  5) \
+    SC( 10,      7,        5,      3,  no, yes,  5) \
+    SC( 11,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 12,      8,        6,      1,  no, yes,  6) \
+    SC( 13,      8,        6,      2,  no, yes,  6) \
+    SC( 14,      8,        6,      3,  no, yes,  6) \
+    SC( 15,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 16,      9,        7,      1,  no, yes,  7) \
+    SC( 17,      9,        7,      2,  no, yes,  7) \
+    SC( 18,      9,        7,      3,  no, yes,  7) \
+    SC( 19,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 20,     10,        8,      1,  no, yes,  8) \
+    SC( 21,     10,        8,      2,  no, yes,  8) \
+    SC( 22,     10,        8,      3,  no, yes,  8) \
+    SC( 23,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 24,     11,        9,      1,  no, yes,  9) \
+    SC( 25,     11,        9,      2,  no, yes,  9) \
+    SC( 26,     11,        9,      3,  no, yes,  9) \
+    SC( 27,     11,        9,      4, yes, yes,  9) \
+                                                         \
+    SC( 28,     12,       10,      1,  no, yes, no) \
+    SC( 29,     12,       10,      2,  no, yes, no) \
+    SC( 30,     12,       10,      3,  no, yes, no) \
+    SC( 31,     12,       10,      4, yes, yes, no) \
+                                                         \
+    SC( 32,     13,       11,      1,  no, yes, no) \
+    SC( 33,     13,       11,      2, yes, yes, no) \
+    SC( 34,     13,       11,      3,  no, yes, no) \
+    SC( 35,     13,       11,      4, yes,  no, no) \
+                                                         \
+    SC( 36,     14,       12,      1, yes,  no, no) \
+    SC( 37,     14,       12,      2, yes,  no, no) \
+    SC( 38,     14,       12,      3, yes,  no, no) \
+    SC( 39,     14,       12,      4, yes,  no, no) \
+                                                         \
+    SC( 40,     15,       13,      1, yes,  no, no) \
+    SC( 41,     15,       13,      2, yes,  no, no) \
+    SC( 42,     15,       13,      3, yes,  no, no) \
+    SC( 43,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 44,     16,       14,      1, yes,  no, no) \
+    SC( 45,     16,       14,      2, yes,  no, no) \
+    SC( 46,     16,       14,      3, yes,  no, no) \
+    SC( 47,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 48,     17,       15,      1, yes,  no, no) \
+    SC( 49,     17,       15,      2, yes,  no, no) \
+    SC( 50,     17,       15,      3, yes,  no, no) \
+    SC( 51,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 52,     18,       16,      1, yes,  no, no) \
+    SC( 53,     18,       16,      2, yes,  no, no) \
+    SC( 54,     18,       16,      3, yes,  no, no) \
+    SC( 55,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 56,     19,       17,      1, yes,  no, no) \
+    SC( 57,     19,       17,      2, yes,  no, no) \
+    SC( 58,     19,       17,      3, yes,  no, no) \
+    SC( 59,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 60,     20,       18,      1, yes,  no, no) \
+    SC( 61,     20,       18,      2, yes,  no, no) \
+    SC( 62,     20,       18,      3, yes,  no, no) \
+    SC( 63,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     21,       19,      1, yes,  no, no) \
+    SC( 65,     21,       19,      2, yes,  no, no) \
+    SC( 66,     21,       19,      3, yes,  no, no) \
+    SC( 67,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     22,       20,      1, yes,  no, no) \
+    SC( 69,     22,       20,      2, yes,  no, no) \
     SC( 70,     22,       20,      3, yes,  no, no) \
     SC( 71,     22,       20,      4, yes,  no, no) \
                                                          \
@@ -473,80 +770,225 @@
 #define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
-#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define	SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
-    SC(  0,      3,        3,      0,  no, yes,  3) \
-    SC(  1,      3,        3,      1,  no, yes,  3) \
-    SC(  2,      3,        3,      2,  no, yes,  3) \
-    SC(  3,      3,        3,      3,  no, yes,  3) \
+    SC(  0,      4,        4,      0,  no, yes,  4) \
+    SC(  1,      4,        4,      1,  no, yes,  4) \
+    SC(  2,      4,        4,      2,  no, yes,  4) \
+    SC(  3,      4,        4,      3,  no, yes,  4) \
                                                          \
-    SC(  4,      5,        3,      1,  no, yes,  3) \
-    SC(  5,      5,        3,      2,  no, yes,  3) \
-    SC(  6,      5,        3,      3,  no, yes,  3) \
-    SC(  7,      5,        3,      4,  no, yes,  3) \
+    SC(  4,      6,        4,      1,  no, yes,  4) \
+    SC(  5,      6,        4,      2,  no, yes,  4) \
+    SC(  6,      6,        4,      3,  no, yes,  4) \
+    SC(  7,      6,        4,      4,  no, yes,  4) \
                                                          \
-    SC(  8,      6,        4,      1,  no, yes,  4) \
-    SC(  9,      6,        4,      2,  no, yes,  4) \
-    SC( 10,      6,        4,      3,  no, yes,  4) \
-    SC( 11,      6,        4,      4,  no, yes,  4) \
+    SC(  8,      7,        5,      1,  no, yes,  5) \
+    SC(  9,      7,        5,      2,  no, yes,  5) \
+    SC( 10,      7,        5,      3,  no, yes,  5) \
+    SC( 11,      7,        5,      4,  no, yes,  5) \
                                                          \
-    SC( 12,      7,        5,      1,  no, yes,  5) \
-    SC( 13,      7,        5,      2,  no, yes,  5) \
-    SC( 14,      7,        5,      3,  no, yes,  5) \
-    SC( 15,      7,        5,      4,  no, yes,  5) \
+    SC( 12,      8,        6,      1,  no, yes,  6) \
+    SC( 13,      8,        6,      2,  no, yes,  6) \
+    SC( 14,      8,        6,      3,  no, yes,  6) \
+    SC( 15,      8,        6,      4,  no, yes,  6) \
                                                          \
-    SC( 16,      8,        6,      1,  no, yes,  6) \
-    SC( 17,      8,        6,      2,  no, yes,  6) \
-    SC( 18,      8,        6,      3,  no, yes,  6) \
-    SC( 19,      8,        6,      4,  no, yes,  6) \
+    SC( 16,      9,        7,      1,  no, yes,  7) \
+    SC( 17,      9,        7,      2,  no, yes,  7) \
+    SC( 18,      9,        7,      3,  no, yes,  7) \
+    SC( 19,      9,        7,      4,  no, yes,  7) \
                                                          \
-    SC( 20,      9,        7,      1,  no, yes,  7) \
-    SC( 21,      9,        7,      2,  no, yes,  7) \
-    SC( 22,      9,        7,      3,  no, yes,  7) \
-    SC( 23,      9,        7,      4,  no, yes,  7) \
+    SC( 20,     10,        8,      1,  no, yes,  8) \
+    SC( 21,     10,        8,      2,  no, yes,  8) \
+    SC( 22,     10,        8,      3,  no, yes,  8) \
+    SC( 23,     10,        8,      4,  no, yes,  8) \
                                                          \
-    SC( 24,     10,        8,      1,  no, yes,  8) \
-    SC( 25,     10,        8,      2,  no, yes,  8) \
-    SC( 26,     10,        8,      3,  no, yes,  8) \
-    SC( 27,     10,        8,      4,  no, yes,  8) \
+    SC( 24,     11,        9,      1,  no, yes,  9) \
+    SC( 25,     11,        9,      2,  no, yes,  9) \
+    SC( 26,     11,        9,      3,  no, yes,  9) \
+    SC( 27,     11,        9,      4,  no, yes,  9) \
                                                          \
-    SC( 28,     11,        9,      1,  no, yes,  9) \
-    SC( 29,     11,        9,      2,  no, yes,  9) \
-    SC( 30,     11,        9,      3,  no, yes,  9) \
-    SC( 31,     11,        9,      4, yes, yes,  9) \
+    SC( 28,     12,       10,      1,  no, yes, no) \
+    SC( 29,     12,       10,      2,  no, yes, no) \
+    SC( 30,     12,       10,      3,  no, yes, no) \
+    SC( 31,     12,       10,      4,  no, yes, no) \
                                                          \
-    SC( 32,     12,       10,      1,  no, yes, no) \
-    SC( 33,     12,       10,      2,  no, yes, no) \
-    SC( 34,     12,       10,      3,  no, yes, no) \
-    SC( 35,     12,       10,      4, yes, yes, no) \
+    SC( 32,     13,       11,      1,  no, yes, no) \
+    SC( 33,     13,       11,      2,  no, yes, no) \
+    SC( 34,     13,       11,      3,  no, yes, no) \
+    SC( 35,     13,       11,      4, yes, yes, no) \
                                                          \
-    SC( 36,     13,       11,      1,  no, yes, no) \
-    SC( 37,     13,       11,      2, yes, yes, no) \
-    SC( 38,     13,       11,      3,  no, yes, no) \
-    SC( 39,     13,       11,      4, yes,  no, no) \
+    SC( 36,     14,       12,      1,  no, yes, no) \
+    SC( 37,     14,       12,      2,  no, yes, no) \
+    SC( 38,     14,       12,      3,  no, yes, no) \
+    SC( 39,     14,       12,      4, yes, yes, no) \
                                                          \
-    SC( 40,     14,       12,      1, yes,  no, no) \
-    SC( 41,     14,       12,      2, yes,  no, no) \
-    SC( 42,     14,       12,      3, yes,  no, no) \
-    SC( 43,     14,       12,      4, yes,  no, no) \
+    SC( 40,     15,       13,      1,  no, yes, no) \
+    SC( 41,     15,       13,      2, yes, yes, no) \
+    SC( 42,     15,       13,      3,  no, yes, no) \
+    SC( 43,     15,       13,      4, yes,  no, no) \
                                                          \
-    SC( 44,     15,       13,      1, yes,  no, no) \
-    SC( 45,     15,       13,      2, yes,  no, no) \
-    SC( 46,     15,       13,      3, yes,  no, no) \
-    SC( 47,     15,       13,      4, yes,  no, no) \
+    SC( 44,     16,       14,      1, yes,  no, no) \
+    SC( 45,     16,       14,      2, yes,  no, no) \
+    SC( 46,     16,       14,      3, yes,  no, no) \
+    SC( 47,     16,       14,      4, yes,  no, no) \
                                                          \
-    SC( 48,     16,       14,      1, yes,  no, no) \
-    SC( 49,     16,       14,      2, yes,  no, no) \
-    SC( 50,     16,       14,      3, yes,  no, no) \
-    SC( 51,     16,       14,      4, yes,  no, no) \
+    SC( 48,     17,       15,      1, yes,  no, no) \
+    SC( 49,     17,       15,      2, yes,  no, no) \
+    SC( 50,     17,       15,      3, yes,  no, no) \
+    SC( 51,     17,       15,      4, yes,  no, no) \
                                                          \
-    SC( 52,     17,       15,      1, yes,  no, no) \
-    SC( 53,     17,       15,      2, yes,  no, no) \
-    SC( 54,     17,       15,      3, yes,  no, no) \
-    SC( 55,     17,       15,      4, yes,  no, no) \
+    SC( 52,     18,       16,      1, yes,  no, no) \
+    SC( 53,     18,       16,      2, yes,  no, no) \
+    SC( 54,     18,       16,      3, yes,  no, no) \
+    SC( 55,     18,       16,      4, yes,  no, no) \
                                                          \
-    SC( 56,     18,       16,      1, yes,  no, no) \
+    SC( 56,     19,       17,      1, yes,  no, no) \
+    SC( 57,     19,       17,      2, yes,  no, no) \
+    SC( 58,     19,       17,      3, yes,  no, no) \
+    SC( 59,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 60,     20,       18,      1, yes,  no, no) \
+    SC( 61,     20,       18,      2, yes,  no, no) \
+    SC( 62,     20,       18,      3, yes,  no, no) \
+    SC( 63,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     21,       19,      1, yes,  no, no) \
+    SC( 65,     21,       19,      2, yes,  no, no) \
+    SC( 66,     21,       19,      3, yes,  no, no) \
+    SC( 67,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     22,       20,      1, yes,  no, no) \
+    SC( 69,     22,       20,      2, yes,  no, no) \
+    SC( 70,     22,       20,      3, yes,  no, no) \
+    SC( 71,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 72,     23,       21,      1, yes,  no, no) \
+    SC( 73,     23,       21,      2, yes,  no, no) \
+    SC( 74,     23,       21,      3, yes,  no, no) \
+    SC( 75,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 76,     24,       22,      1, yes,  no, no) \
+    SC( 77,     24,       22,      2, yes,  no, no) \
+    SC( 78,     24,       22,      3, yes,  no, no) \
+    SC( 79,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 80,     25,       23,      1, yes,  no, no) \
+    SC( 81,     25,       23,      2, yes,  no, no) \
+    SC( 82,     25,       23,      3, yes,  no, no) \
+    SC( 83,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 84,     26,       24,      1, yes,  no, no) \
+    SC( 85,     26,       24,      2, yes,  no, no) \
+    SC( 86,     26,       24,      3, yes,  no, no) \
+    SC( 87,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 88,     27,       25,      1, yes,  no, no) \
+    SC( 89,     27,       25,      2, yes,  no, no) \
+    SC( 90,     27,       25,      3, yes,  no, no) \
+    SC( 91,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 92,     28,       26,      1, yes,  no, no) \
+    SC( 93,     28,       26,      2, yes,  no, no) \
+    SC( 94,     28,       26,      3, yes,  no, no) \
+    SC( 95,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC( 96,     29,       27,      1, yes,  no, no) \
+    SC( 97,     29,       27,      2, yes,  no, no) \
+    SC( 98,     29,       27,      3, yes,  no, no) \
+    SC( 99,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(100,     30,       28,      1, yes,  no, no) \
+    SC(101,     30,       28,      2, yes,  no, no) \
+    SC(102,     30,       28,      3, yes,  no, no) \
+
+#define	SIZE_CLASSES_DEFINED
+#define	NTBINS			0
+#define	NLBINS			28
+#define	NBINS			43
+#define	NSIZES			103
+#define	NPSIZES			63
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define	LG_LARGE_MINCLASS	16
+#define	HUGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      3,        3,      2,  no, yes,  3) \
+    SC(  3,      3,        3,      3,  no, yes,  3) \
+                                                         \
+    SC(  4,      5,        3,      1,  no, yes,  3) \
+    SC(  5,      5,        3,      2,  no, yes,  3) \
+    SC(  6,      5,        3,      3,  no, yes,  3) \
+    SC(  7,      5,        3,      4,  no, yes,  3) \
+                                                         \
+    SC(  8,      6,        4,      1,  no, yes,  4) \
+    SC(  9,      6,        4,      2,  no, yes,  4) \
+    SC( 10,      6,        4,      3,  no, yes,  4) \
+    SC( 11,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC( 12,      7,        5,      1,  no, yes,  5) \
+    SC( 13,      7,        5,      2,  no, yes,  5) \
+    SC( 14,      7,        5,      3,  no, yes,  5) \
+    SC( 15,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 16,      8,        6,      1,  no, yes,  6) \
+    SC( 17,      8,        6,      2,  no, yes,  6) \
+    SC( 18,      8,        6,      3,  no, yes,  6) \
+    SC( 19,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 20,      9,        7,      1,  no, yes,  7) \
+    SC( 21,      9,        7,      2,  no, yes,  7) \
+    SC( 22,      9,        7,      3,  no, yes,  7) \
+    SC( 23,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 24,     10,        8,      1,  no, yes,  8) \
+    SC( 25,     10,        8,      2,  no, yes,  8) \
+    SC( 26,     10,        8,      3,  no, yes,  8) \
+    SC( 27,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 28,     11,        9,      1,  no, yes,  9) \
+    SC( 29,     11,        9,      2,  no, yes,  9) \
+    SC( 30,     11,        9,      3,  no, yes,  9) \
+    SC( 31,     11,        9,      4, yes, yes,  9) \
+                                                         \
+    SC( 32,     12,       10,      1,  no, yes, no) \
+    SC( 33,     12,       10,      2,  no, yes, no) \
+    SC( 34,     12,       10,      3,  no, yes, no) \
+    SC( 35,     12,       10,      4, yes, yes, no) \
+                                                         \
+    SC( 36,     13,       11,      1,  no, yes, no) \
+    SC( 37,     13,       11,      2, yes, yes, no) \
+    SC( 38,     13,       11,      3,  no, yes, no) \
+    SC( 39,     13,       11,      4, yes,  no, no) \
+                                                         \
+    SC( 40,     14,       12,      1, yes,  no, no) \
+    SC( 41,     14,       12,      2, yes,  no, no) \
+    SC( 42,     14,       12,      3, yes,  no, no) \
+    SC( 43,     14,       12,      4, yes,  no, no) \
+                                                         \
+    SC( 44,     15,       13,      1, yes,  no, no) \
+    SC( 45,     15,       13,      2, yes,  no, no) \
+    SC( 46,     15,       13,      3, yes,  no, no) \
+    SC( 47,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 48,     16,       14,      1, yes,  no, no) \
+    SC( 49,     16,       14,      2, yes,  no, no) \
+    SC( 50,     16,       14,      3, yes,  no, no) \
+    SC( 51,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 52,     17,       15,      1, yes,  no, no) \
+    SC( 53,     17,       15,      2, yes,  no, no) \
+    SC( 54,     17,       15,      3, yes,  no, no) \
+    SC( 55,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 56,     18,       16,      1, yes,  no, no) \
     SC( 57,     18,       16,      2, yes,  no, no) \
     SC( 58,     18,       16,      3, yes,  no, no) \
     SC( 59,     18,       16,      4, yes,  no, no) \
@@ -783,314 +1225,1236 @@
 #define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif
 
-#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 14)
 #define	SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
     SC(  0,      3,        3,      0,  no, yes,  3) \
-                                                         \
     SC(  1,      3,        3,      1,  no, yes,  3) \
-    SC(  2,      4,        4,      1,  no, yes,  4) \
-    SC(  3,      4,        4,      2,  no, yes,  4) \
-    SC(  4,      4,        4,      3,  no, yes,  4) \
-                                                         \
-    SC(  5,      6,        4,      1,  no, yes,  4) \
-    SC(  6,      6,        4,      2,  no, yes,  4) \
-    SC(  7,      6,        4,      3,  no, yes,  4) \
-    SC(  8,      6,        4,      4,  no, yes,  4) \
+    SC(  2,      3,        3,      2,  no, yes,  3) \
+    SC(  3,      3,        3,      3,  no, yes,  3) \
                                                          \
-    SC(  9,      7,        5,      1,  no, yes,  5) \
-    SC( 10,      7,        5,      2,  no, yes,  5) \
-    SC( 11,      7,        5,      3,  no, yes,  5) \
-    SC( 12,      7,        5,      4,  no, yes,  5) \
+    SC(  4,      5,        3,      1,  no, yes,  3) \
+    SC(  5,      5,        3,      2,  no, yes,  3) \
+    SC(  6,      5,        3,      3,  no, yes,  3) \
+    SC(  7,      5,        3,      4,  no, yes,  3) \
                                                          \
-    SC( 13,      8,        6,      1,  no, yes,  6) \
-    SC( 14,      8,        6,      2,  no, yes,  6) \
-    SC( 15,      8,        6,      3,  no, yes,  6) \
-    SC( 16,      8,        6,      4,  no, yes,  6) \
+    SC(  8,      6,        4,      1,  no, yes,  4) \
+    SC(  9,      6,        4,      2,  no, yes,  4) \
+    SC( 10,      6,        4,      3,  no, yes,  4) \
+    SC( 11,      6,        4,      4,  no, yes,  4) \
                                                          \
-    SC( 17,      9,        7,      1,  no, yes,  7) \
-    SC( 18,      9,        7,      2,  no, yes,  7) \
-    SC( 19,      9,        7,      3,  no, yes,  7) \
-    SC( 20,      9,        7,      4,  no, yes,  7) \
+    SC( 12,      7,        5,      1,  no, yes,  5) \
+    SC( 13,      7,        5,      2,  no, yes,  5) \
+    SC( 14,      7,        5,      3,  no, yes,  5) \
+    SC( 15,      7,        5,      4,  no, yes,  5) \
                                                          \
-    SC( 21,     10,        8,      1,  no, yes,  8) \
-    SC( 22,     10,        8,      2,  no, yes,  8) \
-    SC( 23,     10,        8,      3,  no, yes,  8) \
-    SC( 24,     10,        8,      4,  no, yes,  8) \
+    SC( 16,      8,        6,      1,  no, yes,  6) \
+    SC( 17,      8,        6,      2,  no, yes,  6) \
+    SC( 18,      8,        6,      3,  no, yes,  6) \
+    SC( 19,      8,        6,      4,  no, yes,  6) \
                                                          \
-    SC( 25,     11,        9,      1,  no, yes,  9) \
-    SC( 26,     11,        9,      2,  no, yes,  9) \
-    SC( 27,     11,        9,      3,  no, yes,  9) \
-    SC( 28,     11,        9,      4, yes, yes,  9) \
+    SC( 20,      9,        7,      1,  no, yes,  7) \
+    SC( 21,      9,        7,      2,  no, yes,  7) \
+    SC( 22,      9,        7,      3,  no, yes,  7) \
+    SC( 23,      9,        7,      4,  no, yes,  7) \
                                                          \
-    SC( 29,     12,       10,      1,  no, yes, no) \
-    SC( 30,     12,       10,      2,  no, yes, no) \
-    SC( 31,     12,       10,      3,  no, yes, no) \
-    SC( 32,     12,       10,      4, yes, yes, no) \
+    SC( 24,     10,        8,      1,  no, yes,  8) \
+    SC( 25,     10,        8,      2,  no, yes,  8) \
+    SC( 26,     10,        8,      3,  no, yes,  8) \
+    SC( 27,     10,        8,      4,  no, yes,  8) \
                                                          \
-    SC( 33,     13,       11,      1,  no, yes, no) \
-    SC( 34,     13,       11,      2, yes, yes, no) \
-    SC( 35,     13,       11,      3,  no, yes, no) \
-    SC( 36,     13,       11,      4, yes,  no, no) \
+    SC( 28,     11,        9,      1,  no, yes,  9) \
+    SC( 29,     11,        9,      2,  no, yes,  9) \
+    SC( 30,     11,        9,      3,  no, yes,  9) \
+    SC( 31,     11,        9,      4,  no, yes,  9) \
                                                          \
-    SC( 37,     14,       12,      1, yes,  no, no) \
-    SC( 38,     14,       12,      2, yes,  no, no) \
-    SC( 39,     14,       12,      3, yes,  no, no) \
-    SC( 40,     14,       12,      4, yes,  no, no) \
+    SC( 32,     12,       10,      1,  no, yes, no) \
+    SC( 33,     12,       10,      2,  no, yes, no) \
+    SC( 34,     12,       10,      3,  no, yes, no) \
+    SC( 35,     12,       10,      4,  no, yes, no) \
                                                          \
-    SC( 41,     15,       13,      1, yes,  no, no) \
-    SC( 42,     15,       13,      2, yes,  no, no) \
-    SC( 43,     15,       13,      3, yes,  no, no) \
-    SC( 44,     15,       13,      4, yes,  no, no) \
+    SC( 36,     13,       11,      1,  no, yes, no) \
+    SC( 37,     13,       11,      2,  no, yes, no) \
+    SC( 38,     13,       11,      3,  no, yes, no) \
+    SC( 39,     13,       11,      4, yes, yes, no) \
                                                          \
-    SC( 45,     16,       14,      1, yes,  no, no) \
-    SC( 46,     16,       14,      2, yes,  no, no) \
-    SC( 47,     16,       14,      3, yes,  no, no) \
-    SC( 48,     16,       14,      4, yes,  no, no) \
+    SC( 40,     14,       12,      1,  no, yes, no) \
+    SC( 41,     14,       12,      2,  no, yes, no) \
+    SC( 42,     14,       12,      3,  no, yes, no) \
+    SC( 43,     14,       12,      4, yes, yes, no) \
                                                          \
-    SC( 49,     17,       15,      1, yes,  no, no) \
-    SC( 50,     17,       15,      2, yes,  no, no) \
-    SC( 51,     17,       15,      3, yes,  no, no) \
-    SC( 52,     17,       15,      4, yes,  no, no) \
+    SC( 44,     15,       13,      1,  no, yes, no) \
+    SC( 45,     15,       13,      2, yes, yes, no) \
+    SC( 46,     15,       13,      3,  no, yes, no) \
+    SC( 47,     15,       13,      4, yes,  no, no) \
                                                          \
-    SC( 53,     18,       16,      1, yes,  no, no) \
-    SC( 54,     18,       16,      2, yes,  no, no) \
-    SC( 55,     18,       16,      3, yes,  no, no) \
-    SC( 56,     18,       16,      4, yes,  no, no) \
+    SC( 48,     16,       14,      1, yes,  no, no) \
+    SC( 49,     16,       14,      2, yes,  no, no) \
+    SC( 50,     16,       14,      3, yes,  no, no) \
+    SC( 51,     16,       14,      4, yes,  no, no) \
                                                          \
-    SC( 57,     19,       17,      1, yes,  no, no) \
-    SC( 58,     19,       17,      2, yes,  no, no) \
-    SC( 59,     19,       17,      3, yes,  no, no) \
-    SC( 60,     19,       17,      4, yes,  no, no) \
+    SC( 52,     17,       15,      1, yes,  no, no) \
+    SC( 53,     17,       15,      2, yes,  no, no) \
+    SC( 54,     17,       15,      3, yes,  no, no) \
+    SC( 55,     17,       15,      4, yes,  no, no) \
                                                          \
-    SC( 61,     20,       18,      1, yes,  no, no) \
-    SC( 62,     20,       18,      2, yes,  no, no) \
-    SC( 63,     20,       18,      3, yes,  no, no) \
-    SC( 64,     20,       18,      4, yes,  no, no) \
+    SC( 56,     18,       16,      1, yes,  no, no) \
+    SC( 57,     18,       16,      2, yes,  no, no) \
+    SC( 58,     18,       16,      3, yes,  no, no) \
+    SC( 59,     18,       16,      4, yes,  no, no) \
                                                          \
-    SC( 65,     21,       19,      1, yes,  no, no) \
+    SC( 60,     19,       17,      1, yes,  no, no) \
+    SC( 61,     19,       17,      2, yes,  no, no) \
+    SC( 62,     19,       17,      3, yes,  no, no) \
+    SC( 63,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     20,       18,      1, yes,  no, no) \
+    SC( 65,     20,       18,      2, yes,  no, no) \
+    SC( 66,     20,       18,      3, yes,  no, no) \
+    SC( 67,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     21,       19,      1, yes,  no, no) \
+    SC( 69,     21,       19,      2, yes,  no, no) \
+    SC( 70,     21,       19,      3, yes,  no, no) \
+    SC( 71,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 72,     22,       20,      1, yes,  no, no) \
+    SC( 73,     22,       20,      2, yes,  no, no) \
+    SC( 74,     22,       20,      3, yes,  no, no) \
+    SC( 75,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 76,     23,       21,      1, yes,  no, no) \
+    SC( 77,     23,       21,      2, yes,  no, no) \
+    SC( 78,     23,       21,      3, yes,  no, no) \
+    SC( 79,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 80,     24,       22,      1, yes,  no, no) \
+    SC( 81,     24,       22,      2, yes,  no, no) \
+    SC( 82,     24,       22,      3, yes,  no, no) \
+    SC( 83,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 84,     25,       23,      1, yes,  no, no) \
+    SC( 85,     25,       23,      2, yes,  no, no) \
+    SC( 86,     25,       23,      3, yes,  no, no) \
+    SC( 87,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 88,     26,       24,      1, yes,  no, no) \
+    SC( 89,     26,       24,      2, yes,  no, no) \
+    SC( 90,     26,       24,      3, yes,  no, no) \
+    SC( 91,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 92,     27,       25,      1, yes,  no, no) \
+    SC( 93,     27,       25,      2, yes,  no, no) \
+    SC( 94,     27,       25,      3, yes,  no, no) \
+    SC( 95,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 96,     28,       26,      1, yes,  no, no) \
+    SC( 97,     28,       26,      2, yes,  no, no) \
+    SC( 98,     28,       26,      3, yes,  no, no) \
+    SC( 99,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC(100,     29,       27,      1, yes,  no, no) \
+    SC(101,     29,       27,      2, yes,  no, no) \
+    SC(102,     29,       27,      3, yes,  no, no) \
+    SC(103,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(104,     30,       28,      1, yes,  no, no) \
+    SC(105,     30,       28,      2, yes,  no, no) \
+    SC(106,     30,       28,      3, yes,  no, no) \
+    SC(107,     30,       28,      4, yes,  no, no) \
+                                                         \
+    SC(108,     31,       29,      1, yes,  no, no) \
+    SC(109,     31,       29,      2, yes,  no, no) \
+    SC(110,     31,       29,      3, yes,  no, no) \
+    SC(111,     31,       29,      4, yes,  no, no) \
+                                                         \
+    SC(112,     32,       30,      1, yes,  no, no) \
+    SC(113,     32,       30,      2, yes,  no, no) \
+    SC(114,     32,       30,      3, yes,  no, no) \
+    SC(115,     32,       30,      4, yes,  no, no) \
+                                                         \
+    SC(116,     33,       31,      1, yes,  no, no) \
+    SC(117,     33,       31,      2, yes,  no, no) \
+    SC(118,     33,       31,      3, yes,  no, no) \
+    SC(119,     33,       31,      4, yes,  no, no) \
+                                                         \
+    SC(120,     34,       32,      1, yes,  no, no) \
+    SC(121,     34,       32,      2, yes,  no, no) \
+    SC(122,     34,       32,      3, yes,  no, no) \
+    SC(123,     34,       32,      4, yes,  no, no) \
+                                                         \
+    SC(124,     35,       33,      1, yes,  no, no) \
+    SC(125,     35,       33,      2, yes,  no, no) \
+    SC(126,     35,       33,      3, yes,  no, no) \
+    SC(127,     35,       33,      4, yes,  no, no) \
+                                                         \
+    SC(128,     36,       34,      1, yes,  no, no) \
+    SC(129,     36,       34,      2, yes,  no, no) \
+    SC(130,     36,       34,      3, yes,  no, no) \
+    SC(131,     36,       34,      4, yes,  no, no) \
+                                                         \
+    SC(132,     37,       35,      1, yes,  no, no) \
+    SC(133,     37,       35,      2, yes,  no, no) \
+    SC(134,     37,       35,      3, yes,  no, no) \
+    SC(135,     37,       35,      4, yes,  no, no) \
+                                                         \
+    SC(136,     38,       36,      1, yes,  no, no) \
+    SC(137,     38,       36,      2, yes,  no, no) \
+    SC(138,     38,       36,      3, yes,  no, no) \
+    SC(139,     38,       36,      4, yes,  no, no) \
+                                                         \
+    SC(140,     39,       37,      1, yes,  no, no) \
+    SC(141,     39,       37,      2, yes,  no, no) \
+    SC(142,     39,       37,      3, yes,  no, no) \
+    SC(143,     39,       37,      4, yes,  no, no) \
+                                                         \
+    SC(144,     40,       38,      1, yes,  no, no) \
+    SC(145,     40,       38,      2, yes,  no, no) \
+    SC(146,     40,       38,      3, yes,  no, no) \
+    SC(147,     40,       38,      4, yes,  no, no) \
+                                                         \
+    SC(148,     41,       39,      1, yes,  no, no) \
+    SC(149,     41,       39,      2, yes,  no, no) \
+    SC(150,     41,       39,      3, yes,  no, no) \
+    SC(151,     41,       39,      4, yes,  no, no) \
+                                                         \
+    SC(152,     42,       40,      1, yes,  no, no) \
+    SC(153,     42,       40,      2, yes,  no, no) \
+    SC(154,     42,       40,      3, yes,  no, no) \
+    SC(155,     42,       40,      4, yes,  no, no) \
+                                                         \
+    SC(156,     43,       41,      1, yes,  no, no) \
+    SC(157,     43,       41,      2, yes,  no, no) \
+    SC(158,     43,       41,      3, yes,  no, no) \
+    SC(159,     43,       41,      4, yes,  no, no) \
+                                                         \
+    SC(160,     44,       42,      1, yes,  no, no) \
+    SC(161,     44,       42,      2, yes,  no, no) \
+    SC(162,     44,       42,      3, yes,  no, no) \
+    SC(163,     44,       42,      4, yes,  no, no) \
+                                                         \
+    SC(164,     45,       43,      1, yes,  no, no) \
+    SC(165,     45,       43,      2, yes,  no, no) \
+    SC(166,     45,       43,      3, yes,  no, no) \
+    SC(167,     45,       43,      4, yes,  no, no) \
+                                                         \
+    SC(168,     46,       44,      1, yes,  no, no) \
+    SC(169,     46,       44,      2, yes,  no, no) \
+    SC(170,     46,       44,      3, yes,  no, no) \
+    SC(171,     46,       44,      4, yes,  no, no) \
+                                                         \
+    SC(172,     47,       45,      1, yes,  no, no) \
+    SC(173,     47,       45,      2, yes,  no, no) \
+    SC(174,     47,       45,      3, yes,  no, no) \
+    SC(175,     47,       45,      4, yes,  no, no) \
+                                                         \
+    SC(176,     48,       46,      1, yes,  no, no) \
+    SC(177,     48,       46,      2, yes,  no, no) \
+    SC(178,     48,       46,      3, yes,  no, no) \
+    SC(179,     48,       46,      4, yes,  no, no) \
+                                                         \
+    SC(180,     49,       47,      1, yes,  no, no) \
+    SC(181,     49,       47,      2, yes,  no, no) \
+    SC(182,     49,       47,      3, yes,  no, no) \
+    SC(183,     49,       47,      4, yes,  no, no) \
+                                                         \
+    SC(184,     50,       48,      1, yes,  no, no) \
+    SC(185,     50,       48,      2, yes,  no, no) \
+    SC(186,     50,       48,      3, yes,  no, no) \
+    SC(187,     50,       48,      4, yes,  no, no) \
+                                                         \
+    SC(188,     51,       49,      1, yes,  no, no) \
+    SC(189,     51,       49,      2, yes,  no, no) \
+    SC(190,     51,       49,      3, yes,  no, no) \
+    SC(191,     51,       49,      4, yes,  no, no) \
+                                                         \
+    SC(192,     52,       50,      1, yes,  no, no) \
+    SC(193,     52,       50,      2, yes,  no, no) \
+    SC(194,     52,       50,      3, yes,  no, no) \
+    SC(195,     52,       50,      4, yes,  no, no) \
+                                                         \
+    SC(196,     53,       51,      1, yes,  no, no) \
+    SC(197,     53,       51,      2, yes,  no, no) \
+    SC(198,     53,       51,      3, yes,  no, no) \
+    SC(199,     53,       51,      4, yes,  no, no) \
+                                                         \
+    SC(200,     54,       52,      1, yes,  no, no) \
+    SC(201,     54,       52,      2, yes,  no, no) \
+    SC(202,     54,       52,      3, yes,  no, no) \
+    SC(203,     54,       52,      4, yes,  no, no) \
+                                                         \
+    SC(204,     55,       53,      1, yes,  no, no) \
+    SC(205,     55,       53,      2, yes,  no, no) \
+    SC(206,     55,       53,      3, yes,  no, no) \
+    SC(207,     55,       53,      4, yes,  no, no) \
+                                                         \
+    SC(208,     56,       54,      1, yes,  no, no) \
+    SC(209,     56,       54,      2, yes,  no, no) \
+    SC(210,     56,       54,      3, yes,  no, no) \
+    SC(211,     56,       54,      4, yes,  no, no) \
+                                                         \
+    SC(212,     57,       55,      1, yes,  no, no) \
+    SC(213,     57,       55,      2, yes,  no, no) \
+    SC(214,     57,       55,      3, yes,  no, no) \
+    SC(215,     57,       55,      4, yes,  no, no) \
+                                                         \
+    SC(216,     58,       56,      1, yes,  no, no) \
+    SC(217,     58,       56,      2, yes,  no, no) \
+    SC(218,     58,       56,      3, yes,  no, no) \
+    SC(219,     58,       56,      4, yes,  no, no) \
+                                                         \
+    SC(220,     59,       57,      1, yes,  no, no) \
+    SC(221,     59,       57,      2, yes,  no, no) \
+    SC(222,     59,       57,      3, yes,  no, no) \
+    SC(223,     59,       57,      4, yes,  no, no) \
+                                                         \
+    SC(224,     60,       58,      1, yes,  no, no) \
+    SC(225,     60,       58,      2, yes,  no, no) \
+    SC(226,     60,       58,      3, yes,  no, no) \
+    SC(227,     60,       58,      4, yes,  no, no) \
+                                                         \
+    SC(228,     61,       59,      1, yes,  no, no) \
+    SC(229,     61,       59,      2, yes,  no, no) \
+    SC(230,     61,       59,      3, yes,  no, no) \
+    SC(231,     61,       59,      4, yes,  no, no) \
+                                                         \
+    SC(232,     62,       60,      1, yes,  no, no) \
+    SC(233,     62,       60,      2, yes,  no, no) \
+    SC(234,     62,       60,      3, yes,  no, no) \
+
+#define	SIZE_CLASSES_DEFINED
+#define	NTBINS			0
+#define	NLBINS			32
+#define	NBINS			47
+#define	NSIZES			235
+#define	NPSIZES			191
+#define	LG_TINY_MAXCLASS	"NA"
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define	LG_LARGE_MINCLASS	16
+#define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
+                                                         \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      4,        4,      1,  no, yes,  4) \
+    SC(  3,      4,        4,      2,  no, yes,  4) \
+    SC(  4,      4,        4,      3,  no, yes,  4) \
+                                                         \
+    SC(  5,      6,        4,      1,  no, yes,  4) \
+    SC(  6,      6,        4,      2,  no, yes,  4) \
+    SC(  7,      6,        4,      3,  no, yes,  4) \
+    SC(  8,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC(  9,      7,        5,      1,  no, yes,  5) \
+    SC( 10,      7,        5,      2,  no, yes,  5) \
+    SC( 11,      7,        5,      3,  no, yes,  5) \
+    SC( 12,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 13,      8,        6,      1,  no, yes,  6) \
+    SC( 14,      8,        6,      2,  no, yes,  6) \
+    SC( 15,      8,        6,      3,  no, yes,  6) \
+    SC( 16,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 17,      9,        7,      1,  no, yes,  7) \
+    SC( 18,      9,        7,      2,  no, yes,  7) \
+    SC( 19,      9,        7,      3,  no, yes,  7) \
+    SC( 20,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 21,     10,        8,      1,  no, yes,  8) \
+    SC( 22,     10,        8,      2,  no, yes,  8) \
+    SC( 23,     10,        8,      3,  no, yes,  8) \
+    SC( 24,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 25,     11,        9,      1,  no, yes,  9) \
+    SC( 26,     11,        9,      2,  no, yes,  9) \
+    SC( 27,     11,        9,      3,  no, yes,  9) \
+    SC( 28,     11,        9,      4, yes, yes,  9) \
+                                                         \
+    SC( 29,     12,       10,      1,  no, yes, no) \
+    SC( 30,     12,       10,      2,  no, yes, no) \
+    SC( 31,     12,       10,      3,  no, yes, no) \
+    SC( 32,     12,       10,      4, yes, yes, no) \
+                                                         \
+    SC( 33,     13,       11,      1,  no, yes, no) \
+    SC( 34,     13,       11,      2, yes, yes, no) \
+    SC( 35,     13,       11,      3,  no, yes, no) \
+    SC( 36,     13,       11,      4, yes,  no, no) \
+                                                         \
+    SC( 37,     14,       12,      1, yes,  no, no) \
+    SC( 38,     14,       12,      2, yes,  no, no) \
+    SC( 39,     14,       12,      3, yes,  no, no) \
+    SC( 40,     14,       12,      4, yes,  no, no) \
+                                                         \
+    SC( 41,     15,       13,      1, yes,  no, no) \
+    SC( 42,     15,       13,      2, yes,  no, no) \
+    SC( 43,     15,       13,      3, yes,  no, no) \
+    SC( 44,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 45,     16,       14,      1, yes,  no, no) \
+    SC( 46,     16,       14,      2, yes,  no, no) \
+    SC( 47,     16,       14,      3, yes,  no, no) \
+    SC( 48,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 49,     17,       15,      1, yes,  no, no) \
+    SC( 50,     17,       15,      2, yes,  no, no) \
+    SC( 51,     17,       15,      3, yes,  no, no) \
+    SC( 52,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 53,     18,       16,      1, yes,  no, no) \
+    SC( 54,     18,       16,      2, yes,  no, no) \
+    SC( 55,     18,       16,      3, yes,  no, no) \
+    SC( 56,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 57,     19,       17,      1, yes,  no, no) \
+    SC( 58,     19,       17,      2, yes,  no, no) \
+    SC( 59,     19,       17,      3, yes,  no, no) \
+    SC( 60,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 61,     20,       18,      1, yes,  no, no) \
+    SC( 62,     20,       18,      2, yes,  no, no) \
+    SC( 63,     20,       18,      3, yes,  no, no) \
+    SC( 64,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 65,     21,       19,      1, yes,  no, no) \
+    SC( 66,     21,       19,      2, yes,  no, no) \
+    SC( 67,     21,       19,      3, yes,  no, no) \
+    SC( 68,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 69,     22,       20,      1, yes,  no, no) \
+    SC( 70,     22,       20,      2, yes,  no, no) \
+    SC( 71,     22,       20,      3, yes,  no, no) \
+    SC( 72,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 73,     23,       21,      1, yes,  no, no) \
+    SC( 74,     23,       21,      2, yes,  no, no) \
+    SC( 75,     23,       21,      3, yes,  no, no) \
+    SC( 76,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 77,     24,       22,      1, yes,  no, no) \
+    SC( 78,     24,       22,      2, yes,  no, no) \
+    SC( 79,     24,       22,      3, yes,  no, no) \
+    SC( 80,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 81,     25,       23,      1, yes,  no, no) \
+    SC( 82,     25,       23,      2, yes,  no, no) \
+    SC( 83,     25,       23,      3, yes,  no, no) \
+    SC( 84,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 85,     26,       24,      1, yes,  no, no) \
+    SC( 86,     26,       24,      2, yes,  no, no) \
+    SC( 87,     26,       24,      3, yes,  no, no) \
+    SC( 88,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 89,     27,       25,      1, yes,  no, no) \
+    SC( 90,     27,       25,      2, yes,  no, no) \
+    SC( 91,     27,       25,      3, yes,  no, no) \
+    SC( 92,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 93,     28,       26,      1, yes,  no, no) \
+    SC( 94,     28,       26,      2, yes,  no, no) \
+    SC( 95,     28,       26,      3, yes,  no, no) \
+    SC( 96,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC( 97,     29,       27,      1, yes,  no, no) \
+    SC( 98,     29,       27,      2, yes,  no, no) \
+    SC( 99,     29,       27,      3, yes,  no, no) \
+    SC(100,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(101,     30,       28,      1, yes,  no, no) \
+    SC(102,     30,       28,      2, yes,  no, no) \
+    SC(103,     30,       28,      3, yes,  no, no) \
+    SC(104,     30,       28,      4, yes,  no, no) \
+                                                         \
+    SC(105,     31,       29,      1, yes,  no, no) \
+    SC(106,     31,       29,      2, yes,  no, no) \
+    SC(107,     31,       29,      3, yes,  no, no) \
+    SC(108,     31,       29,      4, yes,  no, no) \
+                                                         \
+    SC(109,     32,       30,      1, yes,  no, no) \
+    SC(110,     32,       30,      2, yes,  no, no) \
+    SC(111,     32,       30,      3, yes,  no, no) \
+    SC(112,     32,       30,      4, yes,  no, no) \
+                                                         \
+    SC(113,     33,       31,      1, yes,  no, no) \
+    SC(114,     33,       31,      2, yes,  no, no) \
+    SC(115,     33,       31,      3, yes,  no, no) \
+    SC(116,     33,       31,      4, yes,  no, no) \
+                                                         \
+    SC(117,     34,       32,      1, yes,  no, no) \
+    SC(118,     34,       32,      2, yes,  no, no) \
+    SC(119,     34,       32,      3, yes,  no, no) \
+    SC(120,     34,       32,      4, yes,  no, no) \
+                                                         \
+    SC(121,     35,       33,      1, yes,  no, no) \
+    SC(122,     35,       33,      2, yes,  no, no) \
+    SC(123,     35,       33,      3, yes,  no, no) \
+    SC(124,     35,       33,      4, yes,  no, no) \
+                                                         \
+    SC(125,     36,       34,      1, yes,  no, no) \
+    SC(126,     36,       34,      2, yes,  no, no) \
+    SC(127,     36,       34,      3, yes,  no, no) \
+    SC(128,     36,       34,      4, yes,  no, no) \
+                                                         \
+    SC(129,     37,       35,      1, yes,  no, no) \
+    SC(130,     37,       35,      2, yes,  no, no) \
+    SC(131,     37,       35,      3, yes,  no, no) \
+    SC(132,     37,       35,      4, yes,  no, no) \
+                                                         \
+    SC(133,     38,       36,      1, yes,  no, no) \
+    SC(134,     38,       36,      2, yes,  no, no) \
+    SC(135,     38,       36,      3, yes,  no, no) \
+    SC(136,     38,       36,      4, yes,  no, no) \
+                                                         \
+    SC(137,     39,       37,      1, yes,  no, no) \
+    SC(138,     39,       37,      2, yes,  no, no) \
+    SC(139,     39,       37,      3, yes,  no, no) \
+    SC(140,     39,       37,      4, yes,  no, no) \
+                                                         \
+    SC(141,     40,       38,      1, yes,  no, no) \
+    SC(142,     40,       38,      2, yes,  no, no) \
+    SC(143,     40,       38,      3, yes,  no, no) \
+    SC(144,     40,       38,      4, yes,  no, no) \
+                                                         \
+    SC(145,     41,       39,      1, yes,  no, no) \
+    SC(146,     41,       39,      2, yes,  no, no) \
+    SC(147,     41,       39,      3, yes,  no, no) \
+    SC(148,     41,       39,      4, yes,  no, no) \
+                                                         \
+    SC(149,     42,       40,      1, yes,  no, no) \
+    SC(150,     42,       40,      2, yes,  no, no) \
+    SC(151,     42,       40,      3, yes,  no, no) \
+    SC(152,     42,       40,      4, yes,  no, no) \
+                                                         \
+    SC(153,     43,       41,      1, yes,  no, no) \
+    SC(154,     43,       41,      2, yes,  no, no) \
+    SC(155,     43,       41,      3, yes,  no, no) \
+    SC(156,     43,       41,      4, yes,  no, no) \
+                                                         \
+    SC(157,     44,       42,      1, yes,  no, no) \
+    SC(158,     44,       42,      2, yes,  no, no) \
+    SC(159,     44,       42,      3, yes,  no, no) \
+    SC(160,     44,       42,      4, yes,  no, no) \
+                                                         \
+    SC(161,     45,       43,      1, yes,  no, no) \
+    SC(162,     45,       43,      2, yes,  no, no) \
+    SC(163,     45,       43,      3, yes,  no, no) \
+    SC(164,     45,       43,      4, yes,  no, no) \
+                                                         \
+    SC(165,     46,       44,      1, yes,  no, no) \
+    SC(166,     46,       44,      2, yes,  no, no) \
+    SC(167,     46,       44,      3, yes,  no, no) \
+    SC(168,     46,       44,      4, yes,  no, no) \
+                                                         \
+    SC(169,     47,       45,      1, yes,  no, no) \
+    SC(170,     47,       45,      2, yes,  no, no) \
+    SC(171,     47,       45,      3, yes,  no, no) \
+    SC(172,     47,       45,      4, yes,  no, no) \
+                                                         \
+    SC(173,     48,       46,      1, yes,  no, no) \
+    SC(174,     48,       46,      2, yes,  no, no) \
+    SC(175,     48,       46,      3, yes,  no, no) \
+    SC(176,     48,       46,      4, yes,  no, no) \
+                                                         \
+    SC(177,     49,       47,      1, yes,  no, no) \
+    SC(178,     49,       47,      2, yes,  no, no) \
+    SC(179,     49,       47,      3, yes,  no, no) \
+    SC(180,     49,       47,      4, yes,  no, no) \
+                                                         \
+    SC(181,     50,       48,      1, yes,  no, no) \
+    SC(182,     50,       48,      2, yes,  no, no) \
+    SC(183,     50,       48,      3, yes,  no, no) \
+    SC(184,     50,       48,      4, yes,  no, no) \
+                                                         \
+    SC(185,     51,       49,      1, yes,  no, no) \
+    SC(186,     51,       49,      2, yes,  no, no) \
+    SC(187,     51,       49,      3, yes,  no, no) \
+    SC(188,     51,       49,      4, yes,  no, no) \
+                                                         \
+    SC(189,     52,       50,      1, yes,  no, no) \
+    SC(190,     52,       50,      2, yes,  no, no) \
+    SC(191,     52,       50,      3, yes,  no, no) \
+    SC(192,     52,       50,      4, yes,  no, no) \
+                                                         \
+    SC(193,     53,       51,      1, yes,  no, no) \
+    SC(194,     53,       51,      2, yes,  no, no) \
+    SC(195,     53,       51,      3, yes,  no, no) \
+    SC(196,     53,       51,      4, yes,  no, no) \
+                                                         \
+    SC(197,     54,       52,      1, yes,  no, no) \
+    SC(198,     54,       52,      2, yes,  no, no) \
+    SC(199,     54,       52,      3, yes,  no, no) \
+    SC(200,     54,       52,      4, yes,  no, no) \
+                                                         \
+    SC(201,     55,       53,      1, yes,  no, no) \
+    SC(202,     55,       53,      2, yes,  no, no) \
+    SC(203,     55,       53,      3, yes,  no, no) \
+    SC(204,     55,       53,      4, yes,  no, no) \
+                                                         \
+    SC(205,     56,       54,      1, yes,  no, no) \
+    SC(206,     56,       54,      2, yes,  no, no) \
+    SC(207,     56,       54,      3, yes,  no, no) \
+    SC(208,     56,       54,      4, yes,  no, no) \
+                                                         \
+    SC(209,     57,       55,      1, yes,  no, no) \
+    SC(210,     57,       55,      2, yes,  no, no) \
+    SC(211,     57,       55,      3, yes,  no, no) \
+    SC(212,     57,       55,      4, yes,  no, no) \
+                                                         \
+    SC(213,     58,       56,      1, yes,  no, no) \
+    SC(214,     58,       56,      2, yes,  no, no) \
+    SC(215,     58,       56,      3, yes,  no, no) \
+    SC(216,     58,       56,      4, yes,  no, no) \
+                                                         \
+    SC(217,     59,       57,      1, yes,  no, no) \
+    SC(218,     59,       57,      2, yes,  no, no) \
+    SC(219,     59,       57,      3, yes,  no, no) \
+    SC(220,     59,       57,      4, yes,  no, no) \
+                                                         \
+    SC(221,     60,       58,      1, yes,  no, no) \
+    SC(222,     60,       58,      2, yes,  no, no) \
+    SC(223,     60,       58,      3, yes,  no, no) \
+    SC(224,     60,       58,      4, yes,  no, no) \
+                                                         \
+    SC(225,     61,       59,      1, yes,  no, no) \
+    SC(226,     61,       59,      2, yes,  no, no) \
+    SC(227,     61,       59,      3, yes,  no, no) \
+    SC(228,     61,       59,      4, yes,  no, no) \
+                                                         \
+    SC(229,     62,       60,      1, yes,  no, no) \
+    SC(230,     62,       60,      2, yes,  no, no) \
+    SC(231,     62,       60,      3, yes,  no, no) \
+
+#define	SIZE_CLASSES_DEFINED
+#define	NTBINS			1
+#define	NLBINS			29
+#define	NBINS			36
+#define	NSIZES			232
+#define	NPSIZES			199
+#define	LG_TINY_MAXCLASS	3
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define	LG_LARGE_MINCLASS	14
+#define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 14)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,  3) \
+                                                         \
+    SC(  1,      3,        3,      1,  no, yes,  3) \
+    SC(  2,      4,        4,      1,  no, yes,  4) \
+    SC(  3,      4,        4,      2,  no, yes,  4) \
+    SC(  4,      4,        4,      3,  no, yes,  4) \
+                                                         \
+    SC(  5,      6,        4,      1,  no, yes,  4) \
+    SC(  6,      6,        4,      2,  no, yes,  4) \
+    SC(  7,      6,        4,      3,  no, yes,  4) \
+    SC(  8,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC(  9,      7,        5,      1,  no, yes,  5) \
+    SC( 10,      7,        5,      2,  no, yes,  5) \
+    SC( 11,      7,        5,      3,  no, yes,  5) \
+    SC( 12,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 13,      8,        6,      1,  no, yes,  6) \
+    SC( 14,      8,        6,      2,  no, yes,  6) \
+    SC( 15,      8,        6,      3,  no, yes,  6) \
+    SC( 16,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 17,      9,        7,      1,  no, yes,  7) \
+    SC( 18,      9,        7,      2,  no, yes,  7) \
+    SC( 19,      9,        7,      3,  no, yes,  7) \
+    SC( 20,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 21,     10,        8,      1,  no, yes,  8) \
+    SC( 22,     10,        8,      2,  no, yes,  8) \
+    SC( 23,     10,        8,      3,  no, yes,  8) \
+    SC( 24,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 25,     11,        9,      1,  no, yes,  9) \
+    SC( 26,     11,        9,      2,  no, yes,  9) \
+    SC( 27,     11,        9,      3,  no, yes,  9) \
+    SC( 28,     11,        9,      4,  no, yes,  9) \
+                                                         \
+    SC( 29,     12,       10,      1,  no, yes, no) \
+    SC( 30,     12,       10,      2,  no, yes, no) \
+    SC( 31,     12,       10,      3,  no, yes, no) \
+    SC( 32,     12,       10,      4,  no, yes, no) \
+                                                         \
+    SC( 33,     13,       11,      1,  no, yes, no) \
+    SC( 34,     13,       11,      2,  no, yes, no) \
+    SC( 35,     13,       11,      3,  no, yes, no) \
+    SC( 36,     13,       11,      4, yes, yes, no) \
+                                                         \
+    SC( 37,     14,       12,      1,  no, yes, no) \
+    SC( 38,     14,       12,      2,  no, yes, no) \
+    SC( 39,     14,       12,      3,  no, yes, no) \
+    SC( 40,     14,       12,      4, yes, yes, no) \
+                                                         \
+    SC( 41,     15,       13,      1,  no, yes, no) \
+    SC( 42,     15,       13,      2, yes, yes, no) \
+    SC( 43,     15,       13,      3,  no, yes, no) \
+    SC( 44,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 45,     16,       14,      1, yes,  no, no) \
+    SC( 46,     16,       14,      2, yes,  no, no) \
+    SC( 47,     16,       14,      3, yes,  no, no) \
+    SC( 48,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 49,     17,       15,      1, yes,  no, no) \
+    SC( 50,     17,       15,      2, yes,  no, no) \
+    SC( 51,     17,       15,      3, yes,  no, no) \
+    SC( 52,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 53,     18,       16,      1, yes,  no, no) \
+    SC( 54,     18,       16,      2, yes,  no, no) \
+    SC( 55,     18,       16,      3, yes,  no, no) \
+    SC( 56,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 57,     19,       17,      1, yes,  no, no) \
+    SC( 58,     19,       17,      2, yes,  no, no) \
+    SC( 59,     19,       17,      3, yes,  no, no) \
+    SC( 60,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 61,     20,       18,      1, yes,  no, no) \
+    SC( 62,     20,       18,      2, yes,  no, no) \
+    SC( 63,     20,       18,      3, yes,  no, no) \
+    SC( 64,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 65,     21,       19,      1, yes,  no, no) \
     SC( 66,     21,       19,      2, yes,  no, no) \
     SC( 67,     21,       19,      3, yes,  no, no) \
     SC( 68,     21,       19,      4, yes,  no, no) \
                                                          \
-    SC( 69,     22,       20,      1, yes,  no, no) \
-    SC( 70,     22,       20,      2, yes,  no, no) \
-    SC( 71,     22,       20,      3, yes,  no, no) \
-    SC( 72,     22,       20,      4, yes,  no, no) \
+    SC( 69,     22,       20,      1, yes,  no, no) \
+    SC( 70,     22,       20,      2, yes,  no, no) \
+    SC( 71,     22,       20,      3, yes,  no, no) \
+    SC( 72,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 73,     23,       21,      1, yes,  no, no) \
+    SC( 74,     23,       21,      2, yes,  no, no) \
+    SC( 75,     23,       21,      3, yes,  no, no) \
+    SC( 76,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 77,     24,       22,      1, yes,  no, no) \
+    SC( 78,     24,       22,      2, yes,  no, no) \
+    SC( 79,     24,       22,      3, yes,  no, no) \
+    SC( 80,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 81,     25,       23,      1, yes,  no, no) \
+    SC( 82,     25,       23,      2, yes,  no, no) \
+    SC( 83,     25,       23,      3, yes,  no, no) \
+    SC( 84,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 85,     26,       24,      1, yes,  no, no) \
+    SC( 86,     26,       24,      2, yes,  no, no) \
+    SC( 87,     26,       24,      3, yes,  no, no) \
+    SC( 88,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 89,     27,       25,      1, yes,  no, no) \
+    SC( 90,     27,       25,      2, yes,  no, no) \
+    SC( 91,     27,       25,      3, yes,  no, no) \
+    SC( 92,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 93,     28,       26,      1, yes,  no, no) \
+    SC( 94,     28,       26,      2, yes,  no, no) \
+    SC( 95,     28,       26,      3, yes,  no, no) \
+    SC( 96,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC( 97,     29,       27,      1, yes,  no, no) \
+    SC( 98,     29,       27,      2, yes,  no, no) \
+    SC( 99,     29,       27,      3, yes,  no, no) \
+    SC(100,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(101,     30,       28,      1, yes,  no, no) \
+    SC(102,     30,       28,      2, yes,  no, no) \
+    SC(103,     30,       28,      3, yes,  no, no) \
+    SC(104,     30,       28,      4, yes,  no, no) \
+                                                         \
+    SC(105,     31,       29,      1, yes,  no, no) \
+    SC(106,     31,       29,      2, yes,  no, no) \
+    SC(107,     31,       29,      3, yes,  no, no) \
+    SC(108,     31,       29,      4, yes,  no, no) \
+                                                         \
+    SC(109,     32,       30,      1, yes,  no, no) \
+    SC(110,     32,       30,      2, yes,  no, no) \
+    SC(111,     32,       30,      3, yes,  no, no) \
+    SC(112,     32,       30,      4, yes,  no, no) \
+                                                         \
+    SC(113,     33,       31,      1, yes,  no, no) \
+    SC(114,     33,       31,      2, yes,  no, no) \
+    SC(115,     33,       31,      3, yes,  no, no) \
+    SC(116,     33,       31,      4, yes,  no, no) \
+                                                         \
+    SC(117,     34,       32,      1, yes,  no, no) \
+    SC(118,     34,       32,      2, yes,  no, no) \
+    SC(119,     34,       32,      3, yes,  no, no) \
+    SC(120,     34,       32,      4, yes,  no, no) \
+                                                         \
+    SC(121,     35,       33,      1, yes,  no, no) \
+    SC(122,     35,       33,      2, yes,  no, no) \
+    SC(123,     35,       33,      3, yes,  no, no) \
+    SC(124,     35,       33,      4, yes,  no, no) \
+                                                         \
+    SC(125,     36,       34,      1, yes,  no, no) \
+    SC(126,     36,       34,      2, yes,  no, no) \
+    SC(127,     36,       34,      3, yes,  no, no) \
+    SC(128,     36,       34,      4, yes,  no, no) \
+                                                         \
+    SC(129,     37,       35,      1, yes,  no, no) \
+    SC(130,     37,       35,      2, yes,  no, no) \
+    SC(131,     37,       35,      3, yes,  no, no) \
+    SC(132,     37,       35,      4, yes,  no, no) \
+                                                         \
+    SC(133,     38,       36,      1, yes,  no, no) \
+    SC(134,     38,       36,      2, yes,  no, no) \
+    SC(135,     38,       36,      3, yes,  no, no) \
+    SC(136,     38,       36,      4, yes,  no, no) \
+                                                         \
+    SC(137,     39,       37,      1, yes,  no, no) \
+    SC(138,     39,       37,      2, yes,  no, no) \
+    SC(139,     39,       37,      3, yes,  no, no) \
+    SC(140,     39,       37,      4, yes,  no, no) \
+                                                         \
+    SC(141,     40,       38,      1, yes,  no, no) \
+    SC(142,     40,       38,      2, yes,  no, no) \
+    SC(143,     40,       38,      3, yes,  no, no) \
+    SC(144,     40,       38,      4, yes,  no, no) \
+                                                         \
+    SC(145,     41,       39,      1, yes,  no, no) \
+    SC(146,     41,       39,      2, yes,  no, no) \
+    SC(147,     41,       39,      3, yes,  no, no) \
+    SC(148,     41,       39,      4, yes,  no, no) \
+                                                         \
+    SC(149,     42,       40,      1, yes,  no, no) \
+    SC(150,     42,       40,      2, yes,  no, no) \
+    SC(151,     42,       40,      3, yes,  no, no) \
+    SC(152,     42,       40,      4, yes,  no, no) \
+                                                         \
+    SC(153,     43,       41,      1, yes,  no, no) \
+    SC(154,     43,       41,      2, yes,  no, no) \
+    SC(155,     43,       41,      3, yes,  no, no) \
+    SC(156,     43,       41,      4, yes,  no, no) \
+                                                         \
+    SC(157,     44,       42,      1, yes,  no, no) \
+    SC(158,     44,       42,      2, yes,  no, no) \
+    SC(159,     44,       42,      3, yes,  no, no) \
+    SC(160,     44,       42,      4, yes,  no, no) \
+                                                         \
+    SC(161,     45,       43,      1, yes,  no, no) \
+    SC(162,     45,       43,      2, yes,  no, no) \
+    SC(163,     45,       43,      3, yes,  no, no) \
+    SC(164,     45,       43,      4, yes,  no, no) \
+                                                         \
+    SC(165,     46,       44,      1, yes,  no, no) \
+    SC(166,     46,       44,      2, yes,  no, no) \
+    SC(167,     46,       44,      3, yes,  no, no) \
+    SC(168,     46,       44,      4, yes,  no, no) \
+                                                         \
+    SC(169,     47,       45,      1, yes,  no, no) \
+    SC(170,     47,       45,      2, yes,  no, no) \
+    SC(171,     47,       45,      3, yes,  no, no) \
+    SC(172,     47,       45,      4, yes,  no, no) \
+                                                         \
+    SC(173,     48,       46,      1, yes,  no, no) \
+    SC(174,     48,       46,      2, yes,  no, no) \
+    SC(175,     48,       46,      3, yes,  no, no) \
+    SC(176,     48,       46,      4, yes,  no, no) \
+                                                         \
+    SC(177,     49,       47,      1, yes,  no, no) \
+    SC(178,     49,       47,      2, yes,  no, no) \
+    SC(179,     49,       47,      3, yes,  no, no) \
+    SC(180,     49,       47,      4, yes,  no, no) \
+                                                         \
+    SC(181,     50,       48,      1, yes,  no, no) \
+    SC(182,     50,       48,      2, yes,  no, no) \
+    SC(183,     50,       48,      3, yes,  no, no) \
+    SC(184,     50,       48,      4, yes,  no, no) \
+                                                         \
+    SC(185,     51,       49,      1, yes,  no, no) \
+    SC(186,     51,       49,      2, yes,  no, no) \
+    SC(187,     51,       49,      3, yes,  no, no) \
+    SC(188,     51,       49,      4, yes,  no, no) \
                                                          \
-    SC( 73,     23,       21,      1, yes,  no, no) \
-    SC( 74,     23,       21,      2, yes,  no, no) \
-    SC( 75,     23,       21,      3, yes,  no, no) \
-    SC( 76,     23,       21,      4, yes,  no, no) \
+    SC(189,     52,       50,      1, yes,  no, no) \
+    SC(190,     52,       50,      2, yes,  no, no) \
+    SC(191,     52,       50,      3, yes,  no, no) \
+    SC(192,     52,       50,      4, yes,  no, no) \
                                                          \
-    SC( 77,     24,       22,      1, yes,  no, no) \
-    SC( 78,     24,       22,      2, yes,  no, no) \
-    SC( 79,     24,       22,      3, yes,  no, no) \
-    SC( 80,     24,       22,      4, yes,  no, no) \
+    SC(193,     53,       51,      1, yes,  no, no) \
+    SC(194,     53,       51,      2, yes,  no, no) \
+    SC(195,     53,       51,      3, yes,  no, no) \
+    SC(196,     53,       51,      4, yes,  no, no) \
                                                          \
-    SC( 81,     25,       23,      1, yes,  no, no) \
-    SC( 82,     25,       23,      2, yes,  no, no) \
-    SC( 83,     25,       23,      3, yes,  no, no) \
-    SC( 84,     25,       23,      4, yes,  no, no) \
+    SC(197,     54,       52,      1, yes,  no, no) \
+    SC(198,     54,       52,      2, yes,  no, no) \
+    SC(199,     54,       52,      3, yes,  no, no) \
+    SC(200,     54,       52,      4, yes,  no, no) \
                                                          \
-    SC( 85,     26,       24,      1, yes,  no, no) \
-    SC( 86,     26,       24,      2, yes,  no, no) \
-    SC( 87,     26,       24,      3, yes,  no, no) \
-    SC( 88,     26,       24,      4, yes,  no, no) \
+    SC(201,     55,       53,      1, yes,  no, no) \
+    SC(202,     55,       53,      2, yes,  no, no) \
+    SC(203,     55,       53,      3, yes,  no, no) \
+    SC(204,     55,       53,      4, yes,  no, no) \
                                                          \
-    SC( 89,     27,       25,      1, yes,  no, no) \
-    SC( 90,     27,       25,      2, yes,  no, no) \
-    SC( 91,     27,       25,      3, yes,  no, no) \
-    SC( 92,     27,       25,      4, yes,  no, no) \
+    SC(205,     56,       54,      1, yes,  no, no) \
+    SC(206,     56,       54,      2, yes,  no, no) \
+    SC(207,     56,       54,      3, yes,  no, no) \
+    SC(208,     56,       54,      4, yes,  no, no) \
                                                          \
-    SC( 93,     28,       26,      1, yes,  no, no) \
-    SC( 94,     28,       26,      2, yes,  no, no) \
-    SC( 95,     28,       26,      3, yes,  no, no) \
-    SC( 96,     28,       26,      4, yes,  no, no) \
+    SC(209,     57,       55,      1, yes,  no, no) \
+    SC(210,     57,       55,      2, yes,  no, no) \
+    SC(211,     57,       55,      3, yes,  no, no) \
+    SC(212,     57,       55,      4, yes,  no, no) \
                                                          \
-    SC( 97,     29,       27,      1, yes,  no, no) \
-    SC( 98,     29,       27,      2, yes,  no, no) \
-    SC( 99,     29,       27,      3, yes,  no, no) \
-    SC(100,     29,       27,      4, yes,  no, no) \
+    SC(213,     58,       56,      1, yes,  no, no) \
+    SC(214,     58,       56,      2, yes,  no, no) \
+    SC(215,     58,       56,      3, yes,  no, no) \
+    SC(216,     58,       56,      4, yes,  no, no) \
                                                          \
-    SC(101,     30,       28,      1, yes,  no, no) \
-    SC(102,     30,       28,      2, yes,  no, no) \
-    SC(103,     30,       28,      3, yes,  no, no) \
-    SC(104,     30,       28,      4, yes,  no, no) \
+    SC(217,     59,       57,      1, yes,  no, no) \
+    SC(218,     59,       57,      2, yes,  no, no) \
+    SC(219,     59,       57,      3, yes,  no, no) \
+    SC(220,     59,       57,      4, yes,  no, no) \
                                                          \
-    SC(105,     31,       29,      1, yes,  no, no) \
-    SC(106,     31,       29,      2, yes,  no, no) \
-    SC(107,     31,       29,      3, yes,  no, no) \
-    SC(108,     31,       29,      4, yes,  no, no) \
+    SC(221,     60,       58,      1, yes,  no, no) \
+    SC(222,     60,       58,      2, yes,  no, no) \
+    SC(223,     60,       58,      3, yes,  no, no) \
+    SC(224,     60,       58,      4, yes,  no, no) \
                                                          \
-    SC(109,     32,       30,      1, yes,  no, no) \
-    SC(110,     32,       30,      2, yes,  no, no) \
-    SC(111,     32,       30,      3, yes,  no, no) \
-    SC(112,     32,       30,      4, yes,  no, no) \
+    SC(225,     61,       59,      1, yes,  no, no) \
+    SC(226,     61,       59,      2, yes,  no, no) \
+    SC(227,     61,       59,      3, yes,  no, no) \
+    SC(228,     61,       59,      4, yes,  no, no) \
                                                          \
-    SC(113,     33,       31,      1, yes,  no, no) \
-    SC(114,     33,       31,      2, yes,  no, no) \
-    SC(115,     33,       31,      3, yes,  no, no) \
-    SC(116,     33,       31,      4, yes,  no, no) \
+    SC(229,     62,       60,      1, yes,  no, no) \
+    SC(230,     62,       60,      2, yes,  no, no) \
+    SC(231,     62,       60,      3, yes,  no, no) \
+
+#define	SIZE_CLASSES_DEFINED
+#define	NTBINS			1
+#define	NLBINS			29
+#define	NBINS			44
+#define	NSIZES			232
+#define	NPSIZES			191
+#define	LG_TINY_MAXCLASS	3
+#define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define	SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define	LG_LARGE_MINCLASS	16
+#define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define	SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
+    SC(  0,      4,        4,      0,  no, yes,  4) \
+    SC(  1,      4,        4,      1,  no, yes,  4) \
+    SC(  2,      4,        4,      2,  no, yes,  4) \
+    SC(  3,      4,        4,      3,  no, yes,  4) \
+                                                         \
+    SC(  4,      6,        4,      1,  no, yes,  4) \
+    SC(  5,      6,        4,      2,  no, yes,  4) \
+    SC(  6,      6,        4,      3,  no, yes,  4) \
+    SC(  7,      6,        4,      4,  no, yes,  4) \
+                                                         \
+    SC(  8,      7,        5,      1,  no, yes,  5) \
+    SC(  9,      7,        5,      2,  no, yes,  5) \
+    SC( 10,      7,        5,      3,  no, yes,  5) \
+    SC( 11,      7,        5,      4,  no, yes,  5) \
+                                                         \
+    SC( 12,      8,        6,      1,  no, yes,  6) \
+    SC( 13,      8,        6,      2,  no, yes,  6) \
+    SC( 14,      8,        6,      3,  no, yes,  6) \
+    SC( 15,      8,        6,      4,  no, yes,  6) \
+                                                         \
+    SC( 16,      9,        7,      1,  no, yes,  7) \
+    SC( 17,      9,        7,      2,  no, yes,  7) \
+    SC( 18,      9,        7,      3,  no, yes,  7) \
+    SC( 19,      9,        7,      4,  no, yes,  7) \
+                                                         \
+    SC( 20,     10,        8,      1,  no, yes,  8) \
+    SC( 21,     10,        8,      2,  no, yes,  8) \
+    SC( 22,     10,        8,      3,  no, yes,  8) \
+    SC( 23,     10,        8,      4,  no, yes,  8) \
+                                                         \
+    SC( 24,     11,        9,      1,  no, yes,  9) \
+    SC( 25,     11,        9,      2,  no, yes,  9) \
+    SC( 26,     11,        9,      3,  no, yes,  9) \
+    SC( 27,     11,        9,      4, yes, yes,  9) \
+                                                         \
+    SC( 28,     12,       10,      1,  no, yes, no) \
+    SC( 29,     12,       10,      2,  no, yes, no) \
+    SC( 30,     12,       10,      3,  no, yes, no) \
+    SC( 31,     12,       10,      4, yes, yes, no) \
+                                                         \
+    SC( 32,     13,       11,      1,  no, yes, no) \
+    SC( 33,     13,       11,      2, yes, yes, no) \
+    SC( 34,     13,       11,      3,  no, yes, no) \
+    SC( 35,     13,       11,      4, yes,  no, no) \
+                                                         \
+    SC( 36,     14,       12,      1, yes,  no, no) \
+    SC( 37,     14,       12,      2, yes,  no, no) \
+    SC( 38,     14,       12,      3, yes,  no, no) \
+    SC( 39,     14,       12,      4, yes,  no, no) \
+                                                         \
+    SC( 40,     15,       13,      1, yes,  no, no) \
+    SC( 41,     15,       13,      2, yes,  no, no) \
+    SC( 42,     15,       13,      3, yes,  no, no) \
+    SC( 43,     15,       13,      4, yes,  no, no) \
+                                                         \
+    SC( 44,     16,       14,      1, yes,  no, no) \
+    SC( 45,     16,       14,      2, yes,  no, no) \
+    SC( 46,     16,       14,      3, yes,  no, no) \
+    SC( 47,     16,       14,      4, yes,  no, no) \
+                                                         \
+    SC( 48,     17,       15,      1, yes,  no, no) \
+    SC( 49,     17,       15,      2, yes,  no, no) \
+    SC( 50,     17,       15,      3, yes,  no, no) \
+    SC( 51,     17,       15,      4, yes,  no, no) \
+                                                         \
+    SC( 52,     18,       16,      1, yes,  no, no) \
+    SC( 53,     18,       16,      2, yes,  no, no) \
+    SC( 54,     18,       16,      3, yes,  no, no) \
+    SC( 55,     18,       16,      4, yes,  no, no) \
+                                                         \
+    SC( 56,     19,       17,      1, yes,  no, no) \
+    SC( 57,     19,       17,      2, yes,  no, no) \
+    SC( 58,     19,       17,      3, yes,  no, no) \
+    SC( 59,     19,       17,      4, yes,  no, no) \
+                                                         \
+    SC( 60,     20,       18,      1, yes,  no, no) \
+    SC( 61,     20,       18,      2, yes,  no, no) \
+    SC( 62,     20,       18,      3, yes,  no, no) \
+    SC( 63,     20,       18,      4, yes,  no, no) \
+                                                         \
+    SC( 64,     21,       19,      1, yes,  no, no) \
+    SC( 65,     21,       19,      2, yes,  no, no) \
+    SC( 66,     21,       19,      3, yes,  no, no) \
+    SC( 67,     21,       19,      4, yes,  no, no) \
+                                                         \
+    SC( 68,     22,       20,      1, yes,  no, no) \
+    SC( 69,     22,       20,      2, yes,  no, no) \
+    SC( 70,     22,       20,      3, yes,  no, no) \
+    SC( 71,     22,       20,      4, yes,  no, no) \
+                                                         \
+    SC( 72,     23,       21,      1, yes,  no, no) \
+    SC( 73,     23,       21,      2, yes,  no, no) \
+    SC( 74,     23,       21,      3, yes,  no, no) \
+    SC( 75,     23,       21,      4, yes,  no, no) \
+                                                         \
+    SC( 76,     24,       22,      1, yes,  no, no) \
+    SC( 77,     24,       22,      2, yes,  no, no) \
+    SC( 78,     24,       22,      3, yes,  no, no) \
+    SC( 79,     24,       22,      4, yes,  no, no) \
+                                                         \
+    SC( 80,     25,       23,      1, yes,  no, no) \
+    SC( 81,     25,       23,      2, yes,  no, no) \
+    SC( 82,     25,       23,      3, yes,  no, no) \
+    SC( 83,     25,       23,      4, yes,  no, no) \
+                                                         \
+    SC( 84,     26,       24,      1, yes,  no, no) \
+    SC( 85,     26,       24,      2, yes,  no, no) \
+    SC( 86,     26,       24,      3, yes,  no, no) \
+    SC( 87,     26,       24,      4, yes,  no, no) \
+                                                         \
+    SC( 88,     27,       25,      1, yes,  no, no) \
+    SC( 89,     27,       25,      2, yes,  no, no) \
+    SC( 90,     27,       25,      3, yes,  no, no) \
+    SC( 91,     27,       25,      4, yes,  no, no) \
+                                                         \
+    SC( 92,     28,       26,      1, yes,  no, no) \
+    SC( 93,     28,       26,      2, yes,  no, no) \
+    SC( 94,     28,       26,      3, yes,  no, no) \
+    SC( 95,     28,       26,      4, yes,  no, no) \
+                                                         \
+    SC( 96,     29,       27,      1, yes,  no, no) \
+    SC( 97,     29,       27,      2, yes,  no, no) \
+    SC( 98,     29,       27,      3, yes,  no, no) \
+    SC( 99,     29,       27,      4, yes,  no, no) \
+                                                         \
+    SC(100,     30,       28,      1, yes,  no, no) \
+    SC(101,     30,       28,      2, yes,  no, no) \
+    SC(102,     30,       28,      3, yes,  no, no) \
+    SC(103,     30,       28,      4, yes,  no, no) \
+                                                         \
+    SC(104,     31,       29,      1, yes,  no, no) \
+    SC(105,     31,       29,      2, yes,  no, no) \
+    SC(106,     31,       29,      3, yes,  no, no) \
+    SC(107,     31,       29,      4, yes,  no, no) \
+                                                         \
+    SC(108,     32,       30,      1, yes,  no, no) \
+    SC(109,     32,       30,      2, yes,  no, no) \
+    SC(110,     32,       30,      3, yes,  no, no) \
+    SC(111,     32,       30,      4, yes,  no, no) \
+                                                         \
+    SC(112,     33,       31,      1, yes,  no, no) \
+    SC(113,     33,       31,      2, yes,  no, no) \
+    SC(114,     33,       31,      3, yes,  no, no) \
+    SC(115,     33,       31,      4, yes,  no, no) \
                                                          \
-    SC(117,     34,       32,      1, yes,  no, no) \
-    SC(118,     34,       32,      2, yes,  no, no) \
-    SC(119,     34,       32,      3, yes,  no, no) \
-    SC(120,     34,       32,      4, yes,  no, no) \
+    SC(116,     34,       32,      1, yes,  no, no) \
+    SC(117,     34,       32,      2, yes,  no, no) \
+    SC(118,     34,       32,      3, yes,  no, no) \
+    SC(119,     34,       32,      4, yes,  no, no) \
                                                          \
-    SC(121,     35,       33,      1, yes,  no, no) \
-    SC(122,     35,       33,      2, yes,  no, no) \
-    SC(123,     35,       33,      3, yes,  no, no) \
-    SC(124,     35,       33,      4, yes,  no, no) \
+    SC(120,     35,       33,      1, yes,  no, no) \
+    SC(121,     35,       33,      2, yes,  no, no) \
+    SC(122,     35,       33,      3, yes,  no, no) \
+    SC(123,     35,       33,      4, yes,  no, no) \
                                                          \
-    SC(125,     36,       34,      1, yes,  no, no) \
-    SC(126,     36,       34,      2, yes,  no, no) \
-    SC(127,     36,       34,      3, yes,  no, no) \
-    SC(128,     36,       34,      4, yes,  no, no) \
+    SC(124,     36,       34,      1, yes,  no, no) \
+    SC(125,     36,       34,      2, yes,  no, no) \
+    SC(126,     36,       34,      3, yes,  no, no) \
+    SC(127,     36,       34,      4, yes,  no, no) \
                                                          \
-    SC(129,     37,       35,      1, yes,  no, no) \
-    SC(130,     37,       35,      2, yes,  no, no) \
-    SC(131,     37,       35,      3, yes,  no, no) \
-    SC(132,     37,       35,      4, yes,  no, no) \
+    SC(128,     37,       35,      1, yes,  no, no) \
+    SC(129,     37,       35,      2, yes,  no, no) \
+    SC(130,     37,       35,      3, yes,  no, no) \
+    SC(131,     37,       35,      4, yes,  no, no) \
                                                          \
-    SC(133,     38,       36,      1, yes,  no, no) \
-    SC(134,     38,       36,      2, yes,  no, no) \
-    SC(135,     38,       36,      3, yes,  no, no) \
-    SC(136,     38,       36,      4, yes,  no, no) \
+    SC(132,     38,       36,      1, yes,  no, no) \
+    SC(133,     38,       36,      2, yes,  no, no) \
+    SC(134,     38,       36,      3, yes,  no, no) \
+    SC(135,     38,       36,      4, yes,  no, no) \
                                                          \
-    SC(137,     39,       37,      1, yes,  no, no) \
-    SC(138,     39,       37,      2, yes,  no, no) \
-    SC(139,     39,       37,      3, yes,  no, no) \
-    SC(140,     39,       37,      4, yes,  no, no) \
+    SC(136,     39,       37,      1, yes,  no, no) \
+    SC(137,     39,       37,      2, yes,  no, no) \
+    SC(138,     39,       37,      3, yes,  no, no) \
+    SC(139,     39,       37,      4, yes,  no, no) \
                                                          \
-    SC(141,     40,       38,      1, yes,  no, no) \
-    SC(142,     40,       38,      2, yes,  no, no) \
-    SC(143,     40,       38,      3, yes,  no, no) \
-    SC(144,     40,       38,      4, yes,  no, no) \
+    SC(140,     40,       38,      1, yes,  no, no) \
+    SC(141,     40,       38,      2, yes,  no, no) \
+    SC(142,     40,       38,      3, yes,  no, no) \
+    SC(143,     40,       38,      4, yes,  no, no) \
                                                          \
-    SC(145,     41,       39,      1, yes,  no, no) \
-    SC(146,     41,       39,      2, yes,  no, no) \
-    SC(147,     41,       39,      3, yes,  no, no) \
-    SC(148,     41,       39,      4, yes,  no, no) \
+    SC(144,     41,       39,      1, yes,  no, no) \
+    SC(145,     41,       39,      2, yes,  no, no) \
+    SC(146,     41,       39,      3, yes,  no, no) \
+    SC(147,     41,       39,      4, yes,  no, no) \
                                                          \
-    SC(149,     42,       40,      1, yes,  no, no) \
-    SC(150,     42,       40,      2, yes,  no, no) \
-    SC(151,     42,       40,      3, yes,  no, no) \
-    SC(152,     42,       40,      4, yes,  no, no) \
+    SC(148,     42,       40,      1, yes,  no, no) \
+    SC(149,     42,       40,      2, yes,  no, no) \
+    SC(150,     42,       40,      3, yes,  no, no) \
+    SC(151,     42,       40,      4, yes,  no, no) \
                                                          \
-    SC(153,     43,       41,      1, yes,  no, no) \
-    SC(154,     43,       41,      2, yes,  no, no) \
-    SC(155,     43,       41,      3, yes,  no, no) \
-    SC(156,     43,       41,      4, yes,  no, no) \
+    SC(152,     43,       41,      1, yes,  no, no) \
+    SC(153,     43,       41,      2, yes,  no, no) \
+    SC(154,     43,       41,      3, yes,  no, no) \
+    SC(155,     43,       41,      4, yes,  no, no) \
                                                          \
-    SC(157,     44,       42,      1, yes,  no, no) \
-    SC(158,     44,       42,      2, yes,  no, no) \
-    SC(159,     44,       42,      3, yes,  no, no) \
-    SC(160,     44,       42,      4, yes,  no, no) \
+    SC(156,     44,       42,      1, yes,  no, no) \
+    SC(157,     44,       42,      2, yes,  no, no) \
+    SC(158,     44,       42,      3, yes,  no, no) \
+    SC(159,     44,       42,      4, yes,  no, no) \
                                                          \
-    SC(161,     45,       43,      1, yes,  no, no) \
-    SC(162,     45,       43,      2, yes,  no, no) \
-    SC(163,     45,       43,      3, yes,  no, no) \
-    SC(164,     45,       43,      4, yes,  no, no) \
+    SC(160,     45,       43,      1, yes,  no, no) \
+    SC(161,     45,       43,      2, yes,  no, no) \
+    SC(162,     45,       43,      3, yes,  no, no) \
+    SC(163,     45,       43,      4, yes,  no, no) \
                                                          \
-    SC(165,     46,       44,      1, yes,  no, no) \
-    SC(166,     46,       44,      2, yes,  no, no) \
-    SC(167,     46,       44,      3, yes,  no, no) \
-    SC(168,     46,       44,      4, yes,  no, no) \
+    SC(164,     46,       44,      1, yes,  no, no) \
+    SC(165,     46,       44,      2, yes,  no, no) \
+    SC(166,     46,       44,      3, yes,  no, no) \
+    SC(167,     46,       44,      4, yes,  no, no) \
                                                          \
-    SC(169,     47,       45,      1, yes,  no, no) \
-    SC(170,     47,       45,      2, yes,  no, no) \
-    SC(171,     47,       45,      3, yes,  no, no) \
-    SC(172,     47,       45,      4, yes,  no, no) \
+    SC(168,     47,       45,      1, yes,  no, no) \
+    SC(169,     47,       45,      2, yes,  no, no) \
+    SC(170,     47,       45,      3, yes,  no, no) \
+    SC(171,     47,       45,      4, yes,  no, no) \
                                                          \
-    SC(173,     48,       46,      1, yes,  no, no) \
-    SC(174,     48,       46,      2, yes,  no, no) \
-    SC(175,     48,       46,      3, yes,  no, no) \
-    SC(176,     48,       46,      4, yes,  no, no) \
+    SC(172,     48,       46,      1, yes,  no, no) \
+    SC(173,     48,       46,      2, yes,  no, no) \
+    SC(174,     48,       46,      3, yes,  no, no) \
+    SC(175,     48,       46,      4, yes,  no, no) \
                                                          \
-    SC(177,     49,       47,      1, yes,  no, no) \
-    SC(178,     49,       47,      2, yes,  no, no) \
-    SC(179,     49,       47,      3, yes,  no, no) \
-    SC(180,     49,       47,      4, yes,  no, no) \
+    SC(176,     49,       47,      1, yes,  no, no) \
+    SC(177,     49,       47,      2, yes,  no, no) \
+    SC(178,     49,       47,      3, yes,  no, no) \
+    SC(179,     49,       47,      4, yes,  no, no) \
                                                          \
-    SC(181,     50,       48,      1, yes,  no, no) \
-    SC(182,     50,       48,      2, yes,  no, no) \
-    SC(183,     50,       48,      3, yes,  no, no) \
-    SC(184,     50,       48,      4, yes,  no, no) \
+    SC(180,     50,       48,      1, yes,  no, no) \
+    SC(181,     50,       48,      2, yes,  no, no) \
+    SC(182,     50,       48,      3, yes,  no, no) \
+    SC(183,     50,       48,      4, yes,  no, no) \
                                                          \
-    SC(185,     51,       49,      1, yes,  no, no) \
-    SC(186,     51,       49,      2, yes,  no, no) \
-    SC(187,     51,       49,      3, yes,  no, no) \
-    SC(188,     51,       49,      4, yes,  no, no) \
+    SC(184,     51,       49,      1, yes,  no, no) \
+    SC(185,     51,       49,      2, yes,  no, no) \
+    SC(186,     51,       49,      3, yes,  no, no) \
+    SC(187,     51,       49,      4, yes,  no, no) \
                                                          \
-    SC(189,     52,       50,      1, yes,  no, no) \
-    SC(190,     52,       50,      2, yes,  no, no) \
-    SC(191,     52,       50,      3, yes,  no, no) \
-    SC(192,     52,       50,      4, yes,  no, no) \
+    SC(188,     52,       50,      1, yes,  no, no) \
+    SC(189,     52,       50,      2, yes,  no, no) \
+    SC(190,     52,       50,      3, yes,  no, no) \
+    SC(191,     52,       50,      4, yes,  no, no) \
                                                          \
-    SC(193,     53,       51,      1, yes,  no, no) \
-    SC(194,     53,       51,      2, yes,  no, no) \
-    SC(195,     53,       51,      3, yes,  no, no) \
-    SC(196,     53,       51,      4, yes,  no, no) \
+    SC(192,     53,       51,      1, yes,  no, no) \
+    SC(193,     53,       51,      2, yes,  no, no) \
+    SC(194,     53,       51,      3, yes,  no, no) \
+    SC(195,     53,       51,      4, yes,  no, no) \
                                                          \
-    SC(197,     54,       52,      1, yes,  no, no) \
-    SC(198,     54,       52,      2, yes,  no, no) \
-    SC(199,     54,       52,      3, yes,  no, no) \
-    SC(200,     54,       52,      4, yes,  no, no) \
+    SC(196,     54,       52,      1, yes,  no, no) \
+    SC(197,     54,       52,      2, yes,  no, no) \
+    SC(198,     54,       52,      3, yes,  no, no) \
+    SC(199,     54,       52,      4, yes,  no, no) \
                                                          \
-    SC(201,     55,       53,      1, yes,  no, no) \
-    SC(202,     55,       53,      2, yes,  no, no) \
-    SC(203,     55,       53,      3, yes,  no, no) \
-    SC(204,     55,       53,      4, yes,  no, no) \
+    SC(200,     55,       53,      1, yes,  no, no) \
+    SC(201,     55,       53,      2, yes,  no, no) \
+    SC(202,     55,       53,      3, yes,  no, no) \
+    SC(203,     55,       53,      4, yes,  no, no) \
                                                          \
-    SC(205,     56,       54,      1, yes,  no, no) \
-    SC(206,     56,       54,      2, yes,  no, no) \
-    SC(207,     56,       54,      3, yes,  no, no) \
-    SC(208,     56,       54,      4, yes,  no, no) \
+    SC(204,     56,       54,      1, yes,  no, no) \
+    SC(205,     56,       54,      2, yes,  no, no) \
+    SC(206,     56,       54,      3, yes,  no, no) \
+    SC(207,     56,       54,      4, yes,  no, no) \
                                                          \
-    SC(209,     57,       55,      1, yes,  no, no) \
-    SC(210,     57,       55,      2, yes,  no, no) \
-    SC(211,     57,       55,      3, yes,  no, no) \
-    SC(212,     57,       55,      4, yes,  no, no) \
+    SC(208,     57,       55,      1, yes,  no, no) \
+    SC(209,     57,       55,      2, yes,  no, no) \
+    SC(210,     57,       55,      3, yes,  no, no) \
+    SC(211,     57,       55,      4, yes,  no, no) \
                                                          \
-    SC(213,     58,       56,      1, yes,  no, no) \
-    SC(214,     58,       56,      2, yes,  no, no) \
-    SC(215,     58,       56,      3, yes,  no, no) \
-    SC(216,     58,       56,      4, yes,  no, no) \
+    SC(212,     58,       56,      1, yes,  no, no) \
+    SC(213,     58,       56,      2, yes,  no, no) \
+    SC(214,     58,       56,      3, yes,  no, no) \
+    SC(215,     58,       56,      4, yes,  no, no) \
                                                          \
-    SC(217,     59,       57,      1, yes,  no, no) \
-    SC(218,     59,       57,      2, yes,  no, no) \
-    SC(219,     59,       57,      3, yes,  no, no) \
-    SC(220,     59,       57,      4, yes,  no, no) \
+    SC(216,     59,       57,      1, yes,  no, no) \
+    SC(217,     59,       57,      2, yes,  no, no) \
+    SC(218,     59,       57,      3, yes,  no, no) \
+    SC(219,     59,       57,      4, yes,  no, no) \
                                                          \
-    SC(221,     60,       58,      1, yes,  no, no) \
-    SC(222,     60,       58,      2, yes,  no, no) \
-    SC(223,     60,       58,      3, yes,  no, no) \
-    SC(224,     60,       58,      4, yes,  no, no) \
+    SC(220,     60,       58,      1, yes,  no, no) \
+    SC(221,     60,       58,      2, yes,  no, no) \
+    SC(222,     60,       58,      3, yes,  no, no) \
+    SC(223,     60,       58,      4, yes,  no, no) \
                                                          \
-    SC(225,     61,       59,      1, yes,  no, no) \
-    SC(226,     61,       59,      2, yes,  no, no) \
-    SC(227,     61,       59,      3, yes,  no, no) \
-    SC(228,     61,       59,      4, yes,  no, no) \
+    SC(224,     61,       59,      1, yes,  no, no) \
+    SC(225,     61,       59,      2, yes,  no, no) \
+    SC(226,     61,       59,      3, yes,  no, no) \
+    SC(227,     61,       59,      4, yes,  no, no) \
                                                          \
-    SC(229,     62,       60,      1, yes,  no, no) \
-    SC(230,     62,       60,      2, yes,  no, no) \
-    SC(231,     62,       60,      3, yes,  no, no) \
+    SC(228,     62,       60,      1, yes,  no, no) \
+    SC(229,     62,       60,      2, yes,  no, no) \
+    SC(230,     62,       60,      3, yes,  no, no) \
 
 #define	SIZE_CLASSES_DEFINED
-#define	NTBINS			1
-#define	NLBINS			29
-#define	NBINS			36
-#define	NSIZES			232
+#define	NTBINS			0
+#define	NLBINS			28
+#define	NBINS			35
+#define	NSIZES			231
 #define	NPSIZES			199
-#define	LG_TINY_MAXCLASS	3
+#define	LG_TINY_MAXCLASS	"NA"
 #define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
 #define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
 #define	LG_LARGE_MINCLASS	14
 #define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif
 
-#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define	SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, lg_delta_lookup */ \
     SC(  0,      4,        4,      0,  no, yes,  4) \
@@ -1126,26 +2490,26 @@
     SC( 24,     11,        9,      1,  no, yes,  9) \
     SC( 25,     11,        9,      2,  no, yes,  9) \
     SC( 26,     11,        9,      3,  no, yes,  9) \
-    SC( 27,     11,        9,      4, yes, yes,  9) \
+    SC( 27,     11,        9,      4,  no, yes,  9) \
                                                          \
     SC( 28,     12,       10,      1,  no, yes, no) \
     SC( 29,     12,       10,      2,  no, yes, no) \
     SC( 30,     12,       10,      3,  no, yes, no) \
-    SC( 31,     12,       10,      4, yes, yes, no) \
+    SC( 31,     12,       10,      4,  no, yes, no) \
                                                          \
     SC( 32,     13,       11,      1,  no, yes, no) \
-    SC( 33,     13,       11,      2, yes, yes, no) \
+    SC( 33,     13,       11,      2,  no, yes, no) \
     SC( 34,     13,       11,      3,  no, yes, no) \
-    SC( 35,     13,       11,      4, yes,  no, no) \
+    SC( 35,     13,       11,      4, yes, yes, no) \
                                                          \
-    SC( 36,     14,       12,      1, yes,  no, no) \
-    SC( 37,     14,       12,      2, yes,  no, no) \
-    SC( 38,     14,       12,      3, yes,  no, no) \
-    SC( 39,     14,       12,      4, yes,  no, no) \
+    SC( 36,     14,       12,      1,  no, yes, no) \
+    SC( 37,     14,       12,      2,  no, yes, no) \
+    SC( 38,     14,       12,      3,  no, yes, no) \
+    SC( 39,     14,       12,      4, yes, yes, no) \
                                                          \
-    SC( 40,     15,       13,      1, yes,  no, no) \
-    SC( 41,     15,       13,      2, yes,  no, no) \
-    SC( 42,     15,       13,      3, yes,  no, no) \
+    SC( 40,     15,       13,      1,  no, yes, no) \
+    SC( 41,     15,       13,      2, yes, yes, no) \
+    SC( 42,     15,       13,      3,  no, yes, no) \
     SC( 43,     15,       13,      4, yes,  no, no) \
                                                          \
     SC( 44,     16,       14,      1, yes,  no, no) \
@@ -1385,13 +2749,13 @@
 #define	SIZE_CLASSES_DEFINED
 #define	NTBINS			0
 #define	NLBINS			28
-#define	NBINS			35
+#define	NBINS			43
 #define	NSIZES			231
-#define	NPSIZES			199
+#define	NPSIZES			191
 #define	LG_TINY_MAXCLASS	"NA"
 #define	LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
-#define	SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
-#define	LG_LARGE_MINCLASS	14
+#define	SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define	LG_LARGE_MINCLASS	16
 #define	HUGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif
 

project external/jemalloc_new/
diff --git a/external/jemalloc_new/configure b/external/jemalloc_new/configure
index 4d96211f..6aebfad0 100755
--- a/external/jemalloc_new/configure
+++ b/external/jemalloc_new/configure
@@ -744,7 +744,6 @@ infodir
 docdir
 oldincludedir
 includedir
-runstatedir
 localstatedir
 sharedstatedir
 sysconfdir
@@ -850,7 +849,6 @@ datadir='${datarootdir}'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
-runstatedir='${localstatedir}/run'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
 docdir='${datarootdir}/doc/${PACKAGE}'
@@ -1103,15 +1101,6 @@ do
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
 
-  -runstatedir | --runstatedir | --runstatedi | --runstated \
-  | --runstate | --runstat | --runsta | --runst | --runs \
-  | --run | --ru | --r)
-    ac_prev=runstatedir ;;
-  -runstatedir=* | --runstatedir=* | --runstatedi=* | --runstated=* \
-  | --runstate=* | --runstat=* | --runsta=* | --runst=* | --runs=* \
-  | --run=* | --ru=* | --r=*)
-    runstatedir=$ac_optarg ;;
-
   -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
     ac_prev=sbindir ;;
   -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
@@ -1249,7 +1238,7 @@ fi
 for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
 		datadir sysconfdir sharedstatedir localstatedir includedir \
 		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir runstatedir
+		libdir localedir mandir
 do
   eval ac_val=\$$ac_var
   # Remove trailing slashes.
@@ -1402,7 +1391,6 @@ Fine tuning of the installation directories:
   --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
-  --runstatedir=DIR       modifiable per-process data [LOCALSTATEDIR/run]
   --libdir=DIR            object code libraries [EPREFIX/lib]
   --includedir=DIR        C header files [PREFIX/include]
   --oldincludedir=DIR     C header files for non-gcc [/usr/include]
diff --git a/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs.h b/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs.h
index 052bd11c..6b41ff0b 100644
--- a/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs.h
+++ b/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs.h
@@ -208,7 +208,7 @@
 /* #undef LG_QUANTUM */
 
 /* One page is 2^LG_PAGE bytes. */
-#define LG_PAGE 12
+#define LG_PAGE 14
 
 /*
  * One huge page is 2^LG_HUGEPAGE bytes.  Note that this is defined even if the
diff --git a/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs_host.h b/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs_host.h
index 38f91bc2..cfa6afed 100644
--- a/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs_host.h
+++ b/external/jemalloc_new/include/jemalloc/internal/jemalloc_internal_defs_host.h
@@ -199,7 +199,7 @@
 /* #undef LG_QUANTUM */
 
 /* One page is 2^LG_PAGE bytes. */
-#define LG_PAGE 12
+#define LG_PAGE 14
 
 /*
  * One huge page is 2^LG_HUGEPAGE bytes.  Note that this is defined even if the
diff --git a/external/jemalloc_new/include/jemalloc/internal/size_classes.h b/external/jemalloc_new/include/jemalloc/internal/size_classes.h
index 0b7d3cd3..8b7c2517 100644
--- a/external/jemalloc_new/include/jemalloc/internal/size_classes.h
+++ b/external/jemalloc_new/include/jemalloc/internal/size_classes.h
@@ -189,6 +189,158 @@
 #define LARGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 14)
+#define SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,   1,  3) \
+    SC(  1,      3,        3,      1,  no, yes,   1,  3) \
+    SC(  2,      3,        3,      2,  no, yes,   3,  3) \
+    SC(  3,      3,        3,      3,  no, yes,   1,  3) \
+                                                         \
+    SC(  4,      5,        3,      1,  no, yes,   5,  3) \
+    SC(  5,      5,        3,      2,  no, yes,   3,  3) \
+    SC(  6,      5,        3,      3,  no, yes,   7,  3) \
+    SC(  7,      5,        3,      4,  no, yes,   1,  3) \
+                                                         \
+    SC(  8,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  9,      6,        4,      2,  no, yes,   3,  4) \
+    SC( 10,      6,        4,      3,  no, yes,   7,  4) \
+    SC( 11,      6,        4,      4,  no, yes,   1,  4) \
+                                                         \
+    SC( 12,      7,        5,      1,  no, yes,   5,  5) \
+    SC( 13,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 14,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 15,      7,        5,      4,  no, yes,   1,  5) \
+                                                         \
+    SC( 16,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 17,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 18,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 19,      8,        6,      4,  no, yes,   1,  6) \
+                                                         \
+    SC( 20,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 21,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 22,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 23,      9,        7,      4,  no, yes,   1,  7) \
+                                                         \
+    SC( 24,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 25,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 26,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 27,     10,        8,      4,  no, yes,   1,  8) \
+                                                         \
+    SC( 28,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 29,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 30,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 31,     11,        9,      4,  no, yes,   1,  9) \
+                                                         \
+    SC( 32,     12,       10,      1,  no, yes,   5, no) \
+    SC( 33,     12,       10,      2,  no, yes,   3, no) \
+    SC( 34,     12,       10,      3,  no, yes,   7, no) \
+    SC( 35,     12,       10,      4,  no, yes,   1, no) \
+                                                         \
+    SC( 36,     13,       11,      1,  no, yes,   5, no) \
+    SC( 37,     13,       11,      2,  no, yes,   3, no) \
+    SC( 38,     13,       11,      3,  no, yes,   7, no) \
+    SC( 39,     13,       11,      4, yes, yes,   1, no) \
+                                                         \
+    SC( 40,     14,       12,      1,  no, yes,   5, no) \
+    SC( 41,     14,       12,      2,  no, yes,   3, no) \
+    SC( 42,     14,       12,      3,  no, yes,   7, no) \
+    SC( 43,     14,       12,      4, yes, yes,   2, no) \
+                                                         \
+    SC( 44,     15,       13,      1,  no, yes,   5, no) \
+    SC( 45,     15,       13,      2, yes, yes,   3, no) \
+    SC( 46,     15,       13,      3,  no, yes,   7, no) \
+    SC( 47,     15,       13,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 48,     16,       14,      1, yes,  no,   0, no) \
+    SC( 49,     16,       14,      2, yes,  no,   0, no) \
+    SC( 50,     16,       14,      3, yes,  no,   0, no) \
+    SC( 51,     16,       14,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 52,     17,       15,      1, yes,  no,   0, no) \
+    SC( 53,     17,       15,      2, yes,  no,   0, no) \
+    SC( 54,     17,       15,      3, yes,  no,   0, no) \
+    SC( 55,     17,       15,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 56,     18,       16,      1, yes,  no,   0, no) \
+    SC( 57,     18,       16,      2, yes,  no,   0, no) \
+    SC( 58,     18,       16,      3, yes,  no,   0, no) \
+    SC( 59,     18,       16,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 60,     19,       17,      1, yes,  no,   0, no) \
+    SC( 61,     19,       17,      2, yes,  no,   0, no) \
+    SC( 62,     19,       17,      3, yes,  no,   0, no) \
+    SC( 63,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 64,     20,       18,      1, yes,  no,   0, no) \
+    SC( 65,     20,       18,      2, yes,  no,   0, no) \
+    SC( 66,     20,       18,      3, yes,  no,   0, no) \
+    SC( 67,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 68,     21,       19,      1, yes,  no,   0, no) \
+    SC( 69,     21,       19,      2, yes,  no,   0, no) \
+    SC( 70,     21,       19,      3, yes,  no,   0, no) \
+    SC( 71,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 72,     22,       20,      1, yes,  no,   0, no) \
+    SC( 73,     22,       20,      2, yes,  no,   0, no) \
+    SC( 74,     22,       20,      3, yes,  no,   0, no) \
+    SC( 75,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 76,     23,       21,      1, yes,  no,   0, no) \
+    SC( 77,     23,       21,      2, yes,  no,   0, no) \
+    SC( 78,     23,       21,      3, yes,  no,   0, no) \
+    SC( 79,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 80,     24,       22,      1, yes,  no,   0, no) \
+    SC( 81,     24,       22,      2, yes,  no,   0, no) \
+    SC( 82,     24,       22,      3, yes,  no,   0, no) \
+    SC( 83,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 84,     25,       23,      1, yes,  no,   0, no) \
+    SC( 85,     25,       23,      2, yes,  no,   0, no) \
+    SC( 86,     25,       23,      3, yes,  no,   0, no) \
+    SC( 87,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 88,     26,       24,      1, yes,  no,   0, no) \
+    SC( 89,     26,       24,      2, yes,  no,   0, no) \
+    SC( 90,     26,       24,      3, yes,  no,   0, no) \
+    SC( 91,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 92,     27,       25,      1, yes,  no,   0, no) \
+    SC( 93,     27,       25,      2, yes,  no,   0, no) \
+    SC( 94,     27,       25,      3, yes,  no,   0, no) \
+    SC( 95,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 96,     28,       26,      1, yes,  no,   0, no) \
+    SC( 97,     28,       26,      2, yes,  no,   0, no) \
+    SC( 98,     28,       26,      3, yes,  no,   0, no) \
+    SC( 99,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC(100,     29,       27,      1, yes,  no,   0, no) \
+    SC(101,     29,       27,      2, yes,  no,   0, no) \
+    SC(102,     29,       27,      3, yes,  no,   0, no) \
+    SC(103,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(104,     30,       28,      1, yes,  no,   0, no) \
+    SC(105,     30,       28,      2, yes,  no,   0, no) \
+    SC(106,     30,       28,      3, yes,  no,   0, no) \
+
+#define SIZE_CLASSES_DEFINED
+#define NTBINS			0
+#define NLBINS			32
+#define NBINS			47
+#define NSIZES			107
+#define LG_CEIL_NSIZES		7
+#define NPSIZES			63
+#define LG_TINY_MAXCLASS	"NA"
+#define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define LG_LARGE_MINCLASS	16
+#define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
+#define LARGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
+#endif
+
 #if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
 #define SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
@@ -338,93 +490,242 @@
 #define LARGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
-#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
-    SC(  0,      4,        4,      0,  no, yes,   1,  4) \
-    SC(  1,      4,        4,      1,  no, yes,   1,  4) \
-    SC(  2,      4,        4,      2,  no, yes,   3,  4) \
-    SC(  3,      4,        4,      3,  no, yes,   1,  4) \
-                                                         \
-    SC(  4,      6,        4,      1,  no, yes,   5,  4) \
-    SC(  5,      6,        4,      2,  no, yes,   3,  4) \
-    SC(  6,      6,        4,      3,  no, yes,   7,  4) \
-    SC(  7,      6,        4,      4,  no, yes,   1,  4) \
+    SC(  0,      3,        3,      0,  no, yes,   1,  3) \
                                                          \
-    SC(  8,      7,        5,      1,  no, yes,   5,  5) \
-    SC(  9,      7,        5,      2,  no, yes,   3,  5) \
-    SC( 10,      7,        5,      3,  no, yes,   7,  5) \
-    SC( 11,      7,        5,      4,  no, yes,   1,  5) \
+    SC(  1,      3,        3,      1,  no, yes,   1,  3) \
+    SC(  2,      4,        4,      1,  no, yes,   1,  4) \
+    SC(  3,      4,        4,      2,  no, yes,   3,  4) \
+    SC(  4,      4,        4,      3,  no, yes,   1,  4) \
                                                          \
-    SC( 12,      8,        6,      1,  no, yes,   5,  6) \
-    SC( 13,      8,        6,      2,  no, yes,   3,  6) \
-    SC( 14,      8,        6,      3,  no, yes,   7,  6) \
-    SC( 15,      8,        6,      4,  no, yes,   1,  6) \
+    SC(  5,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  6,      6,        4,      2,  no, yes,   3,  4) \
+    SC(  7,      6,        4,      3,  no, yes,   7,  4) \
+    SC(  8,      6,        4,      4,  no, yes,   1,  4) \
                                                          \
-    SC( 16,      9,        7,      1,  no, yes,   5,  7) \
-    SC( 17,      9,        7,      2,  no, yes,   3,  7) \
-    SC( 18,      9,        7,      3,  no, yes,   7,  7) \
-    SC( 19,      9,        7,      4,  no, yes,   1,  7) \
+    SC(  9,      7,        5,      1,  no, yes,   5,  5) \
+    SC( 10,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 11,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 12,      7,        5,      4,  no, yes,   1,  5) \
                                                          \
-    SC( 20,     10,        8,      1,  no, yes,   5,  8) \
-    SC( 21,     10,        8,      2,  no, yes,   3,  8) \
-    SC( 22,     10,        8,      3,  no, yes,   7,  8) \
-    SC( 23,     10,        8,      4,  no, yes,   1,  8) \
+    SC( 13,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 14,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 15,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 16,      8,        6,      4,  no, yes,   1,  6) \
                                                          \
-    SC( 24,     11,        9,      1,  no, yes,   5,  9) \
-    SC( 25,     11,        9,      2,  no, yes,   3,  9) \
-    SC( 26,     11,        9,      3,  no, yes,   7,  9) \
-    SC( 27,     11,        9,      4, yes, yes,   1,  9) \
+    SC( 17,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 18,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 19,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 20,      9,        7,      4,  no, yes,   1,  7) \
                                                          \
-    SC( 28,     12,       10,      1,  no, yes,   5, no) \
-    SC( 29,     12,       10,      2,  no, yes,   3, no) \
-    SC( 30,     12,       10,      3,  no, yes,   7, no) \
-    SC( 31,     12,       10,      4, yes, yes,   2, no) \
+    SC( 21,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 22,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 23,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 24,     10,        8,      4,  no, yes,   1,  8) \
                                                          \
-    SC( 32,     13,       11,      1,  no, yes,   5, no) \
-    SC( 33,     13,       11,      2, yes, yes,   3, no) \
-    SC( 34,     13,       11,      3,  no, yes,   7, no) \
-    SC( 35,     13,       11,      4, yes,  no,   0, no) \
+    SC( 25,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 26,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 27,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 28,     11,        9,      4,  no, yes,   1,  9) \
                                                          \
-    SC( 36,     14,       12,      1, yes,  no,   0, no) \
-    SC( 37,     14,       12,      2, yes,  no,   0, no) \
-    SC( 38,     14,       12,      3, yes,  no,   0, no) \
-    SC( 39,     14,       12,      4, yes,  no,   0, no) \
+    SC( 29,     12,       10,      1,  no, yes,   5, no) \
+    SC( 30,     12,       10,      2,  no, yes,   3, no) \
+    SC( 31,     12,       10,      3,  no, yes,   7, no) \
+    SC( 32,     12,       10,      4,  no, yes,   1, no) \
                                                          \
-    SC( 40,     15,       13,      1, yes,  no,   0, no) \
-    SC( 41,     15,       13,      2, yes,  no,   0, no) \
-    SC( 42,     15,       13,      3, yes,  no,   0, no) \
-    SC( 43,     15,       13,      4, yes,  no,   0, no) \
+    SC( 33,     13,       11,      1,  no, yes,   5, no) \
+    SC( 34,     13,       11,      2,  no, yes,   3, no) \
+    SC( 35,     13,       11,      3,  no, yes,   7, no) \
+    SC( 36,     13,       11,      4, yes, yes,   1, no) \
                                                          \
-    SC( 44,     16,       14,      1, yes,  no,   0, no) \
-    SC( 45,     16,       14,      2, yes,  no,   0, no) \
-    SC( 46,     16,       14,      3, yes,  no,   0, no) \
-    SC( 47,     16,       14,      4, yes,  no,   0, no) \
+    SC( 37,     14,       12,      1,  no, yes,   5, no) \
+    SC( 38,     14,       12,      2,  no, yes,   3, no) \
+    SC( 39,     14,       12,      3,  no, yes,   7, no) \
+    SC( 40,     14,       12,      4, yes, yes,   2, no) \
                                                          \
-    SC( 48,     17,       15,      1, yes,  no,   0, no) \
-    SC( 49,     17,       15,      2, yes,  no,   0, no) \
-    SC( 50,     17,       15,      3, yes,  no,   0, no) \
-    SC( 51,     17,       15,      4, yes,  no,   0, no) \
+    SC( 41,     15,       13,      1,  no, yes,   5, no) \
+    SC( 42,     15,       13,      2, yes, yes,   3, no) \
+    SC( 43,     15,       13,      3,  no, yes,   7, no) \
+    SC( 44,     15,       13,      4, yes,  no,   0, no) \
                                                          \
-    SC( 52,     18,       16,      1, yes,  no,   0, no) \
-    SC( 53,     18,       16,      2, yes,  no,   0, no) \
-    SC( 54,     18,       16,      3, yes,  no,   0, no) \
-    SC( 55,     18,       16,      4, yes,  no,   0, no) \
+    SC( 45,     16,       14,      1, yes,  no,   0, no) \
+    SC( 46,     16,       14,      2, yes,  no,   0, no) \
+    SC( 47,     16,       14,      3, yes,  no,   0, no) \
+    SC( 48,     16,       14,      4, yes,  no,   0, no) \
                                                          \
-    SC( 56,     19,       17,      1, yes,  no,   0, no) \
-    SC( 57,     19,       17,      2, yes,  no,   0, no) \
-    SC( 58,     19,       17,      3, yes,  no,   0, no) \
-    SC( 59,     19,       17,      4, yes,  no,   0, no) \
+    SC( 49,     17,       15,      1, yes,  no,   0, no) \
+    SC( 50,     17,       15,      2, yes,  no,   0, no) \
+    SC( 51,     17,       15,      3, yes,  no,   0, no) \
+    SC( 52,     17,       15,      4, yes,  no,   0, no) \
                                                          \
-    SC( 60,     20,       18,      1, yes,  no,   0, no) \
-    SC( 61,     20,       18,      2, yes,  no,   0, no) \
-    SC( 62,     20,       18,      3, yes,  no,   0, no) \
-    SC( 63,     20,       18,      4, yes,  no,   0, no) \
+    SC( 53,     18,       16,      1, yes,  no,   0, no) \
+    SC( 54,     18,       16,      2, yes,  no,   0, no) \
+    SC( 55,     18,       16,      3, yes,  no,   0, no) \
+    SC( 56,     18,       16,      4, yes,  no,   0, no) \
                                                          \
-    SC( 64,     21,       19,      1, yes,  no,   0, no) \
-    SC( 65,     21,       19,      2, yes,  no,   0, no) \
-    SC( 66,     21,       19,      3, yes,  no,   0, no) \
-    SC( 67,     21,       19,      4, yes,  no,   0, no) \
+    SC( 57,     19,       17,      1, yes,  no,   0, no) \
+    SC( 58,     19,       17,      2, yes,  no,   0, no) \
+    SC( 59,     19,       17,      3, yes,  no,   0, no) \
+    SC( 60,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 61,     20,       18,      1, yes,  no,   0, no) \
+    SC( 62,     20,       18,      2, yes,  no,   0, no) \
+    SC( 63,     20,       18,      3, yes,  no,   0, no) \
+    SC( 64,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 65,     21,       19,      1, yes,  no,   0, no) \
+    SC( 66,     21,       19,      2, yes,  no,   0, no) \
+    SC( 67,     21,       19,      3, yes,  no,   0, no) \
+    SC( 68,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 69,     22,       20,      1, yes,  no,   0, no) \
+    SC( 70,     22,       20,      2, yes,  no,   0, no) \
+    SC( 71,     22,       20,      3, yes,  no,   0, no) \
+    SC( 72,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 73,     23,       21,      1, yes,  no,   0, no) \
+    SC( 74,     23,       21,      2, yes,  no,   0, no) \
+    SC( 75,     23,       21,      3, yes,  no,   0, no) \
+    SC( 76,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 77,     24,       22,      1, yes,  no,   0, no) \
+    SC( 78,     24,       22,      2, yes,  no,   0, no) \
+    SC( 79,     24,       22,      3, yes,  no,   0, no) \
+    SC( 80,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 81,     25,       23,      1, yes,  no,   0, no) \
+    SC( 82,     25,       23,      2, yes,  no,   0, no) \
+    SC( 83,     25,       23,      3, yes,  no,   0, no) \
+    SC( 84,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 85,     26,       24,      1, yes,  no,   0, no) \
+    SC( 86,     26,       24,      2, yes,  no,   0, no) \
+    SC( 87,     26,       24,      3, yes,  no,   0, no) \
+    SC( 88,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 89,     27,       25,      1, yes,  no,   0, no) \
+    SC( 90,     27,       25,      2, yes,  no,   0, no) \
+    SC( 91,     27,       25,      3, yes,  no,   0, no) \
+    SC( 92,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 93,     28,       26,      1, yes,  no,   0, no) \
+    SC( 94,     28,       26,      2, yes,  no,   0, no) \
+    SC( 95,     28,       26,      3, yes,  no,   0, no) \
+    SC( 96,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 97,     29,       27,      1, yes,  no,   0, no) \
+    SC( 98,     29,       27,      2, yes,  no,   0, no) \
+    SC( 99,     29,       27,      3, yes,  no,   0, no) \
+    SC(100,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(101,     30,       28,      1, yes,  no,   0, no) \
+    SC(102,     30,       28,      2, yes,  no,   0, no) \
+    SC(103,     30,       28,      3, yes,  no,   0, no) \
+
+#define SIZE_CLASSES_DEFINED
+#define NTBINS			1
+#define NLBINS			29
+#define NBINS			44
+#define NSIZES			104
+#define LG_CEIL_NSIZES		7
+#define NPSIZES			63
+#define LG_TINY_MAXCLASS	3
+#define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define LG_LARGE_MINCLASS	16
+#define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
+#define LARGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
+#endif
+
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
+    SC(  0,      4,        4,      0,  no, yes,   1,  4) \
+    SC(  1,      4,        4,      1,  no, yes,   1,  4) \
+    SC(  2,      4,        4,      2,  no, yes,   3,  4) \
+    SC(  3,      4,        4,      3,  no, yes,   1,  4) \
+                                                         \
+    SC(  4,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  5,      6,        4,      2,  no, yes,   3,  4) \
+    SC(  6,      6,        4,      3,  no, yes,   7,  4) \
+    SC(  7,      6,        4,      4,  no, yes,   1,  4) \
+                                                         \
+    SC(  8,      7,        5,      1,  no, yes,   5,  5) \
+    SC(  9,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 10,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 11,      7,        5,      4,  no, yes,   1,  5) \
+                                                         \
+    SC( 12,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 13,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 14,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 15,      8,        6,      4,  no, yes,   1,  6) \
+                                                         \
+    SC( 16,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 17,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 18,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 19,      9,        7,      4,  no, yes,   1,  7) \
+                                                         \
+    SC( 20,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 21,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 22,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 23,     10,        8,      4,  no, yes,   1,  8) \
+                                                         \
+    SC( 24,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 25,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 26,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 27,     11,        9,      4, yes, yes,   1,  9) \
+                                                         \
+    SC( 28,     12,       10,      1,  no, yes,   5, no) \
+    SC( 29,     12,       10,      2,  no, yes,   3, no) \
+    SC( 30,     12,       10,      3,  no, yes,   7, no) \
+    SC( 31,     12,       10,      4, yes, yes,   2, no) \
+                                                         \
+    SC( 32,     13,       11,      1,  no, yes,   5, no) \
+    SC( 33,     13,       11,      2, yes, yes,   3, no) \
+    SC( 34,     13,       11,      3,  no, yes,   7, no) \
+    SC( 35,     13,       11,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 36,     14,       12,      1, yes,  no,   0, no) \
+    SC( 37,     14,       12,      2, yes,  no,   0, no) \
+    SC( 38,     14,       12,      3, yes,  no,   0, no) \
+    SC( 39,     14,       12,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 40,     15,       13,      1, yes,  no,   0, no) \
+    SC( 41,     15,       13,      2, yes,  no,   0, no) \
+    SC( 42,     15,       13,      3, yes,  no,   0, no) \
+    SC( 43,     15,       13,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 44,     16,       14,      1, yes,  no,   0, no) \
+    SC( 45,     16,       14,      2, yes,  no,   0, no) \
+    SC( 46,     16,       14,      3, yes,  no,   0, no) \
+    SC( 47,     16,       14,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 48,     17,       15,      1, yes,  no,   0, no) \
+    SC( 49,     17,       15,      2, yes,  no,   0, no) \
+    SC( 50,     17,       15,      3, yes,  no,   0, no) \
+    SC( 51,     17,       15,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 52,     18,       16,      1, yes,  no,   0, no) \
+    SC( 53,     18,       16,      2, yes,  no,   0, no) \
+    SC( 54,     18,       16,      3, yes,  no,   0, no) \
+    SC( 55,     18,       16,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 56,     19,       17,      1, yes,  no,   0, no) \
+    SC( 57,     19,       17,      2, yes,  no,   0, no) \
+    SC( 58,     19,       17,      3, yes,  no,   0, no) \
+    SC( 59,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 60,     20,       18,      1, yes,  no,   0, no) \
+    SC( 61,     20,       18,      2, yes,  no,   0, no) \
+    SC( 62,     20,       18,      3, yes,  no,   0, no) \
+    SC( 63,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 64,     21,       19,      1, yes,  no,   0, no) \
+    SC( 65,     21,       19,      2, yes,  no,   0, no) \
+    SC( 66,     21,       19,      3, yes,  no,   0, no) \
+    SC( 67,     21,       19,      4, yes,  no,   0, no) \
                                                          \
     SC( 68,     22,       20,      1, yes,  no,   0, no) \
     SC( 69,     22,       20,      2, yes,  no,   0, no) \
@@ -485,80 +786,227 @@
 #define LARGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
 #endif
 
-#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 2 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
-    SC(  0,      3,        3,      0,  no, yes,   1,  3) \
-    SC(  1,      3,        3,      1,  no, yes,   1,  3) \
-    SC(  2,      3,        3,      2,  no, yes,   3,  3) \
-    SC(  3,      3,        3,      3,  no, yes,   1,  3) \
+    SC(  0,      4,        4,      0,  no, yes,   1,  4) \
+    SC(  1,      4,        4,      1,  no, yes,   1,  4) \
+    SC(  2,      4,        4,      2,  no, yes,   3,  4) \
+    SC(  3,      4,        4,      3,  no, yes,   1,  4) \
                                                          \
-    SC(  4,      5,        3,      1,  no, yes,   5,  3) \
-    SC(  5,      5,        3,      2,  no, yes,   3,  3) \
-    SC(  6,      5,        3,      3,  no, yes,   7,  3) \
-    SC(  7,      5,        3,      4,  no, yes,   1,  3) \
+    SC(  4,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  5,      6,        4,      2,  no, yes,   3,  4) \
+    SC(  6,      6,        4,      3,  no, yes,   7,  4) \
+    SC(  7,      6,        4,      4,  no, yes,   1,  4) \
                                                          \
-    SC(  8,      6,        4,      1,  no, yes,   5,  4) \
-    SC(  9,      6,        4,      2,  no, yes,   3,  4) \
-    SC( 10,      6,        4,      3,  no, yes,   7,  4) \
-    SC( 11,      6,        4,      4,  no, yes,   1,  4) \
+    SC(  8,      7,        5,      1,  no, yes,   5,  5) \
+    SC(  9,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 10,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 11,      7,        5,      4,  no, yes,   1,  5) \
                                                          \
-    SC( 12,      7,        5,      1,  no, yes,   5,  5) \
-    SC( 13,      7,        5,      2,  no, yes,   3,  5) \
-    SC( 14,      7,        5,      3,  no, yes,   7,  5) \
-    SC( 15,      7,        5,      4,  no, yes,   1,  5) \
+    SC( 12,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 13,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 14,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 15,      8,        6,      4,  no, yes,   1,  6) \
                                                          \
-    SC( 16,      8,        6,      1,  no, yes,   5,  6) \
-    SC( 17,      8,        6,      2,  no, yes,   3,  6) \
-    SC( 18,      8,        6,      3,  no, yes,   7,  6) \
-    SC( 19,      8,        6,      4,  no, yes,   1,  6) \
+    SC( 16,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 17,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 18,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 19,      9,        7,      4,  no, yes,   1,  7) \
                                                          \
-    SC( 20,      9,        7,      1,  no, yes,   5,  7) \
-    SC( 21,      9,        7,      2,  no, yes,   3,  7) \
-    SC( 22,      9,        7,      3,  no, yes,   7,  7) \
-    SC( 23,      9,        7,      4,  no, yes,   1,  7) \
+    SC( 20,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 21,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 22,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 23,     10,        8,      4,  no, yes,   1,  8) \
                                                          \
-    SC( 24,     10,        8,      1,  no, yes,   5,  8) \
-    SC( 25,     10,        8,      2,  no, yes,   3,  8) \
-    SC( 26,     10,        8,      3,  no, yes,   7,  8) \
-    SC( 27,     10,        8,      4,  no, yes,   1,  8) \
+    SC( 24,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 25,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 26,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 27,     11,        9,      4,  no, yes,   1,  9) \
                                                          \
-    SC( 28,     11,        9,      1,  no, yes,   5,  9) \
-    SC( 29,     11,        9,      2,  no, yes,   3,  9) \
-    SC( 30,     11,        9,      3,  no, yes,   7,  9) \
-    SC( 31,     11,        9,      4, yes, yes,   1,  9) \
+    SC( 28,     12,       10,      1,  no, yes,   5, no) \
+    SC( 29,     12,       10,      2,  no, yes,   3, no) \
+    SC( 30,     12,       10,      3,  no, yes,   7, no) \
+    SC( 31,     12,       10,      4,  no, yes,   1, no) \
                                                          \
-    SC( 32,     12,       10,      1,  no, yes,   5, no) \
-    SC( 33,     12,       10,      2,  no, yes,   3, no) \
-    SC( 34,     12,       10,      3,  no, yes,   7, no) \
-    SC( 35,     12,       10,      4, yes, yes,   2, no) \
+    SC( 32,     13,       11,      1,  no, yes,   5, no) \
+    SC( 33,     13,       11,      2,  no, yes,   3, no) \
+    SC( 34,     13,       11,      3,  no, yes,   7, no) \
+    SC( 35,     13,       11,      4, yes, yes,   1, no) \
                                                          \
-    SC( 36,     13,       11,      1,  no, yes,   5, no) \
-    SC( 37,     13,       11,      2, yes, yes,   3, no) \
-    SC( 38,     13,       11,      3,  no, yes,   7, no) \
-    SC( 39,     13,       11,      4, yes,  no,   0, no) \
+    SC( 36,     14,       12,      1,  no, yes,   5, no) \
+    SC( 37,     14,       12,      2,  no, yes,   3, no) \
+    SC( 38,     14,       12,      3,  no, yes,   7, no) \
+    SC( 39,     14,       12,      4, yes, yes,   2, no) \
                                                          \
-    SC( 40,     14,       12,      1, yes,  no,   0, no) \
-    SC( 41,     14,       12,      2, yes,  no,   0, no) \
-    SC( 42,     14,       12,      3, yes,  no,   0, no) \
-    SC( 43,     14,       12,      4, yes,  no,   0, no) \
+    SC( 40,     15,       13,      1,  no, yes,   5, no) \
+    SC( 41,     15,       13,      2, yes, yes,   3, no) \
+    SC( 42,     15,       13,      3,  no, yes,   7, no) \
+    SC( 43,     15,       13,      4, yes,  no,   0, no) \
                                                          \
-    SC( 44,     15,       13,      1, yes,  no,   0, no) \
-    SC( 45,     15,       13,      2, yes,  no,   0, no) \
-    SC( 46,     15,       13,      3, yes,  no,   0, no) \
-    SC( 47,     15,       13,      4, yes,  no,   0, no) \
+    SC( 44,     16,       14,      1, yes,  no,   0, no) \
+    SC( 45,     16,       14,      2, yes,  no,   0, no) \
+    SC( 46,     16,       14,      3, yes,  no,   0, no) \
+    SC( 47,     16,       14,      4, yes,  no,   0, no) \
                                                          \
-    SC( 48,     16,       14,      1, yes,  no,   0, no) \
-    SC( 49,     16,       14,      2, yes,  no,   0, no) \
-    SC( 50,     16,       14,      3, yes,  no,   0, no) \
-    SC( 51,     16,       14,      4, yes,  no,   0, no) \
+    SC( 48,     17,       15,      1, yes,  no,   0, no) \
+    SC( 49,     17,       15,      2, yes,  no,   0, no) \
+    SC( 50,     17,       15,      3, yes,  no,   0, no) \
+    SC( 51,     17,       15,      4, yes,  no,   0, no) \
                                                          \
-    SC( 52,     17,       15,      1, yes,  no,   0, no) \
-    SC( 53,     17,       15,      2, yes,  no,   0, no) \
-    SC( 54,     17,       15,      3, yes,  no,   0, no) \
-    SC( 55,     17,       15,      4, yes,  no,   0, no) \
+    SC( 52,     18,       16,      1, yes,  no,   0, no) \
+    SC( 53,     18,       16,      2, yes,  no,   0, no) \
+    SC( 54,     18,       16,      3, yes,  no,   0, no) \
+    SC( 55,     18,       16,      4, yes,  no,   0, no) \
                                                          \
-    SC( 56,     18,       16,      1, yes,  no,   0, no) \
+    SC( 56,     19,       17,      1, yes,  no,   0, no) \
+    SC( 57,     19,       17,      2, yes,  no,   0, no) \
+    SC( 58,     19,       17,      3, yes,  no,   0, no) \
+    SC( 59,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 60,     20,       18,      1, yes,  no,   0, no) \
+    SC( 61,     20,       18,      2, yes,  no,   0, no) \
+    SC( 62,     20,       18,      3, yes,  no,   0, no) \
+    SC( 63,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 64,     21,       19,      1, yes,  no,   0, no) \
+    SC( 65,     21,       19,      2, yes,  no,   0, no) \
+    SC( 66,     21,       19,      3, yes,  no,   0, no) \
+    SC( 67,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 68,     22,       20,      1, yes,  no,   0, no) \
+    SC( 69,     22,       20,      2, yes,  no,   0, no) \
+    SC( 70,     22,       20,      3, yes,  no,   0, no) \
+    SC( 71,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 72,     23,       21,      1, yes,  no,   0, no) \
+    SC( 73,     23,       21,      2, yes,  no,   0, no) \
+    SC( 74,     23,       21,      3, yes,  no,   0, no) \
+    SC( 75,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 76,     24,       22,      1, yes,  no,   0, no) \
+    SC( 77,     24,       22,      2, yes,  no,   0, no) \
+    SC( 78,     24,       22,      3, yes,  no,   0, no) \
+    SC( 79,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 80,     25,       23,      1, yes,  no,   0, no) \
+    SC( 81,     25,       23,      2, yes,  no,   0, no) \
+    SC( 82,     25,       23,      3, yes,  no,   0, no) \
+    SC( 83,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 84,     26,       24,      1, yes,  no,   0, no) \
+    SC( 85,     26,       24,      2, yes,  no,   0, no) \
+    SC( 86,     26,       24,      3, yes,  no,   0, no) \
+    SC( 87,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 88,     27,       25,      1, yes,  no,   0, no) \
+    SC( 89,     27,       25,      2, yes,  no,   0, no) \
+    SC( 90,     27,       25,      3, yes,  no,   0, no) \
+    SC( 91,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 92,     28,       26,      1, yes,  no,   0, no) \
+    SC( 93,     28,       26,      2, yes,  no,   0, no) \
+    SC( 94,     28,       26,      3, yes,  no,   0, no) \
+    SC( 95,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 96,     29,       27,      1, yes,  no,   0, no) \
+    SC( 97,     29,       27,      2, yes,  no,   0, no) \
+    SC( 98,     29,       27,      3, yes,  no,   0, no) \
+    SC( 99,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(100,     30,       28,      1, yes,  no,   0, no) \
+    SC(101,     30,       28,      2, yes,  no,   0, no) \
+    SC(102,     30,       28,      3, yes,  no,   0, no) \
+
+#define SIZE_CLASSES_DEFINED
+#define NTBINS			0
+#define NLBINS			28
+#define NBINS			43
+#define NSIZES			103
+#define LG_CEIL_NSIZES		7
+#define NPSIZES			63
+#define LG_TINY_MAXCLASS	"NA"
+#define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define LG_LARGE_MINCLASS	16
+#define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
+#define LARGE_MAXCLASS		((((size_t)1) << 30) + (((size_t)3) << 28))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 12)
+#define SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,   1,  3) \
+    SC(  1,      3,        3,      1,  no, yes,   1,  3) \
+    SC(  2,      3,        3,      2,  no, yes,   3,  3) \
+    SC(  3,      3,        3,      3,  no, yes,   1,  3) \
+                                                         \
+    SC(  4,      5,        3,      1,  no, yes,   5,  3) \
+    SC(  5,      5,        3,      2,  no, yes,   3,  3) \
+    SC(  6,      5,        3,      3,  no, yes,   7,  3) \
+    SC(  7,      5,        3,      4,  no, yes,   1,  3) \
+                                                         \
+    SC(  8,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  9,      6,        4,      2,  no, yes,   3,  4) \
+    SC( 10,      6,        4,      3,  no, yes,   7,  4) \
+    SC( 11,      6,        4,      4,  no, yes,   1,  4) \
+                                                         \
+    SC( 12,      7,        5,      1,  no, yes,   5,  5) \
+    SC( 13,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 14,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 15,      7,        5,      4,  no, yes,   1,  5) \
+                                                         \
+    SC( 16,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 17,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 18,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 19,      8,        6,      4,  no, yes,   1,  6) \
+                                                         \
+    SC( 20,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 21,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 22,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 23,      9,        7,      4,  no, yes,   1,  7) \
+                                                         \
+    SC( 24,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 25,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 26,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 27,     10,        8,      4,  no, yes,   1,  8) \
+                                                         \
+    SC( 28,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 29,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 30,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 31,     11,        9,      4, yes, yes,   1,  9) \
+                                                         \
+    SC( 32,     12,       10,      1,  no, yes,   5, no) \
+    SC( 33,     12,       10,      2,  no, yes,   3, no) \
+    SC( 34,     12,       10,      3,  no, yes,   7, no) \
+    SC( 35,     12,       10,      4, yes, yes,   2, no) \
+                                                         \
+    SC( 36,     13,       11,      1,  no, yes,   5, no) \
+    SC( 37,     13,       11,      2, yes, yes,   3, no) \
+    SC( 38,     13,       11,      3,  no, yes,   7, no) \
+    SC( 39,     13,       11,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 40,     14,       12,      1, yes,  no,   0, no) \
+    SC( 41,     14,       12,      2, yes,  no,   0, no) \
+    SC( 42,     14,       12,      3, yes,  no,   0, no) \
+    SC( 43,     14,       12,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 44,     15,       13,      1, yes,  no,   0, no) \
+    SC( 45,     15,       13,      2, yes,  no,   0, no) \
+    SC( 46,     15,       13,      3, yes,  no,   0, no) \
+    SC( 47,     15,       13,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 48,     16,       14,      1, yes,  no,   0, no) \
+    SC( 49,     16,       14,      2, yes,  no,   0, no) \
+    SC( 50,     16,       14,      3, yes,  no,   0, no) \
+    SC( 51,     16,       14,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 52,     17,       15,      1, yes,  no,   0, no) \
+    SC( 53,     17,       15,      2, yes,  no,   0, no) \
+    SC( 54,     17,       15,      3, yes,  no,   0, no) \
+    SC( 55,     17,       15,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 56,     18,       16,      1, yes,  no,   0, no) \
     SC( 57,     18,       16,      2, yes,  no,   0, no) \
     SC( 58,     18,       16,      3, yes,  no,   0, no) \
     SC( 59,     18,       16,      4, yes,  no,   0, no) \
@@ -797,308 +1245,1236 @@
 #define LARGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif
 
-#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 3 && LG_PAGE == 14)
 #define SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
     SC(  0,      3,        3,      0,  no, yes,   1,  3) \
-                                                         \
     SC(  1,      3,        3,      1,  no, yes,   1,  3) \
-    SC(  2,      4,        4,      1,  no, yes,   1,  4) \
-    SC(  3,      4,        4,      2,  no, yes,   3,  4) \
-    SC(  4,      4,        4,      3,  no, yes,   1,  4) \
+    SC(  2,      3,        3,      2,  no, yes,   3,  3) \
+    SC(  3,      3,        3,      3,  no, yes,   1,  3) \
                                                          \
-    SC(  5,      6,        4,      1,  no, yes,   5,  4) \
-    SC(  6,      6,        4,      2,  no, yes,   3,  4) \
-    SC(  7,      6,        4,      3,  no, yes,   7,  4) \
-    SC(  8,      6,        4,      4,  no, yes,   1,  4) \
+    SC(  4,      5,        3,      1,  no, yes,   5,  3) \
+    SC(  5,      5,        3,      2,  no, yes,   3,  3) \
+    SC(  6,      5,        3,      3,  no, yes,   7,  3) \
+    SC(  7,      5,        3,      4,  no, yes,   1,  3) \
                                                          \
-    SC(  9,      7,        5,      1,  no, yes,   5,  5) \
-    SC( 10,      7,        5,      2,  no, yes,   3,  5) \
-    SC( 11,      7,        5,      3,  no, yes,   7,  5) \
-    SC( 12,      7,        5,      4,  no, yes,   1,  5) \
+    SC(  8,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  9,      6,        4,      2,  no, yes,   3,  4) \
+    SC( 10,      6,        4,      3,  no, yes,   7,  4) \
+    SC( 11,      6,        4,      4,  no, yes,   1,  4) \
                                                          \
-    SC( 13,      8,        6,      1,  no, yes,   5,  6) \
-    SC( 14,      8,        6,      2,  no, yes,   3,  6) \
-    SC( 15,      8,        6,      3,  no, yes,   7,  6) \
-    SC( 16,      8,        6,      4,  no, yes,   1,  6) \
+    SC( 12,      7,        5,      1,  no, yes,   5,  5) \
+    SC( 13,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 14,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 15,      7,        5,      4,  no, yes,   1,  5) \
                                                          \
-    SC( 17,      9,        7,      1,  no, yes,   5,  7) \
-    SC( 18,      9,        7,      2,  no, yes,   3,  7) \
-    SC( 19,      9,        7,      3,  no, yes,   7,  7) \
-    SC( 20,      9,        7,      4,  no, yes,   1,  7) \
+    SC( 16,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 17,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 18,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 19,      8,        6,      4,  no, yes,   1,  6) \
                                                          \
-    SC( 21,     10,        8,      1,  no, yes,   5,  8) \
-    SC( 22,     10,        8,      2,  no, yes,   3,  8) \
-    SC( 23,     10,        8,      3,  no, yes,   7,  8) \
-    SC( 24,     10,        8,      4,  no, yes,   1,  8) \
+    SC( 20,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 21,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 22,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 23,      9,        7,      4,  no, yes,   1,  7) \
                                                          \
-    SC( 25,     11,        9,      1,  no, yes,   5,  9) \
-    SC( 26,     11,        9,      2,  no, yes,   3,  9) \
-    SC( 27,     11,        9,      3,  no, yes,   7,  9) \
-    SC( 28,     11,        9,      4, yes, yes,   1,  9) \
+    SC( 24,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 25,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 26,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 27,     10,        8,      4,  no, yes,   1,  8) \
                                                          \
-    SC( 29,     12,       10,      1,  no, yes,   5, no) \
-    SC( 30,     12,       10,      2,  no, yes,   3, no) \
-    SC( 31,     12,       10,      3,  no, yes,   7, no) \
-    SC( 32,     12,       10,      4, yes, yes,   2, no) \
+    SC( 28,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 29,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 30,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 31,     11,        9,      4,  no, yes,   1,  9) \
                                                          \
-    SC( 33,     13,       11,      1,  no, yes,   5, no) \
-    SC( 34,     13,       11,      2, yes, yes,   3, no) \
-    SC( 35,     13,       11,      3,  no, yes,   7, no) \
-    SC( 36,     13,       11,      4, yes,  no,   0, no) \
+    SC( 32,     12,       10,      1,  no, yes,   5, no) \
+    SC( 33,     12,       10,      2,  no, yes,   3, no) \
+    SC( 34,     12,       10,      3,  no, yes,   7, no) \
+    SC( 35,     12,       10,      4,  no, yes,   1, no) \
                                                          \
-    SC( 37,     14,       12,      1, yes,  no,   0, no) \
-    SC( 38,     14,       12,      2, yes,  no,   0, no) \
-    SC( 39,     14,       12,      3, yes,  no,   0, no) \
-    SC( 40,     14,       12,      4, yes,  no,   0, no) \
+    SC( 36,     13,       11,      1,  no, yes,   5, no) \
+    SC( 37,     13,       11,      2,  no, yes,   3, no) \
+    SC( 38,     13,       11,      3,  no, yes,   7, no) \
+    SC( 39,     13,       11,      4, yes, yes,   1, no) \
                                                          \
-    SC( 41,     15,       13,      1, yes,  no,   0, no) \
-    SC( 42,     15,       13,      2, yes,  no,   0, no) \
-    SC( 43,     15,       13,      3, yes,  no,   0, no) \
-    SC( 44,     15,       13,      4, yes,  no,   0, no) \
+    SC( 40,     14,       12,      1,  no, yes,   5, no) \
+    SC( 41,     14,       12,      2,  no, yes,   3, no) \
+    SC( 42,     14,       12,      3,  no, yes,   7, no) \
+    SC( 43,     14,       12,      4, yes, yes,   2, no) \
                                                          \
-    SC( 45,     16,       14,      1, yes,  no,   0, no) \
-    SC( 46,     16,       14,      2, yes,  no,   0, no) \
-    SC( 47,     16,       14,      3, yes,  no,   0, no) \
-    SC( 48,     16,       14,      4, yes,  no,   0, no) \
+    SC( 44,     15,       13,      1,  no, yes,   5, no) \
+    SC( 45,     15,       13,      2, yes, yes,   3, no) \
+    SC( 46,     15,       13,      3,  no, yes,   7, no) \
+    SC( 47,     15,       13,      4, yes,  no,   0, no) \
                                                          \
-    SC( 49,     17,       15,      1, yes,  no,   0, no) \
-    SC( 50,     17,       15,      2, yes,  no,   0, no) \
-    SC( 51,     17,       15,      3, yes,  no,   0, no) \
-    SC( 52,     17,       15,      4, yes,  no,   0, no) \
+    SC( 48,     16,       14,      1, yes,  no,   0, no) \
+    SC( 49,     16,       14,      2, yes,  no,   0, no) \
+    SC( 50,     16,       14,      3, yes,  no,   0, no) \
+    SC( 51,     16,       14,      4, yes,  no,   0, no) \
                                                          \
-    SC( 53,     18,       16,      1, yes,  no,   0, no) \
-    SC( 54,     18,       16,      2, yes,  no,   0, no) \
-    SC( 55,     18,       16,      3, yes,  no,   0, no) \
-    SC( 56,     18,       16,      4, yes,  no,   0, no) \
+    SC( 52,     17,       15,      1, yes,  no,   0, no) \
+    SC( 53,     17,       15,      2, yes,  no,   0, no) \
+    SC( 54,     17,       15,      3, yes,  no,   0, no) \
+    SC( 55,     17,       15,      4, yes,  no,   0, no) \
                                                          \
-    SC( 57,     19,       17,      1, yes,  no,   0, no) \
-    SC( 58,     19,       17,      2, yes,  no,   0, no) \
-    SC( 59,     19,       17,      3, yes,  no,   0, no) \
-    SC( 60,     19,       17,      4, yes,  no,   0, no) \
+    SC( 56,     18,       16,      1, yes,  no,   0, no) \
+    SC( 57,     18,       16,      2, yes,  no,   0, no) \
+    SC( 58,     18,       16,      3, yes,  no,   0, no) \
+    SC( 59,     18,       16,      4, yes,  no,   0, no) \
                                                          \
-    SC( 61,     20,       18,      1, yes,  no,   0, no) \
-    SC( 62,     20,       18,      2, yes,  no,   0, no) \
-    SC( 63,     20,       18,      3, yes,  no,   0, no) \
-    SC( 64,     20,       18,      4, yes,  no,   0, no) \
+    SC( 60,     19,       17,      1, yes,  no,   0, no) \
+    SC( 61,     19,       17,      2, yes,  no,   0, no) \
+    SC( 62,     19,       17,      3, yes,  no,   0, no) \
+    SC( 63,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 64,     20,       18,      1, yes,  no,   0, no) \
+    SC( 65,     20,       18,      2, yes,  no,   0, no) \
+    SC( 66,     20,       18,      3, yes,  no,   0, no) \
+    SC( 67,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 68,     21,       19,      1, yes,  no,   0, no) \
+    SC( 69,     21,       19,      2, yes,  no,   0, no) \
+    SC( 70,     21,       19,      3, yes,  no,   0, no) \
+    SC( 71,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 72,     22,       20,      1, yes,  no,   0, no) \
+    SC( 73,     22,       20,      2, yes,  no,   0, no) \
+    SC( 74,     22,       20,      3, yes,  no,   0, no) \
+    SC( 75,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 76,     23,       21,      1, yes,  no,   0, no) \
+    SC( 77,     23,       21,      2, yes,  no,   0, no) \
+    SC( 78,     23,       21,      3, yes,  no,   0, no) \
+    SC( 79,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 80,     24,       22,      1, yes,  no,   0, no) \
+    SC( 81,     24,       22,      2, yes,  no,   0, no) \
+    SC( 82,     24,       22,      3, yes,  no,   0, no) \
+    SC( 83,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 84,     25,       23,      1, yes,  no,   0, no) \
+    SC( 85,     25,       23,      2, yes,  no,   0, no) \
+    SC( 86,     25,       23,      3, yes,  no,   0, no) \
+    SC( 87,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 88,     26,       24,      1, yes,  no,   0, no) \
+    SC( 89,     26,       24,      2, yes,  no,   0, no) \
+    SC( 90,     26,       24,      3, yes,  no,   0, no) \
+    SC( 91,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 92,     27,       25,      1, yes,  no,   0, no) \
+    SC( 93,     27,       25,      2, yes,  no,   0, no) \
+    SC( 94,     27,       25,      3, yes,  no,   0, no) \
+    SC( 95,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 96,     28,       26,      1, yes,  no,   0, no) \
+    SC( 97,     28,       26,      2, yes,  no,   0, no) \
+    SC( 98,     28,       26,      3, yes,  no,   0, no) \
+    SC( 99,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC(100,     29,       27,      1, yes,  no,   0, no) \
+    SC(101,     29,       27,      2, yes,  no,   0, no) \
+    SC(102,     29,       27,      3, yes,  no,   0, no) \
+    SC(103,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(104,     30,       28,      1, yes,  no,   0, no) \
+    SC(105,     30,       28,      2, yes,  no,   0, no) \
+    SC(106,     30,       28,      3, yes,  no,   0, no) \
+    SC(107,     30,       28,      4, yes,  no,   0, no) \
+                                                         \
+    SC(108,     31,       29,      1, yes,  no,   0, no) \
+    SC(109,     31,       29,      2, yes,  no,   0, no) \
+    SC(110,     31,       29,      3, yes,  no,   0, no) \
+    SC(111,     31,       29,      4, yes,  no,   0, no) \
+                                                         \
+    SC(112,     32,       30,      1, yes,  no,   0, no) \
+    SC(113,     32,       30,      2, yes,  no,   0, no) \
+    SC(114,     32,       30,      3, yes,  no,   0, no) \
+    SC(115,     32,       30,      4, yes,  no,   0, no) \
+                                                         \
+    SC(116,     33,       31,      1, yes,  no,   0, no) \
+    SC(117,     33,       31,      2, yes,  no,   0, no) \
+    SC(118,     33,       31,      3, yes,  no,   0, no) \
+    SC(119,     33,       31,      4, yes,  no,   0, no) \
+                                                         \
+    SC(120,     34,       32,      1, yes,  no,   0, no) \
+    SC(121,     34,       32,      2, yes,  no,   0, no) \
+    SC(122,     34,       32,      3, yes,  no,   0, no) \
+    SC(123,     34,       32,      4, yes,  no,   0, no) \
+                                                         \
+    SC(124,     35,       33,      1, yes,  no,   0, no) \
+    SC(125,     35,       33,      2, yes,  no,   0, no) \
+    SC(126,     35,       33,      3, yes,  no,   0, no) \
+    SC(127,     35,       33,      4, yes,  no,   0, no) \
+                                                         \
+    SC(128,     36,       34,      1, yes,  no,   0, no) \
+    SC(129,     36,       34,      2, yes,  no,   0, no) \
+    SC(130,     36,       34,      3, yes,  no,   0, no) \
+    SC(131,     36,       34,      4, yes,  no,   0, no) \
+                                                         \
+    SC(132,     37,       35,      1, yes,  no,   0, no) \
+    SC(133,     37,       35,      2, yes,  no,   0, no) \
+    SC(134,     37,       35,      3, yes,  no,   0, no) \
+    SC(135,     37,       35,      4, yes,  no,   0, no) \
+                                                         \
+    SC(136,     38,       36,      1, yes,  no,   0, no) \
+    SC(137,     38,       36,      2, yes,  no,   0, no) \
+    SC(138,     38,       36,      3, yes,  no,   0, no) \
+    SC(139,     38,       36,      4, yes,  no,   0, no) \
+                                                         \
+    SC(140,     39,       37,      1, yes,  no,   0, no) \
+    SC(141,     39,       37,      2, yes,  no,   0, no) \
+    SC(142,     39,       37,      3, yes,  no,   0, no) \
+    SC(143,     39,       37,      4, yes,  no,   0, no) \
+                                                         \
+    SC(144,     40,       38,      1, yes,  no,   0, no) \
+    SC(145,     40,       38,      2, yes,  no,   0, no) \
+    SC(146,     40,       38,      3, yes,  no,   0, no) \
+    SC(147,     40,       38,      4, yes,  no,   0, no) \
+                                                         \
+    SC(148,     41,       39,      1, yes,  no,   0, no) \
+    SC(149,     41,       39,      2, yes,  no,   0, no) \
+    SC(150,     41,       39,      3, yes,  no,   0, no) \
+    SC(151,     41,       39,      4, yes,  no,   0, no) \
+                                                         \
+    SC(152,     42,       40,      1, yes,  no,   0, no) \
+    SC(153,     42,       40,      2, yes,  no,   0, no) \
+    SC(154,     42,       40,      3, yes,  no,   0, no) \
+    SC(155,     42,       40,      4, yes,  no,   0, no) \
+                                                         \
+    SC(156,     43,       41,      1, yes,  no,   0, no) \
+    SC(157,     43,       41,      2, yes,  no,   0, no) \
+    SC(158,     43,       41,      3, yes,  no,   0, no) \
+    SC(159,     43,       41,      4, yes,  no,   0, no) \
+                                                         \
+    SC(160,     44,       42,      1, yes,  no,   0, no) \
+    SC(161,     44,       42,      2, yes,  no,   0, no) \
+    SC(162,     44,       42,      3, yes,  no,   0, no) \
+    SC(163,     44,       42,      4, yes,  no,   0, no) \
+                                                         \
+    SC(164,     45,       43,      1, yes,  no,   0, no) \
+    SC(165,     45,       43,      2, yes,  no,   0, no) \
+    SC(166,     45,       43,      3, yes,  no,   0, no) \
+    SC(167,     45,       43,      4, yes,  no,   0, no) \
+                                                         \
+    SC(168,     46,       44,      1, yes,  no,   0, no) \
+    SC(169,     46,       44,      2, yes,  no,   0, no) \
+    SC(170,     46,       44,      3, yes,  no,   0, no) \
+    SC(171,     46,       44,      4, yes,  no,   0, no) \
+                                                         \
+    SC(172,     47,       45,      1, yes,  no,   0, no) \
+    SC(173,     47,       45,      2, yes,  no,   0, no) \
+    SC(174,     47,       45,      3, yes,  no,   0, no) \
+    SC(175,     47,       45,      4, yes,  no,   0, no) \
+                                                         \
+    SC(176,     48,       46,      1, yes,  no,   0, no) \
+    SC(177,     48,       46,      2, yes,  no,   0, no) \
+    SC(178,     48,       46,      3, yes,  no,   0, no) \
+    SC(179,     48,       46,      4, yes,  no,   0, no) \
+                                                         \
+    SC(180,     49,       47,      1, yes,  no,   0, no) \
+    SC(181,     49,       47,      2, yes,  no,   0, no) \
+    SC(182,     49,       47,      3, yes,  no,   0, no) \
+    SC(183,     49,       47,      4, yes,  no,   0, no) \
+                                                         \
+    SC(184,     50,       48,      1, yes,  no,   0, no) \
+    SC(185,     50,       48,      2, yes,  no,   0, no) \
+    SC(186,     50,       48,      3, yes,  no,   0, no) \
+    SC(187,     50,       48,      4, yes,  no,   0, no) \
+                                                         \
+    SC(188,     51,       49,      1, yes,  no,   0, no) \
+    SC(189,     51,       49,      2, yes,  no,   0, no) \
+    SC(190,     51,       49,      3, yes,  no,   0, no) \
+    SC(191,     51,       49,      4, yes,  no,   0, no) \
+                                                         \
+    SC(192,     52,       50,      1, yes,  no,   0, no) \
+    SC(193,     52,       50,      2, yes,  no,   0, no) \
+    SC(194,     52,       50,      3, yes,  no,   0, no) \
+    SC(195,     52,       50,      4, yes,  no,   0, no) \
+                                                         \
+    SC(196,     53,       51,      1, yes,  no,   0, no) \
+    SC(197,     53,       51,      2, yes,  no,   0, no) \
+    SC(198,     53,       51,      3, yes,  no,   0, no) \
+    SC(199,     53,       51,      4, yes,  no,   0, no) \
+                                                         \
+    SC(200,     54,       52,      1, yes,  no,   0, no) \
+    SC(201,     54,       52,      2, yes,  no,   0, no) \
+    SC(202,     54,       52,      3, yes,  no,   0, no) \
+    SC(203,     54,       52,      4, yes,  no,   0, no) \
+                                                         \
+    SC(204,     55,       53,      1, yes,  no,   0, no) \
+    SC(205,     55,       53,      2, yes,  no,   0, no) \
+    SC(206,     55,       53,      3, yes,  no,   0, no) \
+    SC(207,     55,       53,      4, yes,  no,   0, no) \
+                                                         \
+    SC(208,     56,       54,      1, yes,  no,   0, no) \
+    SC(209,     56,       54,      2, yes,  no,   0, no) \
+    SC(210,     56,       54,      3, yes,  no,   0, no) \
+    SC(211,     56,       54,      4, yes,  no,   0, no) \
+                                                         \
+    SC(212,     57,       55,      1, yes,  no,   0, no) \
+    SC(213,     57,       55,      2, yes,  no,   0, no) \
+    SC(214,     57,       55,      3, yes,  no,   0, no) \
+    SC(215,     57,       55,      4, yes,  no,   0, no) \
+                                                         \
+    SC(216,     58,       56,      1, yes,  no,   0, no) \
+    SC(217,     58,       56,      2, yes,  no,   0, no) \
+    SC(218,     58,       56,      3, yes,  no,   0, no) \
+    SC(219,     58,       56,      4, yes,  no,   0, no) \
+                                                         \
+    SC(220,     59,       57,      1, yes,  no,   0, no) \
+    SC(221,     59,       57,      2, yes,  no,   0, no) \
+    SC(222,     59,       57,      3, yes,  no,   0, no) \
+    SC(223,     59,       57,      4, yes,  no,   0, no) \
+                                                         \
+    SC(224,     60,       58,      1, yes,  no,   0, no) \
+    SC(225,     60,       58,      2, yes,  no,   0, no) \
+    SC(226,     60,       58,      3, yes,  no,   0, no) \
+    SC(227,     60,       58,      4, yes,  no,   0, no) \
+                                                         \
+    SC(228,     61,       59,      1, yes,  no,   0, no) \
+    SC(229,     61,       59,      2, yes,  no,   0, no) \
+    SC(230,     61,       59,      3, yes,  no,   0, no) \
+    SC(231,     61,       59,      4, yes,  no,   0, no) \
+                                                         \
+    SC(232,     62,       60,      1, yes,  no,   0, no) \
+    SC(233,     62,       60,      2, yes,  no,   0, no) \
+    SC(234,     62,       60,      3, yes,  no,   0, no) \
+
+#define SIZE_CLASSES_DEFINED
+#define NTBINS			0
+#define NLBINS			32
+#define NBINS			47
+#define NSIZES			235
+#define LG_CEIL_NSIZES		8
+#define NPSIZES			191
+#define LG_TINY_MAXCLASS	"NA"
+#define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define LG_LARGE_MINCLASS	16
+#define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
+#define LARGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,   1,  3) \
+                                                         \
+    SC(  1,      3,        3,      1,  no, yes,   1,  3) \
+    SC(  2,      4,        4,      1,  no, yes,   1,  4) \
+    SC(  3,      4,        4,      2,  no, yes,   3,  4) \
+    SC(  4,      4,        4,      3,  no, yes,   1,  4) \
+                                                         \
+    SC(  5,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  6,      6,        4,      2,  no, yes,   3,  4) \
+    SC(  7,      6,        4,      3,  no, yes,   7,  4) \
+    SC(  8,      6,        4,      4,  no, yes,   1,  4) \
+                                                         \
+    SC(  9,      7,        5,      1,  no, yes,   5,  5) \
+    SC( 10,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 11,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 12,      7,        5,      4,  no, yes,   1,  5) \
+                                                         \
+    SC( 13,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 14,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 15,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 16,      8,        6,      4,  no, yes,   1,  6) \
+                                                         \
+    SC( 17,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 18,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 19,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 20,      9,        7,      4,  no, yes,   1,  7) \
+                                                         \
+    SC( 21,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 22,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 23,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 24,     10,        8,      4,  no, yes,   1,  8) \
+                                                         \
+    SC( 25,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 26,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 27,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 28,     11,        9,      4, yes, yes,   1,  9) \
+                                                         \
+    SC( 29,     12,       10,      1,  no, yes,   5, no) \
+    SC( 30,     12,       10,      2,  no, yes,   3, no) \
+    SC( 31,     12,       10,      3,  no, yes,   7, no) \
+    SC( 32,     12,       10,      4, yes, yes,   2, no) \
+                                                         \
+    SC( 33,     13,       11,      1,  no, yes,   5, no) \
+    SC( 34,     13,       11,      2, yes, yes,   3, no) \
+    SC( 35,     13,       11,      3,  no, yes,   7, no) \
+    SC( 36,     13,       11,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 37,     14,       12,      1, yes,  no,   0, no) \
+    SC( 38,     14,       12,      2, yes,  no,   0, no) \
+    SC( 39,     14,       12,      3, yes,  no,   0, no) \
+    SC( 40,     14,       12,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 41,     15,       13,      1, yes,  no,   0, no) \
+    SC( 42,     15,       13,      2, yes,  no,   0, no) \
+    SC( 43,     15,       13,      3, yes,  no,   0, no) \
+    SC( 44,     15,       13,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 45,     16,       14,      1, yes,  no,   0, no) \
+    SC( 46,     16,       14,      2, yes,  no,   0, no) \
+    SC( 47,     16,       14,      3, yes,  no,   0, no) \
+    SC( 48,     16,       14,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 49,     17,       15,      1, yes,  no,   0, no) \
+    SC( 50,     17,       15,      2, yes,  no,   0, no) \
+    SC( 51,     17,       15,      3, yes,  no,   0, no) \
+    SC( 52,     17,       15,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 53,     18,       16,      1, yes,  no,   0, no) \
+    SC( 54,     18,       16,      2, yes,  no,   0, no) \
+    SC( 55,     18,       16,      3, yes,  no,   0, no) \
+    SC( 56,     18,       16,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 57,     19,       17,      1, yes,  no,   0, no) \
+    SC( 58,     19,       17,      2, yes,  no,   0, no) \
+    SC( 59,     19,       17,      3, yes,  no,   0, no) \
+    SC( 60,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 61,     20,       18,      1, yes,  no,   0, no) \
+    SC( 62,     20,       18,      2, yes,  no,   0, no) \
+    SC( 63,     20,       18,      3, yes,  no,   0, no) \
+    SC( 64,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 65,     21,       19,      1, yes,  no,   0, no) \
+    SC( 66,     21,       19,      2, yes,  no,   0, no) \
+    SC( 67,     21,       19,      3, yes,  no,   0, no) \
+    SC( 68,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 69,     22,       20,      1, yes,  no,   0, no) \
+    SC( 70,     22,       20,      2, yes,  no,   0, no) \
+    SC( 71,     22,       20,      3, yes,  no,   0, no) \
+    SC( 72,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 73,     23,       21,      1, yes,  no,   0, no) \
+    SC( 74,     23,       21,      2, yes,  no,   0, no) \
+    SC( 75,     23,       21,      3, yes,  no,   0, no) \
+    SC( 76,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 77,     24,       22,      1, yes,  no,   0, no) \
+    SC( 78,     24,       22,      2, yes,  no,   0, no) \
+    SC( 79,     24,       22,      3, yes,  no,   0, no) \
+    SC( 80,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 81,     25,       23,      1, yes,  no,   0, no) \
+    SC( 82,     25,       23,      2, yes,  no,   0, no) \
+    SC( 83,     25,       23,      3, yes,  no,   0, no) \
+    SC( 84,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 85,     26,       24,      1, yes,  no,   0, no) \
+    SC( 86,     26,       24,      2, yes,  no,   0, no) \
+    SC( 87,     26,       24,      3, yes,  no,   0, no) \
+    SC( 88,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 89,     27,       25,      1, yes,  no,   0, no) \
+    SC( 90,     27,       25,      2, yes,  no,   0, no) \
+    SC( 91,     27,       25,      3, yes,  no,   0, no) \
+    SC( 92,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 93,     28,       26,      1, yes,  no,   0, no) \
+    SC( 94,     28,       26,      2, yes,  no,   0, no) \
+    SC( 95,     28,       26,      3, yes,  no,   0, no) \
+    SC( 96,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 97,     29,       27,      1, yes,  no,   0, no) \
+    SC( 98,     29,       27,      2, yes,  no,   0, no) \
+    SC( 99,     29,       27,      3, yes,  no,   0, no) \
+    SC(100,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(101,     30,       28,      1, yes,  no,   0, no) \
+    SC(102,     30,       28,      2, yes,  no,   0, no) \
+    SC(103,     30,       28,      3, yes,  no,   0, no) \
+    SC(104,     30,       28,      4, yes,  no,   0, no) \
+                                                         \
+    SC(105,     31,       29,      1, yes,  no,   0, no) \
+    SC(106,     31,       29,      2, yes,  no,   0, no) \
+    SC(107,     31,       29,      3, yes,  no,   0, no) \
+    SC(108,     31,       29,      4, yes,  no,   0, no) \
+                                                         \
+    SC(109,     32,       30,      1, yes,  no,   0, no) \
+    SC(110,     32,       30,      2, yes,  no,   0, no) \
+    SC(111,     32,       30,      3, yes,  no,   0, no) \
+    SC(112,     32,       30,      4, yes,  no,   0, no) \
+                                                         \
+    SC(113,     33,       31,      1, yes,  no,   0, no) \
+    SC(114,     33,       31,      2, yes,  no,   0, no) \
+    SC(115,     33,       31,      3, yes,  no,   0, no) \
+    SC(116,     33,       31,      4, yes,  no,   0, no) \
+                                                         \
+    SC(117,     34,       32,      1, yes,  no,   0, no) \
+    SC(118,     34,       32,      2, yes,  no,   0, no) \
+    SC(119,     34,       32,      3, yes,  no,   0, no) \
+    SC(120,     34,       32,      4, yes,  no,   0, no) \
+                                                         \
+    SC(121,     35,       33,      1, yes,  no,   0, no) \
+    SC(122,     35,       33,      2, yes,  no,   0, no) \
+    SC(123,     35,       33,      3, yes,  no,   0, no) \
+    SC(124,     35,       33,      4, yes,  no,   0, no) \
+                                                         \
+    SC(125,     36,       34,      1, yes,  no,   0, no) \
+    SC(126,     36,       34,      2, yes,  no,   0, no) \
+    SC(127,     36,       34,      3, yes,  no,   0, no) \
+    SC(128,     36,       34,      4, yes,  no,   0, no) \
+                                                         \
+    SC(129,     37,       35,      1, yes,  no,   0, no) \
+    SC(130,     37,       35,      2, yes,  no,   0, no) \
+    SC(131,     37,       35,      3, yes,  no,   0, no) \
+    SC(132,     37,       35,      4, yes,  no,   0, no) \
+                                                         \
+    SC(133,     38,       36,      1, yes,  no,   0, no) \
+    SC(134,     38,       36,      2, yes,  no,   0, no) \
+    SC(135,     38,       36,      3, yes,  no,   0, no) \
+    SC(136,     38,       36,      4, yes,  no,   0, no) \
+                                                         \
+    SC(137,     39,       37,      1, yes,  no,   0, no) \
+    SC(138,     39,       37,      2, yes,  no,   0, no) \
+    SC(139,     39,       37,      3, yes,  no,   0, no) \
+    SC(140,     39,       37,      4, yes,  no,   0, no) \
+                                                         \
+    SC(141,     40,       38,      1, yes,  no,   0, no) \
+    SC(142,     40,       38,      2, yes,  no,   0, no) \
+    SC(143,     40,       38,      3, yes,  no,   0, no) \
+    SC(144,     40,       38,      4, yes,  no,   0, no) \
+                                                         \
+    SC(145,     41,       39,      1, yes,  no,   0, no) \
+    SC(146,     41,       39,      2, yes,  no,   0, no) \
+    SC(147,     41,       39,      3, yes,  no,   0, no) \
+    SC(148,     41,       39,      4, yes,  no,   0, no) \
+                                                         \
+    SC(149,     42,       40,      1, yes,  no,   0, no) \
+    SC(150,     42,       40,      2, yes,  no,   0, no) \
+    SC(151,     42,       40,      3, yes,  no,   0, no) \
+    SC(152,     42,       40,      4, yes,  no,   0, no) \
+                                                         \
+    SC(153,     43,       41,      1, yes,  no,   0, no) \
+    SC(154,     43,       41,      2, yes,  no,   0, no) \
+    SC(155,     43,       41,      3, yes,  no,   0, no) \
+    SC(156,     43,       41,      4, yes,  no,   0, no) \
+                                                         \
+    SC(157,     44,       42,      1, yes,  no,   0, no) \
+    SC(158,     44,       42,      2, yes,  no,   0, no) \
+    SC(159,     44,       42,      3, yes,  no,   0, no) \
+    SC(160,     44,       42,      4, yes,  no,   0, no) \
+                                                         \
+    SC(161,     45,       43,      1, yes,  no,   0, no) \
+    SC(162,     45,       43,      2, yes,  no,   0, no) \
+    SC(163,     45,       43,      3, yes,  no,   0, no) \
+    SC(164,     45,       43,      4, yes,  no,   0, no) \
+                                                         \
+    SC(165,     46,       44,      1, yes,  no,   0, no) \
+    SC(166,     46,       44,      2, yes,  no,   0, no) \
+    SC(167,     46,       44,      3, yes,  no,   0, no) \
+    SC(168,     46,       44,      4, yes,  no,   0, no) \
+                                                         \
+    SC(169,     47,       45,      1, yes,  no,   0, no) \
+    SC(170,     47,       45,      2, yes,  no,   0, no) \
+    SC(171,     47,       45,      3, yes,  no,   0, no) \
+    SC(172,     47,       45,      4, yes,  no,   0, no) \
+                                                         \
+    SC(173,     48,       46,      1, yes,  no,   0, no) \
+    SC(174,     48,       46,      2, yes,  no,   0, no) \
+    SC(175,     48,       46,      3, yes,  no,   0, no) \
+    SC(176,     48,       46,      4, yes,  no,   0, no) \
+                                                         \
+    SC(177,     49,       47,      1, yes,  no,   0, no) \
+    SC(178,     49,       47,      2, yes,  no,   0, no) \
+    SC(179,     49,       47,      3, yes,  no,   0, no) \
+    SC(180,     49,       47,      4, yes,  no,   0, no) \
+                                                         \
+    SC(181,     50,       48,      1, yes,  no,   0, no) \
+    SC(182,     50,       48,      2, yes,  no,   0, no) \
+    SC(183,     50,       48,      3, yes,  no,   0, no) \
+    SC(184,     50,       48,      4, yes,  no,   0, no) \
+                                                         \
+    SC(185,     51,       49,      1, yes,  no,   0, no) \
+    SC(186,     51,       49,      2, yes,  no,   0, no) \
+    SC(187,     51,       49,      3, yes,  no,   0, no) \
+    SC(188,     51,       49,      4, yes,  no,   0, no) \
+                                                         \
+    SC(189,     52,       50,      1, yes,  no,   0, no) \
+    SC(190,     52,       50,      2, yes,  no,   0, no) \
+    SC(191,     52,       50,      3, yes,  no,   0, no) \
+    SC(192,     52,       50,      4, yes,  no,   0, no) \
+                                                         \
+    SC(193,     53,       51,      1, yes,  no,   0, no) \
+    SC(194,     53,       51,      2, yes,  no,   0, no) \
+    SC(195,     53,       51,      3, yes,  no,   0, no) \
+    SC(196,     53,       51,      4, yes,  no,   0, no) \
+                                                         \
+    SC(197,     54,       52,      1, yes,  no,   0, no) \
+    SC(198,     54,       52,      2, yes,  no,   0, no) \
+    SC(199,     54,       52,      3, yes,  no,   0, no) \
+    SC(200,     54,       52,      4, yes,  no,   0, no) \
+                                                         \
+    SC(201,     55,       53,      1, yes,  no,   0, no) \
+    SC(202,     55,       53,      2, yes,  no,   0, no) \
+    SC(203,     55,       53,      3, yes,  no,   0, no) \
+    SC(204,     55,       53,      4, yes,  no,   0, no) \
+                                                         \
+    SC(205,     56,       54,      1, yes,  no,   0, no) \
+    SC(206,     56,       54,      2, yes,  no,   0, no) \
+    SC(207,     56,       54,      3, yes,  no,   0, no) \
+    SC(208,     56,       54,      4, yes,  no,   0, no) \
+                                                         \
+    SC(209,     57,       55,      1, yes,  no,   0, no) \
+    SC(210,     57,       55,      2, yes,  no,   0, no) \
+    SC(211,     57,       55,      3, yes,  no,   0, no) \
+    SC(212,     57,       55,      4, yes,  no,   0, no) \
+                                                         \
+    SC(213,     58,       56,      1, yes,  no,   0, no) \
+    SC(214,     58,       56,      2, yes,  no,   0, no) \
+    SC(215,     58,       56,      3, yes,  no,   0, no) \
+    SC(216,     58,       56,      4, yes,  no,   0, no) \
+                                                         \
+    SC(217,     59,       57,      1, yes,  no,   0, no) \
+    SC(218,     59,       57,      2, yes,  no,   0, no) \
+    SC(219,     59,       57,      3, yes,  no,   0, no) \
+    SC(220,     59,       57,      4, yes,  no,   0, no) \
+                                                         \
+    SC(221,     60,       58,      1, yes,  no,   0, no) \
+    SC(222,     60,       58,      2, yes,  no,   0, no) \
+    SC(223,     60,       58,      3, yes,  no,   0, no) \
+    SC(224,     60,       58,      4, yes,  no,   0, no) \
+                                                         \
+    SC(225,     61,       59,      1, yes,  no,   0, no) \
+    SC(226,     61,       59,      2, yes,  no,   0, no) \
+    SC(227,     61,       59,      3, yes,  no,   0, no) \
+    SC(228,     61,       59,      4, yes,  no,   0, no) \
+                                                         \
+    SC(229,     62,       60,      1, yes,  no,   0, no) \
+    SC(230,     62,       60,      2, yes,  no,   0, no) \
+    SC(231,     62,       60,      3, yes,  no,   0, no) \
+
+#define SIZE_CLASSES_DEFINED
+#define NTBINS			1
+#define NLBINS			29
+#define NBINS			36
+#define NSIZES			232
+#define LG_CEIL_NSIZES		8
+#define NPSIZES			199
+#define LG_TINY_MAXCLASS	3
+#define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
+#define LG_LARGE_MINCLASS	14
+#define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
+#define LARGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 3 && LG_QUANTUM == 4 && LG_PAGE == 14)
+#define SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
+    SC(  0,      3,        3,      0,  no, yes,   1,  3) \
+                                                         \
+    SC(  1,      3,        3,      1,  no, yes,   1,  3) \
+    SC(  2,      4,        4,      1,  no, yes,   1,  4) \
+    SC(  3,      4,        4,      2,  no, yes,   3,  4) \
+    SC(  4,      4,        4,      3,  no, yes,   1,  4) \
+                                                         \
+    SC(  5,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  6,      6,        4,      2,  no, yes,   3,  4) \
+    SC(  7,      6,        4,      3,  no, yes,   7,  4) \
+    SC(  8,      6,        4,      4,  no, yes,   1,  4) \
+                                                         \
+    SC(  9,      7,        5,      1,  no, yes,   5,  5) \
+    SC( 10,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 11,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 12,      7,        5,      4,  no, yes,   1,  5) \
+                                                         \
+    SC( 13,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 14,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 15,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 16,      8,        6,      4,  no, yes,   1,  6) \
+                                                         \
+    SC( 17,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 18,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 19,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 20,      9,        7,      4,  no, yes,   1,  7) \
+                                                         \
+    SC( 21,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 22,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 23,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 24,     10,        8,      4,  no, yes,   1,  8) \
+                                                         \
+    SC( 25,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 26,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 27,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 28,     11,        9,      4,  no, yes,   1,  9) \
+                                                         \
+    SC( 29,     12,       10,      1,  no, yes,   5, no) \
+    SC( 30,     12,       10,      2,  no, yes,   3, no) \
+    SC( 31,     12,       10,      3,  no, yes,   7, no) \
+    SC( 32,     12,       10,      4,  no, yes,   1, no) \
+                                                         \
+    SC( 33,     13,       11,      1,  no, yes,   5, no) \
+    SC( 34,     13,       11,      2,  no, yes,   3, no) \
+    SC( 35,     13,       11,      3,  no, yes,   7, no) \
+    SC( 36,     13,       11,      4, yes, yes,   1, no) \
+                                                         \
+    SC( 37,     14,       12,      1,  no, yes,   5, no) \
+    SC( 38,     14,       12,      2,  no, yes,   3, no) \
+    SC( 39,     14,       12,      3,  no, yes,   7, no) \
+    SC( 40,     14,       12,      4, yes, yes,   2, no) \
+                                                         \
+    SC( 41,     15,       13,      1,  no, yes,   5, no) \
+    SC( 42,     15,       13,      2, yes, yes,   3, no) \
+    SC( 43,     15,       13,      3,  no, yes,   7, no) \
+    SC( 44,     15,       13,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 45,     16,       14,      1, yes,  no,   0, no) \
+    SC( 46,     16,       14,      2, yes,  no,   0, no) \
+    SC( 47,     16,       14,      3, yes,  no,   0, no) \
+    SC( 48,     16,       14,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 49,     17,       15,      1, yes,  no,   0, no) \
+    SC( 50,     17,       15,      2, yes,  no,   0, no) \
+    SC( 51,     17,       15,      3, yes,  no,   0, no) \
+    SC( 52,     17,       15,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 53,     18,       16,      1, yes,  no,   0, no) \
+    SC( 54,     18,       16,      2, yes,  no,   0, no) \
+    SC( 55,     18,       16,      3, yes,  no,   0, no) \
+    SC( 56,     18,       16,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 57,     19,       17,      1, yes,  no,   0, no) \
+    SC( 58,     19,       17,      2, yes,  no,   0, no) \
+    SC( 59,     19,       17,      3, yes,  no,   0, no) \
+    SC( 60,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 61,     20,       18,      1, yes,  no,   0, no) \
+    SC( 62,     20,       18,      2, yes,  no,   0, no) \
+    SC( 63,     20,       18,      3, yes,  no,   0, no) \
+    SC( 64,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 65,     21,       19,      1, yes,  no,   0, no) \
+    SC( 66,     21,       19,      2, yes,  no,   0, no) \
+    SC( 67,     21,       19,      3, yes,  no,   0, no) \
+    SC( 68,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 69,     22,       20,      1, yes,  no,   0, no) \
+    SC( 70,     22,       20,      2, yes,  no,   0, no) \
+    SC( 71,     22,       20,      3, yes,  no,   0, no) \
+    SC( 72,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 73,     23,       21,      1, yes,  no,   0, no) \
+    SC( 74,     23,       21,      2, yes,  no,   0, no) \
+    SC( 75,     23,       21,      3, yes,  no,   0, no) \
+    SC( 76,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 77,     24,       22,      1, yes,  no,   0, no) \
+    SC( 78,     24,       22,      2, yes,  no,   0, no) \
+    SC( 79,     24,       22,      3, yes,  no,   0, no) \
+    SC( 80,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 81,     25,       23,      1, yes,  no,   0, no) \
+    SC( 82,     25,       23,      2, yes,  no,   0, no) \
+    SC( 83,     25,       23,      3, yes,  no,   0, no) \
+    SC( 84,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 85,     26,       24,      1, yes,  no,   0, no) \
+    SC( 86,     26,       24,      2, yes,  no,   0, no) \
+    SC( 87,     26,       24,      3, yes,  no,   0, no) \
+    SC( 88,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 89,     27,       25,      1, yes,  no,   0, no) \
+    SC( 90,     27,       25,      2, yes,  no,   0, no) \
+    SC( 91,     27,       25,      3, yes,  no,   0, no) \
+    SC( 92,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 93,     28,       26,      1, yes,  no,   0, no) \
+    SC( 94,     28,       26,      2, yes,  no,   0, no) \
+    SC( 95,     28,       26,      3, yes,  no,   0, no) \
+    SC( 96,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 97,     29,       27,      1, yes,  no,   0, no) \
+    SC( 98,     29,       27,      2, yes,  no,   0, no) \
+    SC( 99,     29,       27,      3, yes,  no,   0, no) \
+    SC(100,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(101,     30,       28,      1, yes,  no,   0, no) \
+    SC(102,     30,       28,      2, yes,  no,   0, no) \
+    SC(103,     30,       28,      3, yes,  no,   0, no) \
+    SC(104,     30,       28,      4, yes,  no,   0, no) \
+                                                         \
+    SC(105,     31,       29,      1, yes,  no,   0, no) \
+    SC(106,     31,       29,      2, yes,  no,   0, no) \
+    SC(107,     31,       29,      3, yes,  no,   0, no) \
+    SC(108,     31,       29,      4, yes,  no,   0, no) \
+                                                         \
+    SC(109,     32,       30,      1, yes,  no,   0, no) \
+    SC(110,     32,       30,      2, yes,  no,   0, no) \
+    SC(111,     32,       30,      3, yes,  no,   0, no) \
+    SC(112,     32,       30,      4, yes,  no,   0, no) \
+                                                         \
+    SC(113,     33,       31,      1, yes,  no,   0, no) \
+    SC(114,     33,       31,      2, yes,  no,   0, no) \
+    SC(115,     33,       31,      3, yes,  no,   0, no) \
+    SC(116,     33,       31,      4, yes,  no,   0, no) \
+                                                         \
+    SC(117,     34,       32,      1, yes,  no,   0, no) \
+    SC(118,     34,       32,      2, yes,  no,   0, no) \
+    SC(119,     34,       32,      3, yes,  no,   0, no) \
+    SC(120,     34,       32,      4, yes,  no,   0, no) \
+                                                         \
+    SC(121,     35,       33,      1, yes,  no,   0, no) \
+    SC(122,     35,       33,      2, yes,  no,   0, no) \
+    SC(123,     35,       33,      3, yes,  no,   0, no) \
+    SC(124,     35,       33,      4, yes,  no,   0, no) \
+                                                         \
+    SC(125,     36,       34,      1, yes,  no,   0, no) \
+    SC(126,     36,       34,      2, yes,  no,   0, no) \
+    SC(127,     36,       34,      3, yes,  no,   0, no) \
+    SC(128,     36,       34,      4, yes,  no,   0, no) \
+                                                         \
+    SC(129,     37,       35,      1, yes,  no,   0, no) \
+    SC(130,     37,       35,      2, yes,  no,   0, no) \
+    SC(131,     37,       35,      3, yes,  no,   0, no) \
+    SC(132,     37,       35,      4, yes,  no,   0, no) \
+                                                         \
+    SC(133,     38,       36,      1, yes,  no,   0, no) \
+    SC(134,     38,       36,      2, yes,  no,   0, no) \
+    SC(135,     38,       36,      3, yes,  no,   0, no) \
+    SC(136,     38,       36,      4, yes,  no,   0, no) \
+                                                         \
+    SC(137,     39,       37,      1, yes,  no,   0, no) \
+    SC(138,     39,       37,      2, yes,  no,   0, no) \
+    SC(139,     39,       37,      3, yes,  no,   0, no) \
+    SC(140,     39,       37,      4, yes,  no,   0, no) \
+                                                         \
+    SC(141,     40,       38,      1, yes,  no,   0, no) \
+    SC(142,     40,       38,      2, yes,  no,   0, no) \
+    SC(143,     40,       38,      3, yes,  no,   0, no) \
+    SC(144,     40,       38,      4, yes,  no,   0, no) \
+                                                         \
+    SC(145,     41,       39,      1, yes,  no,   0, no) \
+    SC(146,     41,       39,      2, yes,  no,   0, no) \
+    SC(147,     41,       39,      3, yes,  no,   0, no) \
+    SC(148,     41,       39,      4, yes,  no,   0, no) \
+                                                         \
+    SC(149,     42,       40,      1, yes,  no,   0, no) \
+    SC(150,     42,       40,      2, yes,  no,   0, no) \
+    SC(151,     42,       40,      3, yes,  no,   0, no) \
+    SC(152,     42,       40,      4, yes,  no,   0, no) \
+                                                         \
+    SC(153,     43,       41,      1, yes,  no,   0, no) \
+    SC(154,     43,       41,      2, yes,  no,   0, no) \
+    SC(155,     43,       41,      3, yes,  no,   0, no) \
+    SC(156,     43,       41,      4, yes,  no,   0, no) \
+                                                         \
+    SC(157,     44,       42,      1, yes,  no,   0, no) \
+    SC(158,     44,       42,      2, yes,  no,   0, no) \
+    SC(159,     44,       42,      3, yes,  no,   0, no) \
+    SC(160,     44,       42,      4, yes,  no,   0, no) \
+                                                         \
+    SC(161,     45,       43,      1, yes,  no,   0, no) \
+    SC(162,     45,       43,      2, yes,  no,   0, no) \
+    SC(163,     45,       43,      3, yes,  no,   0, no) \
+    SC(164,     45,       43,      4, yes,  no,   0, no) \
+                                                         \
+    SC(165,     46,       44,      1, yes,  no,   0, no) \
+    SC(166,     46,       44,      2, yes,  no,   0, no) \
+    SC(167,     46,       44,      3, yes,  no,   0, no) \
+    SC(168,     46,       44,      4, yes,  no,   0, no) \
+                                                         \
+    SC(169,     47,       45,      1, yes,  no,   0, no) \
+    SC(170,     47,       45,      2, yes,  no,   0, no) \
+    SC(171,     47,       45,      3, yes,  no,   0, no) \
+    SC(172,     47,       45,      4, yes,  no,   0, no) \
+                                                         \
+    SC(173,     48,       46,      1, yes,  no,   0, no) \
+    SC(174,     48,       46,      2, yes,  no,   0, no) \
+    SC(175,     48,       46,      3, yes,  no,   0, no) \
+    SC(176,     48,       46,      4, yes,  no,   0, no) \
+                                                         \
+    SC(177,     49,       47,      1, yes,  no,   0, no) \
+    SC(178,     49,       47,      2, yes,  no,   0, no) \
+    SC(179,     49,       47,      3, yes,  no,   0, no) \
+    SC(180,     49,       47,      4, yes,  no,   0, no) \
+                                                         \
+    SC(181,     50,       48,      1, yes,  no,   0, no) \
+    SC(182,     50,       48,      2, yes,  no,   0, no) \
+    SC(183,     50,       48,      3, yes,  no,   0, no) \
+    SC(184,     50,       48,      4, yes,  no,   0, no) \
+                                                         \
+    SC(185,     51,       49,      1, yes,  no,   0, no) \
+    SC(186,     51,       49,      2, yes,  no,   0, no) \
+    SC(187,     51,       49,      3, yes,  no,   0, no) \
+    SC(188,     51,       49,      4, yes,  no,   0, no) \
                                                          \
-    SC( 65,     21,       19,      1, yes,  no,   0, no) \
-    SC( 66,     21,       19,      2, yes,  no,   0, no) \
-    SC( 67,     21,       19,      3, yes,  no,   0, no) \
-    SC( 68,     21,       19,      4, yes,  no,   0, no) \
+    SC(189,     52,       50,      1, yes,  no,   0, no) \
+    SC(190,     52,       50,      2, yes,  no,   0, no) \
+    SC(191,     52,       50,      3, yes,  no,   0, no) \
+    SC(192,     52,       50,      4, yes,  no,   0, no) \
                                                          \
-    SC( 69,     22,       20,      1, yes,  no,   0, no) \
-    SC( 70,     22,       20,      2, yes,  no,   0, no) \
-    SC( 71,     22,       20,      3, yes,  no,   0, no) \
-    SC( 72,     22,       20,      4, yes,  no,   0, no) \
+    SC(193,     53,       51,      1, yes,  no,   0, no) \
+    SC(194,     53,       51,      2, yes,  no,   0, no) \
+    SC(195,     53,       51,      3, yes,  no,   0, no) \
+    SC(196,     53,       51,      4, yes,  no,   0, no) \
                                                          \
-    SC( 73,     23,       21,      1, yes,  no,   0, no) \
-    SC( 74,     23,       21,      2, yes,  no,   0, no) \
-    SC( 75,     23,       21,      3, yes,  no,   0, no) \
-    SC( 76,     23,       21,      4, yes,  no,   0, no) \
+    SC(197,     54,       52,      1, yes,  no,   0, no) \
+    SC(198,     54,       52,      2, yes,  no,   0, no) \
+    SC(199,     54,       52,      3, yes,  no,   0, no) \
+    SC(200,     54,       52,      4, yes,  no,   0, no) \
                                                          \
-    SC( 77,     24,       22,      1, yes,  no,   0, no) \
-    SC( 78,     24,       22,      2, yes,  no,   0, no) \
-    SC( 79,     24,       22,      3, yes,  no,   0, no) \
-    SC( 80,     24,       22,      4, yes,  no,   0, no) \
+    SC(201,     55,       53,      1, yes,  no,   0, no) \
+    SC(202,     55,       53,      2, yes,  no,   0, no) \
+    SC(203,     55,       53,      3, yes,  no,   0, no) \
+    SC(204,     55,       53,      4, yes,  no,   0, no) \
                                                          \
-    SC( 81,     25,       23,      1, yes,  no,   0, no) \
-    SC( 82,     25,       23,      2, yes,  no,   0, no) \
-    SC( 83,     25,       23,      3, yes,  no,   0, no) \
-    SC( 84,     25,       23,      4, yes,  no,   0, no) \
+    SC(205,     56,       54,      1, yes,  no,   0, no) \
+    SC(206,     56,       54,      2, yes,  no,   0, no) \
+    SC(207,     56,       54,      3, yes,  no,   0, no) \
+    SC(208,     56,       54,      4, yes,  no,   0, no) \
                                                          \
-    SC( 85,     26,       24,      1, yes,  no,   0, no) \
-    SC( 86,     26,       24,      2, yes,  no,   0, no) \
-    SC( 87,     26,       24,      3, yes,  no,   0, no) \
-    SC( 88,     26,       24,      4, yes,  no,   0, no) \
+    SC(209,     57,       55,      1, yes,  no,   0, no) \
+    SC(210,     57,       55,      2, yes,  no,   0, no) \
+    SC(211,     57,       55,      3, yes,  no,   0, no) \
+    SC(212,     57,       55,      4, yes,  no,   0, no) \
                                                          \
-    SC( 89,     27,       25,      1, yes,  no,   0, no) \
-    SC( 90,     27,       25,      2, yes,  no,   0, no) \
-    SC( 91,     27,       25,      3, yes,  no,   0, no) \
-    SC( 92,     27,       25,      4, yes,  no,   0, no) \
+    SC(213,     58,       56,      1, yes,  no,   0, no) \
+    SC(214,     58,       56,      2, yes,  no,   0, no) \
+    SC(215,     58,       56,      3, yes,  no,   0, no) \
+    SC(216,     58,       56,      4, yes,  no,   0, no) \
                                                          \
-    SC( 93,     28,       26,      1, yes,  no,   0, no) \
-    SC( 94,     28,       26,      2, yes,  no,   0, no) \
-    SC( 95,     28,       26,      3, yes,  no,   0, no) \
-    SC( 96,     28,       26,      4, yes,  no,   0, no) \
+    SC(217,     59,       57,      1, yes,  no,   0, no) \
+    SC(218,     59,       57,      2, yes,  no,   0, no) \
+    SC(219,     59,       57,      3, yes,  no,   0, no) \
+    SC(220,     59,       57,      4, yes,  no,   0, no) \
                                                          \
-    SC( 97,     29,       27,      1, yes,  no,   0, no) \
-    SC( 98,     29,       27,      2, yes,  no,   0, no) \
-    SC( 99,     29,       27,      3, yes,  no,   0, no) \
-    SC(100,     29,       27,      4, yes,  no,   0, no) \
+    SC(221,     60,       58,      1, yes,  no,   0, no) \
+    SC(222,     60,       58,      2, yes,  no,   0, no) \
+    SC(223,     60,       58,      3, yes,  no,   0, no) \
+    SC(224,     60,       58,      4, yes,  no,   0, no) \
                                                          \
-    SC(101,     30,       28,      1, yes,  no,   0, no) \
-    SC(102,     30,       28,      2, yes,  no,   0, no) \
-    SC(103,     30,       28,      3, yes,  no,   0, no) \
-    SC(104,     30,       28,      4, yes,  no,   0, no) \
+    SC(225,     61,       59,      1, yes,  no,   0, no) \
+    SC(226,     61,       59,      2, yes,  no,   0, no) \
+    SC(227,     61,       59,      3, yes,  no,   0, no) \
+    SC(228,     61,       59,      4, yes,  no,   0, no) \
                                                          \
-    SC(105,     31,       29,      1, yes,  no,   0, no) \
-    SC(106,     31,       29,      2, yes,  no,   0, no) \
-    SC(107,     31,       29,      3, yes,  no,   0, no) \
-    SC(108,     31,       29,      4, yes,  no,   0, no) \
+    SC(229,     62,       60,      1, yes,  no,   0, no) \
+    SC(230,     62,       60,      2, yes,  no,   0, no) \
+    SC(231,     62,       60,      3, yes,  no,   0, no) \
+
+#define SIZE_CLASSES_DEFINED
+#define NTBINS			1
+#define NLBINS			29
+#define NBINS			44
+#define NSIZES			232
+#define LG_CEIL_NSIZES		8
+#define NPSIZES			191
+#define LG_TINY_MAXCLASS	3
+#define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
+#define SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define LG_LARGE_MINCLASS	16
+#define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
+#define LARGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
+#endif
+
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#define SIZE_CLASSES \
+  /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
+    SC(  0,      4,        4,      0,  no, yes,   1,  4) \
+    SC(  1,      4,        4,      1,  no, yes,   1,  4) \
+    SC(  2,      4,        4,      2,  no, yes,   3,  4) \
+    SC(  3,      4,        4,      3,  no, yes,   1,  4) \
                                                          \
-    SC(109,     32,       30,      1, yes,  no,   0, no) \
-    SC(110,     32,       30,      2, yes,  no,   0, no) \
-    SC(111,     32,       30,      3, yes,  no,   0, no) \
-    SC(112,     32,       30,      4, yes,  no,   0, no) \
+    SC(  4,      6,        4,      1,  no, yes,   5,  4) \
+    SC(  5,      6,        4,      2,  no, yes,   3,  4) \
+    SC(  6,      6,        4,      3,  no, yes,   7,  4) \
+    SC(  7,      6,        4,      4,  no, yes,   1,  4) \
                                                          \
-    SC(113,     33,       31,      1, yes,  no,   0, no) \
-    SC(114,     33,       31,      2, yes,  no,   0, no) \
-    SC(115,     33,       31,      3, yes,  no,   0, no) \
-    SC(116,     33,       31,      4, yes,  no,   0, no) \
+    SC(  8,      7,        5,      1,  no, yes,   5,  5) \
+    SC(  9,      7,        5,      2,  no, yes,   3,  5) \
+    SC( 10,      7,        5,      3,  no, yes,   7,  5) \
+    SC( 11,      7,        5,      4,  no, yes,   1,  5) \
+                                                         \
+    SC( 12,      8,        6,      1,  no, yes,   5,  6) \
+    SC( 13,      8,        6,      2,  no, yes,   3,  6) \
+    SC( 14,      8,        6,      3,  no, yes,   7,  6) \
+    SC( 15,      8,        6,      4,  no, yes,   1,  6) \
+                                                         \
+    SC( 16,      9,        7,      1,  no, yes,   5,  7) \
+    SC( 17,      9,        7,      2,  no, yes,   3,  7) \
+    SC( 18,      9,        7,      3,  no, yes,   7,  7) \
+    SC( 19,      9,        7,      4,  no, yes,   1,  7) \
+                                                         \
+    SC( 20,     10,        8,      1,  no, yes,   5,  8) \
+    SC( 21,     10,        8,      2,  no, yes,   3,  8) \
+    SC( 22,     10,        8,      3,  no, yes,   7,  8) \
+    SC( 23,     10,        8,      4,  no, yes,   1,  8) \
+                                                         \
+    SC( 24,     11,        9,      1,  no, yes,   5,  9) \
+    SC( 25,     11,        9,      2,  no, yes,   3,  9) \
+    SC( 26,     11,        9,      3,  no, yes,   7,  9) \
+    SC( 27,     11,        9,      4, yes, yes,   1,  9) \
+                                                         \
+    SC( 28,     12,       10,      1,  no, yes,   5, no) \
+    SC( 29,     12,       10,      2,  no, yes,   3, no) \
+    SC( 30,     12,       10,      3,  no, yes,   7, no) \
+    SC( 31,     12,       10,      4, yes, yes,   2, no) \
+                                                         \
+    SC( 32,     13,       11,      1,  no, yes,   5, no) \
+    SC( 33,     13,       11,      2, yes, yes,   3, no) \
+    SC( 34,     13,       11,      3,  no, yes,   7, no) \
+    SC( 35,     13,       11,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 36,     14,       12,      1, yes,  no,   0, no) \
+    SC( 37,     14,       12,      2, yes,  no,   0, no) \
+    SC( 38,     14,       12,      3, yes,  no,   0, no) \
+    SC( 39,     14,       12,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 40,     15,       13,      1, yes,  no,   0, no) \
+    SC( 41,     15,       13,      2, yes,  no,   0, no) \
+    SC( 42,     15,       13,      3, yes,  no,   0, no) \
+    SC( 43,     15,       13,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 44,     16,       14,      1, yes,  no,   0, no) \
+    SC( 45,     16,       14,      2, yes,  no,   0, no) \
+    SC( 46,     16,       14,      3, yes,  no,   0, no) \
+    SC( 47,     16,       14,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 48,     17,       15,      1, yes,  no,   0, no) \
+    SC( 49,     17,       15,      2, yes,  no,   0, no) \
+    SC( 50,     17,       15,      3, yes,  no,   0, no) \
+    SC( 51,     17,       15,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 52,     18,       16,      1, yes,  no,   0, no) \
+    SC( 53,     18,       16,      2, yes,  no,   0, no) \
+    SC( 54,     18,       16,      3, yes,  no,   0, no) \
+    SC( 55,     18,       16,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 56,     19,       17,      1, yes,  no,   0, no) \
+    SC( 57,     19,       17,      2, yes,  no,   0, no) \
+    SC( 58,     19,       17,      3, yes,  no,   0, no) \
+    SC( 59,     19,       17,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 60,     20,       18,      1, yes,  no,   0, no) \
+    SC( 61,     20,       18,      2, yes,  no,   0, no) \
+    SC( 62,     20,       18,      3, yes,  no,   0, no) \
+    SC( 63,     20,       18,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 64,     21,       19,      1, yes,  no,   0, no) \
+    SC( 65,     21,       19,      2, yes,  no,   0, no) \
+    SC( 66,     21,       19,      3, yes,  no,   0, no) \
+    SC( 67,     21,       19,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 68,     22,       20,      1, yes,  no,   0, no) \
+    SC( 69,     22,       20,      2, yes,  no,   0, no) \
+    SC( 70,     22,       20,      3, yes,  no,   0, no) \
+    SC( 71,     22,       20,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 72,     23,       21,      1, yes,  no,   0, no) \
+    SC( 73,     23,       21,      2, yes,  no,   0, no) \
+    SC( 74,     23,       21,      3, yes,  no,   0, no) \
+    SC( 75,     23,       21,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 76,     24,       22,      1, yes,  no,   0, no) \
+    SC( 77,     24,       22,      2, yes,  no,   0, no) \
+    SC( 78,     24,       22,      3, yes,  no,   0, no) \
+    SC( 79,     24,       22,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 80,     25,       23,      1, yes,  no,   0, no) \
+    SC( 81,     25,       23,      2, yes,  no,   0, no) \
+    SC( 82,     25,       23,      3, yes,  no,   0, no) \
+    SC( 83,     25,       23,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 84,     26,       24,      1, yes,  no,   0, no) \
+    SC( 85,     26,       24,      2, yes,  no,   0, no) \
+    SC( 86,     26,       24,      3, yes,  no,   0, no) \
+    SC( 87,     26,       24,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 88,     27,       25,      1, yes,  no,   0, no) \
+    SC( 89,     27,       25,      2, yes,  no,   0, no) \
+    SC( 90,     27,       25,      3, yes,  no,   0, no) \
+    SC( 91,     27,       25,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 92,     28,       26,      1, yes,  no,   0, no) \
+    SC( 93,     28,       26,      2, yes,  no,   0, no) \
+    SC( 94,     28,       26,      3, yes,  no,   0, no) \
+    SC( 95,     28,       26,      4, yes,  no,   0, no) \
+                                                         \
+    SC( 96,     29,       27,      1, yes,  no,   0, no) \
+    SC( 97,     29,       27,      2, yes,  no,   0, no) \
+    SC( 98,     29,       27,      3, yes,  no,   0, no) \
+    SC( 99,     29,       27,      4, yes,  no,   0, no) \
+                                                         \
+    SC(100,     30,       28,      1, yes,  no,   0, no) \
+    SC(101,     30,       28,      2, yes,  no,   0, no) \
+    SC(102,     30,       28,      3, yes,  no,   0, no) \
+    SC(103,     30,       28,      4, yes,  no,   0, no) \
+                                                         \
+    SC(104,     31,       29,      1, yes,  no,   0, no) \
+    SC(105,     31,       29,      2, yes,  no,   0, no) \
+    SC(106,     31,       29,      3, yes,  no,   0, no) \
+    SC(107,     31,       29,      4, yes,  no,   0, no) \
+                                                         \
+    SC(108,     32,       30,      1, yes,  no,   0, no) \
+    SC(109,     32,       30,      2, yes,  no,   0, no) \
+    SC(110,     32,       30,      3, yes,  no,   0, no) \
+    SC(111,     32,       30,      4, yes,  no,   0, no) \
+                                                         \
+    SC(112,     33,       31,      1, yes,  no,   0, no) \
+    SC(113,     33,       31,      2, yes,  no,   0, no) \
+    SC(114,     33,       31,      3, yes,  no,   0, no) \
+    SC(115,     33,       31,      4, yes,  no,   0, no) \
                                                          \
-    SC(117,     34,       32,      1, yes,  no,   0, no) \
-    SC(118,     34,       32,      2, yes,  no,   0, no) \
-    SC(119,     34,       32,      3, yes,  no,   0, no) \
-    SC(120,     34,       32,      4, yes,  no,   0, no) \
+    SC(116,     34,       32,      1, yes,  no,   0, no) \
+    SC(117,     34,       32,      2, yes,  no,   0, no) \
+    SC(118,     34,       32,      3, yes,  no,   0, no) \
+    SC(119,     34,       32,      4, yes,  no,   0, no) \
                                                          \
-    SC(121,     35,       33,      1, yes,  no,   0, no) \
-    SC(122,     35,       33,      2, yes,  no,   0, no) \
-    SC(123,     35,       33,      3, yes,  no,   0, no) \
-    SC(124,     35,       33,      4, yes,  no,   0, no) \
+    SC(120,     35,       33,      1, yes,  no,   0, no) \
+    SC(121,     35,       33,      2, yes,  no,   0, no) \
+    SC(122,     35,       33,      3, yes,  no,   0, no) \
+    SC(123,     35,       33,      4, yes,  no,   0, no) \
                                                          \
-    SC(125,     36,       34,      1, yes,  no,   0, no) \
-    SC(126,     36,       34,      2, yes,  no,   0, no) \
-    SC(127,     36,       34,      3, yes,  no,   0, no) \
-    SC(128,     36,       34,      4, yes,  no,   0, no) \
+    SC(124,     36,       34,      1, yes,  no,   0, no) \
+    SC(125,     36,       34,      2, yes,  no,   0, no) \
+    SC(126,     36,       34,      3, yes,  no,   0, no) \
+    SC(127,     36,       34,      4, yes,  no,   0, no) \
                                                          \
-    SC(129,     37,       35,      1, yes,  no,   0, no) \
-    SC(130,     37,       35,      2, yes,  no,   0, no) \
-    SC(131,     37,       35,      3, yes,  no,   0, no) \
-    SC(132,     37,       35,      4, yes,  no,   0, no) \
+    SC(128,     37,       35,      1, yes,  no,   0, no) \
+    SC(129,     37,       35,      2, yes,  no,   0, no) \
+    SC(130,     37,       35,      3, yes,  no,   0, no) \
+    SC(131,     37,       35,      4, yes,  no,   0, no) \
                                                          \
-    SC(133,     38,       36,      1, yes,  no,   0, no) \
-    SC(134,     38,       36,      2, yes,  no,   0, no) \
-    SC(135,     38,       36,      3, yes,  no,   0, no) \
-    SC(136,     38,       36,      4, yes,  no,   0, no) \
+    SC(132,     38,       36,      1, yes,  no,   0, no) \
+    SC(133,     38,       36,      2, yes,  no,   0, no) \
+    SC(134,     38,       36,      3, yes,  no,   0, no) \
+    SC(135,     38,       36,      4, yes,  no,   0, no) \
                                                          \
-    SC(137,     39,       37,      1, yes,  no,   0, no) \
-    SC(138,     39,       37,      2, yes,  no,   0, no) \
-    SC(139,     39,       37,      3, yes,  no,   0, no) \
-    SC(140,     39,       37,      4, yes,  no,   0, no) \
+    SC(136,     39,       37,      1, yes,  no,   0, no) \
+    SC(137,     39,       37,      2, yes,  no,   0, no) \
+    SC(138,     39,       37,      3, yes,  no,   0, no) \
+    SC(139,     39,       37,      4, yes,  no,   0, no) \
                                                          \
-    SC(141,     40,       38,      1, yes,  no,   0, no) \
-    SC(142,     40,       38,      2, yes,  no,   0, no) \
-    SC(143,     40,       38,      3, yes,  no,   0, no) \
-    SC(144,     40,       38,      4, yes,  no,   0, no) \
+    SC(140,     40,       38,      1, yes,  no,   0, no) \
+    SC(141,     40,       38,      2, yes,  no,   0, no) \
+    SC(142,     40,       38,      3, yes,  no,   0, no) \
+    SC(143,     40,       38,      4, yes,  no,   0, no) \
                                                          \
-    SC(145,     41,       39,      1, yes,  no,   0, no) \
-    SC(146,     41,       39,      2, yes,  no,   0, no) \
-    SC(147,     41,       39,      3, yes,  no,   0, no) \
-    SC(148,     41,       39,      4, yes,  no,   0, no) \
+    SC(144,     41,       39,      1, yes,  no,   0, no) \
+    SC(145,     41,       39,      2, yes,  no,   0, no) \
+    SC(146,     41,       39,      3, yes,  no,   0, no) \
+    SC(147,     41,       39,      4, yes,  no,   0, no) \
                                                          \
-    SC(149,     42,       40,      1, yes,  no,   0, no) \
-    SC(150,     42,       40,      2, yes,  no,   0, no) \
-    SC(151,     42,       40,      3, yes,  no,   0, no) \
-    SC(152,     42,       40,      4, yes,  no,   0, no) \
+    SC(148,     42,       40,      1, yes,  no,   0, no) \
+    SC(149,     42,       40,      2, yes,  no,   0, no) \
+    SC(150,     42,       40,      3, yes,  no,   0, no) \
+    SC(151,     42,       40,      4, yes,  no,   0, no) \
                                                          \
-    SC(153,     43,       41,      1, yes,  no,   0, no) \
-    SC(154,     43,       41,      2, yes,  no,   0, no) \
-    SC(155,     43,       41,      3, yes,  no,   0, no) \
-    SC(156,     43,       41,      4, yes,  no,   0, no) \
+    SC(152,     43,       41,      1, yes,  no,   0, no) \
+    SC(153,     43,       41,      2, yes,  no,   0, no) \
+    SC(154,     43,       41,      3, yes,  no,   0, no) \
+    SC(155,     43,       41,      4, yes,  no,   0, no) \
                                                          \
-    SC(157,     44,       42,      1, yes,  no,   0, no) \
-    SC(158,     44,       42,      2, yes,  no,   0, no) \
-    SC(159,     44,       42,      3, yes,  no,   0, no) \
-    SC(160,     44,       42,      4, yes,  no,   0, no) \
+    SC(156,     44,       42,      1, yes,  no,   0, no) \
+    SC(157,     44,       42,      2, yes,  no,   0, no) \
+    SC(158,     44,       42,      3, yes,  no,   0, no) \
+    SC(159,     44,       42,      4, yes,  no,   0, no) \
                                                          \
-    SC(161,     45,       43,      1, yes,  no,   0, no) \
-    SC(162,     45,       43,      2, yes,  no,   0, no) \
-    SC(163,     45,       43,      3, yes,  no,   0, no) \
-    SC(164,     45,       43,      4, yes,  no,   0, no) \
+    SC(160,     45,       43,      1, yes,  no,   0, no) \
+    SC(161,     45,       43,      2, yes,  no,   0, no) \
+    SC(162,     45,       43,      3, yes,  no,   0, no) \
+    SC(163,     45,       43,      4, yes,  no,   0, no) \
                                                          \
-    SC(165,     46,       44,      1, yes,  no,   0, no) \
-    SC(166,     46,       44,      2, yes,  no,   0, no) \
-    SC(167,     46,       44,      3, yes,  no,   0, no) \
-    SC(168,     46,       44,      4, yes,  no,   0, no) \
+    SC(164,     46,       44,      1, yes,  no,   0, no) \
+    SC(165,     46,       44,      2, yes,  no,   0, no) \
+    SC(166,     46,       44,      3, yes,  no,   0, no) \
+    SC(167,     46,       44,      4, yes,  no,   0, no) \
                                                          \
-    SC(169,     47,       45,      1, yes,  no,   0, no) \
-    SC(170,     47,       45,      2, yes,  no,   0, no) \
-    SC(171,     47,       45,      3, yes,  no,   0, no) \
-    SC(172,     47,       45,      4, yes,  no,   0, no) \
+    SC(168,     47,       45,      1, yes,  no,   0, no) \
+    SC(169,     47,       45,      2, yes,  no,   0, no) \
+    SC(170,     47,       45,      3, yes,  no,   0, no) \
+    SC(171,     47,       45,      4, yes,  no,   0, no) \
                                                          \
-    SC(173,     48,       46,      1, yes,  no,   0, no) \
-    SC(174,     48,       46,      2, yes,  no,   0, no) \
-    SC(175,     48,       46,      3, yes,  no,   0, no) \
-    SC(176,     48,       46,      4, yes,  no,   0, no) \
+    SC(172,     48,       46,      1, yes,  no,   0, no) \
+    SC(173,     48,       46,      2, yes,  no,   0, no) \
+    SC(174,     48,       46,      3, yes,  no,   0, no) \
+    SC(175,     48,       46,      4, yes,  no,   0, no) \
                                                          \
-    SC(177,     49,       47,      1, yes,  no,   0, no) \
-    SC(178,     49,       47,      2, yes,  no,   0, no) \
-    SC(179,     49,       47,      3, yes,  no,   0, no) \
-    SC(180,     49,       47,      4, yes,  no,   0, no) \
+    SC(176,     49,       47,      1, yes,  no,   0, no) \
+    SC(177,     49,       47,      2, yes,  no,   0, no) \
+    SC(178,     49,       47,      3, yes,  no,   0, no) \
+    SC(179,     49,       47,      4, yes,  no,   0, no) \
                                                          \
-    SC(181,     50,       48,      1, yes,  no,   0, no) \
-    SC(182,     50,       48,      2, yes,  no,   0, no) \
-    SC(183,     50,       48,      3, yes,  no,   0, no) \
-    SC(184,     50,       48,      4, yes,  no,   0, no) \
+    SC(180,     50,       48,      1, yes,  no,   0, no) \
+    SC(181,     50,       48,      2, yes,  no,   0, no) \
+    SC(182,     50,       48,      3, yes,  no,   0, no) \
+    SC(183,     50,       48,      4, yes,  no,   0, no) \
                                                          \
-    SC(185,     51,       49,      1, yes,  no,   0, no) \
-    SC(186,     51,       49,      2, yes,  no,   0, no) \
-    SC(187,     51,       49,      3, yes,  no,   0, no) \
-    SC(188,     51,       49,      4, yes,  no,   0, no) \
+    SC(184,     51,       49,      1, yes,  no,   0, no) \
+    SC(185,     51,       49,      2, yes,  no,   0, no) \
+    SC(186,     51,       49,      3, yes,  no,   0, no) \
+    SC(187,     51,       49,      4, yes,  no,   0, no) \
                                                          \
-    SC(189,     52,       50,      1, yes,  no,   0, no) \
-    SC(190,     52,       50,      2, yes,  no,   0, no) \
-    SC(191,     52,       50,      3, yes,  no,   0, no) \
-    SC(192,     52,       50,      4, yes,  no,   0, no) \
+    SC(188,     52,       50,      1, yes,  no,   0, no) \
+    SC(189,     52,       50,      2, yes,  no,   0, no) \
+    SC(190,     52,       50,      3, yes,  no,   0, no) \
+    SC(191,     52,       50,      4, yes,  no,   0, no) \
                                                          \
-    SC(193,     53,       51,      1, yes,  no,   0, no) \
-    SC(194,     53,       51,      2, yes,  no,   0, no) \
-    SC(195,     53,       51,      3, yes,  no,   0, no) \
-    SC(196,     53,       51,      4, yes,  no,   0, no) \
+    SC(192,     53,       51,      1, yes,  no,   0, no) \
+    SC(193,     53,       51,      2, yes,  no,   0, no) \
+    SC(194,     53,       51,      3, yes,  no,   0, no) \
+    SC(195,     53,       51,      4, yes,  no,   0, no) \
                                                          \
-    SC(197,     54,       52,      1, yes,  no,   0, no) \
-    SC(198,     54,       52,      2, yes,  no,   0, no) \
-    SC(199,     54,       52,      3, yes,  no,   0, no) \
-    SC(200,     54,       52,      4, yes,  no,   0, no) \
+    SC(196,     54,       52,      1, yes,  no,   0, no) \
+    SC(197,     54,       52,      2, yes,  no,   0, no) \
+    SC(198,     54,       52,      3, yes,  no,   0, no) \
+    SC(199,     54,       52,      4, yes,  no,   0, no) \
                                                          \
-    SC(201,     55,       53,      1, yes,  no,   0, no) \
-    SC(202,     55,       53,      2, yes,  no,   0, no) \
-    SC(203,     55,       53,      3, yes,  no,   0, no) \
-    SC(204,     55,       53,      4, yes,  no,   0, no) \
+    SC(200,     55,       53,      1, yes,  no,   0, no) \
+    SC(201,     55,       53,      2, yes,  no,   0, no) \
+    SC(202,     55,       53,      3, yes,  no,   0, no) \
+    SC(203,     55,       53,      4, yes,  no,   0, no) \
                                                          \
-    SC(205,     56,       54,      1, yes,  no,   0, no) \
-    SC(206,     56,       54,      2, yes,  no,   0, no) \
-    SC(207,     56,       54,      3, yes,  no,   0, no) \
-    SC(208,     56,       54,      4, yes,  no,   0, no) \
+    SC(204,     56,       54,      1, yes,  no,   0, no) \
+    SC(205,     56,       54,      2, yes,  no,   0, no) \
+    SC(206,     56,       54,      3, yes,  no,   0, no) \
+    SC(207,     56,       54,      4, yes,  no,   0, no) \
                                                          \
-    SC(209,     57,       55,      1, yes,  no,   0, no) \
-    SC(210,     57,       55,      2, yes,  no,   0, no) \
-    SC(211,     57,       55,      3, yes,  no,   0, no) \
-    SC(212,     57,       55,      4, yes,  no,   0, no) \
+    SC(208,     57,       55,      1, yes,  no,   0, no) \
+    SC(209,     57,       55,      2, yes,  no,   0, no) \
+    SC(210,     57,       55,      3, yes,  no,   0, no) \
+    SC(211,     57,       55,      4, yes,  no,   0, no) \
                                                          \
-    SC(213,     58,       56,      1, yes,  no,   0, no) \
-    SC(214,     58,       56,      2, yes,  no,   0, no) \
-    SC(215,     58,       56,      3, yes,  no,   0, no) \
-    SC(216,     58,       56,      4, yes,  no,   0, no) \
+    SC(212,     58,       56,      1, yes,  no,   0, no) \
+    SC(213,     58,       56,      2, yes,  no,   0, no) \
+    SC(214,     58,       56,      3, yes,  no,   0, no) \
+    SC(215,     58,       56,      4, yes,  no,   0, no) \
                                                          \
-    SC(217,     59,       57,      1, yes,  no,   0, no) \
-    SC(218,     59,       57,      2, yes,  no,   0, no) \
-    SC(219,     59,       57,      3, yes,  no,   0, no) \
-    SC(220,     59,       57,      4, yes,  no,   0, no) \
+    SC(216,     59,       57,      1, yes,  no,   0, no) \
+    SC(217,     59,       57,      2, yes,  no,   0, no) \
+    SC(218,     59,       57,      3, yes,  no,   0, no) \
+    SC(219,     59,       57,      4, yes,  no,   0, no) \
                                                          \
-    SC(221,     60,       58,      1, yes,  no,   0, no) \
-    SC(222,     60,       58,      2, yes,  no,   0, no) \
-    SC(223,     60,       58,      3, yes,  no,   0, no) \
-    SC(224,     60,       58,      4, yes,  no,   0, no) \
+    SC(220,     60,       58,      1, yes,  no,   0, no) \
+    SC(221,     60,       58,      2, yes,  no,   0, no) \
+    SC(222,     60,       58,      3, yes,  no,   0, no) \
+    SC(223,     60,       58,      4, yes,  no,   0, no) \
                                                          \
-    SC(225,     61,       59,      1, yes,  no,   0, no) \
-    SC(226,     61,       59,      2, yes,  no,   0, no) \
-    SC(227,     61,       59,      3, yes,  no,   0, no) \
-    SC(228,     61,       59,      4, yes,  no,   0, no) \
+    SC(224,     61,       59,      1, yes,  no,   0, no) \
+    SC(225,     61,       59,      2, yes,  no,   0, no) \
+    SC(226,     61,       59,      3, yes,  no,   0, no) \
+    SC(227,     61,       59,      4, yes,  no,   0, no) \
                                                          \
-    SC(229,     62,       60,      1, yes,  no,   0, no) \
-    SC(230,     62,       60,      2, yes,  no,   0, no) \
-    SC(231,     62,       60,      3, yes,  no,   0, no) \
+    SC(228,     62,       60,      1, yes,  no,   0, no) \
+    SC(229,     62,       60,      2, yes,  no,   0, no) \
+    SC(230,     62,       60,      3, yes,  no,   0, no) \
 
 #define SIZE_CLASSES_DEFINED
-#define NTBINS			1
-#define NLBINS			29
-#define NBINS			36
-#define NSIZES			232
+#define NTBINS			0
+#define NLBINS			28
+#define NBINS			35
+#define NSIZES			231
 #define LG_CEIL_NSIZES		8
 #define NPSIZES			199
-#define LG_TINY_MAXCLASS	3
+#define LG_TINY_MAXCLASS	"NA"
 #define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
 #define SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
 #define LG_LARGE_MINCLASS	14
@@ -1106,7 +2482,7 @@
 #define LARGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif
 
-#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 12)
+#if (LG_SIZEOF_PTR == 3 && LG_TINY_MIN == 4 && LG_QUANTUM == 4 && LG_PAGE == 14)
 #define SIZE_CLASSES \
   /* index, lg_grp, lg_delta, ndelta, psz, bin, pgs, lg_delta_lookup */ \
     SC(  0,      4,        4,      0,  no, yes,   1,  4) \
@@ -1142,26 +2518,26 @@
     SC( 24,     11,        9,      1,  no, yes,   5,  9) \
     SC( 25,     11,        9,      2,  no, yes,   3,  9) \
     SC( 26,     11,        9,      3,  no, yes,   7,  9) \
-    SC( 27,     11,        9,      4, yes, yes,   1,  9) \
+    SC( 27,     11,        9,      4,  no, yes,   1,  9) \
                                                          \
     SC( 28,     12,       10,      1,  no, yes,   5, no) \
     SC( 29,     12,       10,      2,  no, yes,   3, no) \
     SC( 30,     12,       10,      3,  no, yes,   7, no) \
-    SC( 31,     12,       10,      4, yes, yes,   2, no) \
+    SC( 31,     12,       10,      4,  no, yes,   1, no) \
                                                          \
     SC( 32,     13,       11,      1,  no, yes,   5, no) \
-    SC( 33,     13,       11,      2, yes, yes,   3, no) \
+    SC( 33,     13,       11,      2,  no, yes,   3, no) \
     SC( 34,     13,       11,      3,  no, yes,   7, no) \
-    SC( 35,     13,       11,      4, yes,  no,   0, no) \
+    SC( 35,     13,       11,      4, yes, yes,   1, no) \
                                                          \
-    SC( 36,     14,       12,      1, yes,  no,   0, no) \
-    SC( 37,     14,       12,      2, yes,  no,   0, no) \
-    SC( 38,     14,       12,      3, yes,  no,   0, no) \
-    SC( 39,     14,       12,      4, yes,  no,   0, no) \
+    SC( 36,     14,       12,      1,  no, yes,   5, no) \
+    SC( 37,     14,       12,      2,  no, yes,   3, no) \
+    SC( 38,     14,       12,      3,  no, yes,   7, no) \
+    SC( 39,     14,       12,      4, yes, yes,   2, no) \
                                                          \
-    SC( 40,     15,       13,      1, yes,  no,   0, no) \
-    SC( 41,     15,       13,      2, yes,  no,   0, no) \
-    SC( 42,     15,       13,      3, yes,  no,   0, no) \
+    SC( 40,     15,       13,      1,  no, yes,   5, no) \
+    SC( 41,     15,       13,      2, yes, yes,   3, no) \
+    SC( 42,     15,       13,      3,  no, yes,   7, no) \
     SC( 43,     15,       13,      4, yes,  no,   0, no) \
                                                          \
     SC( 44,     16,       14,      1, yes,  no,   0, no) \
@@ -1401,14 +2777,14 @@
 #define SIZE_CLASSES_DEFINED
 #define NTBINS			0
 #define NLBINS			28
-#define NBINS			35
+#define NBINS			43
 #define NSIZES			231
 #define LG_CEIL_NSIZES		8
-#define NPSIZES			199
+#define NPSIZES			191
 #define LG_TINY_MAXCLASS	"NA"
 #define LOOKUP_MAXCLASS		((((size_t)1) << 11) + (((size_t)4) << 9))
-#define SMALL_MAXCLASS		((((size_t)1) << 13) + (((size_t)3) << 11))
-#define LG_LARGE_MINCLASS	14
+#define SMALL_MAXCLASS		((((size_t)1) << 15) + (((size_t)3) << 13))
+#define LG_LARGE_MINCLASS	16
 #define LARGE_MINCLASS		(ZU(1) << LG_LARGE_MINCLASS)
 #define LARGE_MAXCLASS		((((size_t)1) << 62) + (((size_t)3) << 60))
 #endif

project external/kernel-headers/
diff --git a/external/kernel-headers/original/uapi/asm-generic/param.h b/external/kernel-headers/original/uapi/asm-generic/param.h
index baad02e..3b9ec5c 100644
--- a/external/kernel-headers/original/uapi/asm-generic/param.h
+++ b/external/kernel-headers/original/uapi/asm-generic/param.h
@@ -7,7 +7,7 @@
 #endif
 
 #ifndef EXEC_PAGESIZE
-#define EXEC_PAGESIZE	4096
+#define EXEC_PAGESIZE	0x4000
 #endif
 
 #ifndef NOGROUP

project external/perfetto/
diff --git a/external/perfetto/include/perfetto/base/utils.h b/external/perfetto/include/perfetto/base/utils.h
index 3669cb154..fd73f643f 100644
--- a/external/perfetto/include/perfetto/base/utils.h
+++ b/external/perfetto/include/perfetto/base/utils.h
@@ -88,7 +88,7 @@ constexpr uid_t kInvalidUid = static_cast<uid_t>(-1);
 constexpr pid_t kInvalidPid = static_cast<pid_t>(-1);
 #endif
 
-constexpr size_t kPageSize = 4096;
+constexpr size_t kPageSize = 16384;
 constexpr size_t kMaxCpus = 128;
 
 template <typename T>

project external/swiftshader/
diff --git a/external/swiftshader/src/OpenGL/libEGL/libEGL.cpp b/external/swiftshader/src/OpenGL/libEGL/libEGL.cpp
index 5c561b959..d0c3d2ecc 100644
--- a/external/swiftshader/src/OpenGL/libEGL/libEGL.cpp
+++ b/external/swiftshader/src/OpenGL/libEGL/libEGL.cpp
@@ -830,6 +830,9 @@ EGLContext CreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_cont
 					return error(EGL_BAD_ATTRIBUTE, EGL_NO_CONTEXT);
 				}
 				break;
+			case EGL_CONTEXT_PRIORITY_LEVEL_IMG:
+				// Can be freely ignored
+				break;
 			default:
 				return error(EGL_BAD_ATTRIBUTE, EGL_NO_CONTEXT);
 			}
diff --git a/external/swiftshader/third_party/LLVM/lib/Support/Unix/Process.inc b/external/swiftshader/third_party/LLVM/lib/Support/Unix/Process.inc
index 27aaa3991..597190b90 100644
--- a/external/swiftshader/third_party/LLVM/lib/Support/Unix/Process.inc
+++ b/external/swiftshader/third_party/LLVM/lib/Support/Unix/Process.inc
@@ -48,7 +48,7 @@ Process::GetPageSize()
   // On Cygwin, getpagesize() returns 64k but the page size for the purposes of
   // memory protection and mmap() is 4k.
   // See http://www.cygwin.com/ml/cygwin/2009-01/threads.html#00492
-  const int page_size = 0x1000;
+  const int page_size = 0x4000;
 #elif defined(HAVE_GETPAGESIZE)
   const int page_size = ::getpagesize();
 #elif defined(HAVE_SYSCONF)

project frameworks/av/
diff --git a/frameworks/av/camera/cameraserver/Android.bp b/frameworks/av/camera/cameraserver/Android.bp
index ecaba3ac1..94c7a40f8 100644
--- a/frameworks/av/camera/cameraserver/Android.bp
+++ b/frameworks/av/camera/cameraserver/Android.bp
@@ -33,7 +33,6 @@ cc_binary {
         "android.hardware.camera.device@3.2",
         "android.hardware.camera.device@3.4",
     ],
-    compile_multilib: "32",
     cflags: [
         "-Wall",
         "-Wextra",
diff --git a/frameworks/av/drm/drmserver/Android.bp b/frameworks/av/drm/drmserver/Android.bp
index c25a0a172..0c8c389cd 100644
--- a/frameworks/av/drm/drmserver/Android.bp
+++ b/frameworks/av/drm/drmserver/Android.bp
@@ -40,7 +40,5 @@ cc_binary {
         "-Werror",
     ],
 
-    compile_multilib: "32",
-
     init_rc: ["drmserver.rc"],
 }
diff --git a/frameworks/av/media/codec2/hidl/services/Android.bp b/frameworks/av/media/codec2/hidl/services/Android.bp
index 216525e90..e899e7104 100644
--- a/frameworks/av/media/codec2/hidl/services/Android.bp
+++ b/frameworks/av/media/codec2/hidl/services/Android.bp
@@ -29,11 +29,12 @@ cc_binary {
         arm: {
             required: ["codec2.vendor.base.policy"],
         },
+        arm64: {
+            required: ["codec2.vendor.base.policy"],
+        },
         x86: {
             required: ["codec2.vendor.base.policy"],
         },
     },
-
-    compile_multilib: "32",
 }
 
diff --git a/frameworks/av/media/codec2/hidl/services/seccomp_policy/codec2.software.base-arm64.policy b/frameworks/av/media/codec2/hidl/services/seccomp_policy/codec2.software.base-arm64.policy
new file mode 100644
index 000000000..3d540327b
--- /dev/null
+++ b/frameworks/av/media/codec2/hidl/services/seccomp_policy/codec2.software.base-arm64.policy
@@ -0,0 +1,72 @@
+# Copyright (C) 2018 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Organized by frequency of systemcall - in descending order for
+# best performance.
+futex: 1
+ioctl: 1
+write: 1
+prctl: 1
+clock_gettime: 1
+getpriority: 1
+read: 1
+close: 1
+writev: 1
+dup: 1
+ppoll: 1
+mmap: 1
+getrandom: 1
+
+# mremap: Ensure |flags| are (MREMAP_MAYMOVE | MREMAP_FIXED) TODO: Once minijail
+# parser support for '<' is in this needs to be modified to also prevent
+# |old_address| and |new_address| from touching the exception vector page, which
+# on ARM is statically loaded at 0xffff 0000. See
+# http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0211h/Babfeega.html
+# for more details.
+mremap: arg3 == 3
+munmap: 1
+mprotect: 1
+madvise: 1
+openat: 1
+sigaltstack: 1
+clone: 1
+setpriority: 1
+getuid: 1
+fstat: 1
+fstatfs: 1
+pread64: 1
+faccessat: 1
+readlinkat: 1
+exit: 1
+rt_sigprocmask: 1
+set_tid_address: 1
+restart_syscall: 1
+exit_group: 1
+rt_sigreturn: 1
+pipe2: 1
+gettimeofday: 1
+sched_yield: 1
+nanosleep: 1
+lseek: 1
+sched_get_priority_max: 1
+sched_get_priority_min: 1
+statfs: 1
+sched_setscheduler: 1
+newfstatat: 1
+ugetrlimit: 1
+getdents64: 1
+getrandom: 1
+
+@include /system/etc/seccomp_policy/crash_dump.arm.policy
+
diff --git a/frameworks/av/media/codec2/hidl/services/seccomp_policy/codec2.vendor.base-arm64.policy b/frameworks/av/media/codec2/hidl/services/seccomp_policy/codec2.vendor.base-arm64.policy
new file mode 100644
index 000000000..3d540327b
--- /dev/null
+++ b/frameworks/av/media/codec2/hidl/services/seccomp_policy/codec2.vendor.base-arm64.policy
@@ -0,0 +1,72 @@
+# Copyright (C) 2018 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Organized by frequency of systemcall - in descending order for
+# best performance.
+futex: 1
+ioctl: 1
+write: 1
+prctl: 1
+clock_gettime: 1
+getpriority: 1
+read: 1
+close: 1
+writev: 1
+dup: 1
+ppoll: 1
+mmap: 1
+getrandom: 1
+
+# mremap: Ensure |flags| are (MREMAP_MAYMOVE | MREMAP_FIXED) TODO: Once minijail
+# parser support for '<' is in this needs to be modified to also prevent
+# |old_address| and |new_address| from touching the exception vector page, which
+# on ARM is statically loaded at 0xffff 0000. See
+# http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0211h/Babfeega.html
+# for more details.
+mremap: arg3 == 3
+munmap: 1
+mprotect: 1
+madvise: 1
+openat: 1
+sigaltstack: 1
+clone: 1
+setpriority: 1
+getuid: 1
+fstat: 1
+fstatfs: 1
+pread64: 1
+faccessat: 1
+readlinkat: 1
+exit: 1
+rt_sigprocmask: 1
+set_tid_address: 1
+restart_syscall: 1
+exit_group: 1
+rt_sigreturn: 1
+pipe2: 1
+gettimeofday: 1
+sched_yield: 1
+nanosleep: 1
+lseek: 1
+sched_get_priority_max: 1
+sched_get_priority_min: 1
+statfs: 1
+sched_setscheduler: 1
+newfstatat: 1
+ugetrlimit: 1
+getdents64: 1
+getrandom: 1
+
+@include /system/etc/seccomp_policy/crash_dump.arm.policy
+
diff --git a/frameworks/av/media/libeffects/factory/Android.bp b/frameworks/av/media/libeffects/factory/Android.bp
index ddbfdd8c5..fbbb68f99 100644
--- a/frameworks/av/media/libeffects/factory/Android.bp
+++ b/frameworks/av/media/libeffects/factory/Android.bp
@@ -39,8 +39,6 @@ cc_binary {
     vendor: true,
     srcs: ["test/DumpConfig.cpp"],
 
-    compile_multilib: "32",
-
     cflags: [
         "-Wall",
         "-Wextra",
diff --git a/frameworks/av/media/libmedia/MediaUtils.cpp b/frameworks/av/media/libmedia/MediaUtils.cpp
index 31972faca..20444c95a 100644
--- a/frameworks/av/media/libmedia/MediaUtils.cpp
+++ b/frameworks/av/media/libmedia/MediaUtils.cpp
@@ -26,8 +26,6 @@
 
 #include "MediaUtils.h"
 
-extern "C" void __scudo_set_rss_limit(size_t, int) __attribute__((weak));
-
 namespace android {
 
 void limitProcessMemory(const char *property, size_t numberOfBytes,
@@ -59,13 +57,6 @@ void limitProcessMemory(const char *property, size_t numberOfBytes,
         maxMem = propVal;
     }
 
-    // If Scudo is in use, enforce the hard RSS limit (in MB).
-    if (maxMem != SIZE_MAX && &__scudo_set_rss_limit != 0) {
-      __scudo_set_rss_limit(maxMem >> 20, 1);
-      ALOGV("Scudo hard RSS limit set to %zu MB", maxMem >> 20);
-      return;
-    }
-
     if (!android_mallopt(M_SET_ALLOCATION_LIMIT_BYTES, &maxMem,
                          sizeof(maxMem))) {
       ALOGW("couldn't set allocation limit");
diff --git a/frameworks/av/media/libstagefright/omx/Android.bp b/frameworks/av/media/libstagefright/omx/Android.bp
index 7d03d98cc..72a36c7fe 100644
--- a/frameworks/av/media/libstagefright/omx/Android.bp
+++ b/frameworks/av/media/libstagefright/omx/Android.bp
@@ -189,8 +189,6 @@ cc_defaults {
         ],
         cfi: true,
     },
-
-    compile_multilib: "32",
 }
 
 cc_library_shared {
diff --git a/frameworks/av/media/libstagefright/omx/tests/Android.bp b/frameworks/av/media/libstagefright/omx/tests/Android.bp
index 569fa8810..347ceebd4 100644
--- a/frameworks/av/media/libstagefright/omx/tests/Android.bp
+++ b/frameworks/av/media/libstagefright/omx/tests/Android.bp
@@ -29,6 +29,4 @@ cc_test {
         "-Werror",
         "-Wall",
     ],
-
-    compile_multilib: "32",
 }
diff --git a/frameworks/av/media/libstagefright/tests/Android.bp b/frameworks/av/media/libstagefright/tests/Android.bp
index be10fdc94..b21d142bc 100644
--- a/frameworks/av/media/libstagefright/tests/Android.bp
+++ b/frameworks/av/media/libstagefright/tests/Android.bp
@@ -20,8 +20,6 @@ cc_test {
         "frameworks/native/include/media/openmax",
     ],
 
-    compile_multilib: "32",
-
     cflags: [
         "-Werror",
         "-Wall",
diff --git a/frameworks/av/media/mediaserver/Android.bp b/frameworks/av/media/mediaserver/Android.bp
index a968890b3..9212e88b9 100644
--- a/frameworks/av/media/mediaserver/Android.bp
+++ b/frameworks/av/media/mediaserver/Android.bp
@@ -33,9 +33,6 @@ cc_binary {
         "frameworks/av/services/mediaresourcemanager",
     ],
 
-    // back to 32-bit, b/126502613
-    compile_multilib: "32",
-
     init_rc: ["mediaserver.rc"],
 
     cflags: [
diff --git a/frameworks/av/services/mediacodec/Android.bp b/frameworks/av/services/mediacodec/Android.bp
index 99a6d6b80..353888702 100644
--- a/frameworks/av/services/mediacodec/Android.bp
+++ b/frameworks/av/services/mediacodec/Android.bp
@@ -21,15 +21,6 @@ cc_binary {
             exclude_shared_libs: ["libavservices_minijail"],
             shared_libs: ["libavservices_minijail_vendor"],
         },
-        android: {
-            product_variables: {
-                malloc_not_svelte: {
-                    // Scudo increases memory footprint, so only enable on
-                    // non-svelte devices.
-                    shared_libs: ["libc_scudo"],
-                },
-            },
-        },
     },
 
     header_libs: [
diff --git a/frameworks/av/services/mediacodec/Android.mk b/frameworks/av/services/mediacodec/Android.mk
index ecc84087b..c421d6695 100644
--- a/frameworks/av/services/mediacodec/Android.mk
+++ b/frameworks/av/services/mediacodec/Android.mk
@@ -28,6 +28,7 @@ _software_codecs := \
 include $(CLEAR_VARS)
 # seccomp is not required for coverage build.
 ifneq ($(NATIVE_COVERAGE),true)
+LOCAL_REQUIRED_MODULES_arm64 := mediacodec.policy
 LOCAL_REQUIRED_MODULES_arm := mediacodec.policy
 LOCAL_REQUIRED_MODULES_x86 := mediacodec.policy
 endif
@@ -50,8 +51,6 @@ LOCAL_SHARED_LIBRARIES := \
 LOCAL_MODULE := android.hardware.media.omx@1.0-service
 LOCAL_MODULE_RELATIVE_PATH := hw
 LOCAL_VENDOR_MODULE := true
-LOCAL_32_BIT_ONLY := true
-# Since this is 32-bit-only module, only 32-bit version of the codecs are installed.
 # TODO(b/72343507): eliminate the need for manually adding .vendor suffix. This should be done
 # by the build system.
 LOCAL_REQUIRED_MODULES += \
diff --git a/frameworks/av/services/mediacodec/seccomp_policy/mediacodec-arm64.policy b/frameworks/av/services/mediacodec/seccomp_policy/mediacodec-arm64.policy
new file mode 100644
index 000000000..0dac95056
--- /dev/null
+++ b/frameworks/av/services/mediacodec/seccomp_policy/mediacodec-arm64.policy
@@ -0,0 +1,61 @@
+# Organized by frequency of systemcall - in descending order for
+# best performance.
+futex: 1
+ioctl: 1
+write: 1
+prctl: 1
+clock_gettime: 1
+getpriority: 1
+read: 1
+close: 1
+writev: 1
+dup: 1
+ppoll: 1
+mmap: 1
+getrandom: 1
+memfd_create: 1
+ftruncate: 1
+
+# mremap: Ensure |flags| are (MREMAP_MAYMOVE | MREMAP_FIXED) TODO: Once minijail
+# parser support for '<' is in this needs to be modified to also prevent
+# |old_address| and |new_address| from touching the exception vector page, which
+# on ARM is statically loaded at 0xffff 0000. See
+# http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0211h/Babfeega.html
+# for more details.
+mremap: arg3 == 3
+munmap: 1
+mprotect: 1
+madvise: 1
+openat: 1
+sigaltstack: 1
+clone: 1
+setpriority: 1
+getrlimit: 1
+getuid: 1
+fstat: 1
+fstatfs: 1
+newfstatat: 1
+pread64: 1
+faccessat: 1
+readlinkat: 1
+exit: 1
+rt_sigprocmask: 1
+set_tid_address: 1
+restart_syscall: 1
+exit_group: 1
+rt_sigreturn: 1
+pipe2: 1
+gettimeofday: 1
+sched_yield: 1
+nanosleep: 1
+lseek: 1
+sched_get_priority_max: 1
+sched_get_priority_min: 1
+statfs64: 1
+sched_setscheduler: 1
+fstatat: 1
+ugetrlimit: 1
+getdents64: 1
+getrandom: 1
+
+@include /system/etc/seccomp_policy/crash_dump.arm64.policy
diff --git a/frameworks/av/services/mediadrm/Android.mk b/frameworks/av/services/mediadrm/Android.mk
index 227a29d4c..bed93a3ae 100644
--- a/frameworks/av/services/mediadrm/Android.mk
+++ b/frameworks/av/services/mediadrm/Android.mk
@@ -36,14 +36,6 @@ LOCAL_CFLAGS += -Wall -Wextra -Werror
 
 LOCAL_MODULE:= mediadrmserver
 
-# TODO: Some legacy DRM plugins only support 32-bit. They need to be migrated to
-# 64-bit. (b/18948909) Once all of a device's legacy DRM plugins support 64-bit,
-# that device can turn on TARGET_ENABLE_MEDIADRM_64 to build this service as
-# 64-bit.
-ifneq ($(TARGET_ENABLE_MEDIADRM_64), true)
-LOCAL_32_BIT_ONLY := true
-endif
-
 LOCAL_INIT_RC := mediadrmserver.rc
 
 include $(BUILD_EXECUTABLE)
diff --git a/frameworks/av/services/mediaextractor/Android.bp b/frameworks/av/services/mediaextractor/Android.bp
index b81224417..f765a7a97 100644
--- a/frameworks/av/services/mediaextractor/Android.bp
+++ b/frameworks/av/services/mediaextractor/Android.bp
@@ -28,17 +28,6 @@ cc_binary {
         "liblog",
         "libavservices_minijail",
     ],
-    target: {
-        android: {
-            product_variables: {
-                malloc_not_svelte: {
-                    // Scudo increases memory footprint, so only enable on
-                    // non-svelte devices.
-                    shared_libs: ["libc_scudo"],
-                },
-            },
-        },
-    },
     init_rc: ["mediaextractor.rc"],
 
     include_dirs: ["frameworks/av/media/libmedia"],

project frameworks/base/
diff --git a/frameworks/base/core/java/android/os/Build.java b/frameworks/base/core/java/android/os/Build.java
index 77d367f0d93..aa945a5f81b 100755
--- a/frameworks/base/core/java/android/os/Build.java
+++ b/frameworks/base/core/java/android/os/Build.java
@@ -1062,6 +1062,8 @@ public class Build {
         // Don't care on eng builds.  Incremental build may trigger false negative.
         if (IS_ENG) return true;
 
+/* for now */
+/*
         if (IS_TREBLE_ENABLED) {
             // If we can run this code, the device should already pass AVB.
             // So, we don't need to check AVB here.
@@ -1095,7 +1097,7 @@ public class Build {
                 return false;
             }
         }
-
+*/
         /* TODO: Figure out issue with checks failing
         if (!TextUtils.isEmpty(bootimage)) {
             if (!Objects.equals(system, bootimage)) {
diff --git a/frameworks/base/core/jni/fd_utils.cpp b/frameworks/base/core/jni/fd_utils.cpp
index fa5f931470b..ae6c677481b 100644
--- a/frameworks/base/core/jni/fd_utils.cpp
+++ b/frameworks/base/core/jni/fd_utils.cpp
@@ -33,6 +33,7 @@
 
 // Static whitelist of open paths that the zygote is allowed to keep open.
 static const char* kPathWhitelist[] = {
+  "/apfs/nand",
   "/apex/com.android.conscrypt/javalib/conscrypt.jar",
   "/apex/com.android.media/javalib/updatable-media.jar",
   "/dev/null",
diff --git a/frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.png b/frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.png
index ce546f0a11e..156aef6c8de 100644
Binary files a/frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.png and b/frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.png differ
diff --git a/frameworks/base/native/webview/loader/loader.cpp b/frameworks/base/native/webview/loader/loader.cpp
index 1265763d47d..4cabdbb335a 100644
--- a/frameworks/base/native/webview/loader/loader.cpp
+++ b/frameworks/base/native/webview/loader/loader.cpp
@@ -104,7 +104,7 @@ jboolean DoCreateRelroFile(JNIEnv* env, const char* lib, const char* relro,
   if (handle == NULL) {
     ALOGE("Failed to load library %s: %s", lib, dlerror());
     unlink(relro_tmp);
-    return JNI_FALSE;
+    return JNI_TRUE;
   }
   if (close_result != 0 ||
       chmod(relro_tmp, S_IRUSR | S_IRGRP | S_IROTH) != 0 ||
@@ -121,8 +121,7 @@ jint DoLoadWithRelroFile(JNIEnv* env, const char* lib, const char* relro,
                          jobject clazzLoader) {
   int relro_fd = TEMP_FAILURE_RETRY(open(relro, O_RDONLY));
   if (relro_fd == -1) {
-    ALOGE("Failed to open relro file %s: %s", relro, strerror(errno));
-    return LIBLOAD_FAILED_TO_OPEN_RELRO_FILE;
+    ALOGE("Failed to open relro file %s: %s, continuing", relro, strerror(errno));
   }
   android_namespace_t* ns =
       android::FindNamespaceByClassLoader(env, clazzLoader);
@@ -130,16 +129,21 @@ jint DoLoadWithRelroFile(JNIEnv* env, const char* lib, const char* relro,
     ALOGE("Failed to find classloader namespace");
     return LIBLOAD_FAILED_TO_FIND_NAMESPACE;
   }
-  android_dlextinfo extinfo;
-  extinfo.flags = ANDROID_DLEXT_RESERVED_ADDRESS | ANDROID_DLEXT_USE_RELRO |
+  android_dlextinfo extinfo = { };
+  extinfo.flags = ANDROID_DLEXT_RESERVED_ADDRESS |
                   ANDROID_DLEXT_USE_NAMESPACE |
                   ANDROID_DLEXT_RESERVED_ADDRESS_RECURSIVE;
+  if(relro_fd >= 0) {
+    extinfo.flags |= ANDROID_DLEXT_USE_RELRO;
+    extinfo.relro_fd = relro_fd;
+  }
   extinfo.reserved_addr = gReservedAddress;
   extinfo.reserved_size = gReservedSize;
-  extinfo.relro_fd = relro_fd;
   extinfo.library_namespace = ns;
   void* handle = android_dlopen_ext(lib, RTLD_NOW, &extinfo);
-  close(relro_fd);
+  if(relro_fd >= 0) {
+    close(relro_fd);
+  }
   if (handle == NULL) {
     ALOGE("Failed to load library %s: %s", lib, dlerror());
     return LIBLOAD_FAILED_TO_LOAD_LIBRARY;

project frameworks/compile/mclinker/
diff --git a/frameworks/compile/mclinker/include/mcld/Target/GNUInfo.h b/frameworks/compile/mclinker/include/mcld/Target/GNUInfo.h
index d09e5d9..f779a7b 100644
--- a/frameworks/compile/mclinker/include/mcld/Target/GNUInfo.h
+++ b/frameworks/compile/mclinker/include/mcld/Target/GNUInfo.h
@@ -54,11 +54,11 @@ class GNUInfo {
 
   /// commonPageSize - the common page size of the target machine, and we set it
   /// to 4K here. If target favors the different size, please override this
-  virtual uint64_t commonPageSize() const { return 0x1000; }
+  virtual uint64_t commonPageSize() const { return 0x4000; }
 
   /// abiPageSize - the abi page size of the target machine, and we set it to 4K
   /// here. If target favors the different size, please override this function
-  virtual uint64_t abiPageSize() const { return 0x1000; }
+  virtual uint64_t abiPageSize() const { return 0x4000; }
 
   /// stubGroupSize - the default group size to place stubs between sections.
   virtual unsigned stubGroupSize() const { return 0x10000; }

project frameworks/opt/net/wifi/
diff --git a/frameworks/opt/net/wifi/libwifi_hal/Android.mk b/frameworks/opt/net/wifi/libwifi_hal/Android.mk
index 4e2232fb4..dd0218144 100644
--- a/frameworks/opt/net/wifi/libwifi_hal/Android.mk
+++ b/frameworks/opt/net/wifi/libwifi_hal/Android.mk
@@ -104,6 +104,8 @@ else ifeq ($(BOARD_WLAN_DEVICE), rtl)
   LIB_WIFI_HAL := libwifi-hal-rtl
 else ifeq ($(BOARD_WLAN_DEVICE), emulator)
   LIB_WIFI_HAL := libwifi-hal-emu
+else ifeq ($(BOARD_WLAN_DEVICE), brcmfmac)
+  LIB_WIFI_HAL := libwifi-hal-brcmfmac
 endif
 
 # The WiFi HAL that you should be linking.

project hardware/google/av/
diff --git a/hardware/google/av/codec2/hidl/services/Android.bp b/hardware/google/av/codec2/hidl/services/Android.bp
index 00d25ca..e2ec733 100644
--- a/hardware/google/av/codec2/hidl/services/Android.bp
+++ b/hardware/google/av/codec2/hidl/services/Android.bp
@@ -33,8 +33,6 @@ cc_binary {
             required: ["codec2.vendor.base.policy"],
         },
     },
-
-    compile_multilib: "32",
 }
 
 cc_library_shared {
@@ -88,7 +86,5 @@ cc_library_shared {
         "libstagefright_soft_c2gsmdec",
         "libstagefright_soft_c2xaacdec",
     ],
-
-    compile_multilib: "32",
 }
 

project hardware/interfaces/
diff --git a/hardware/interfaces/camera/provider/2.4/default/Android.bp b/hardware/interfaces/camera/provider/2.4/default/Android.bp
index cb78fcb85..22808ec91 100644
--- a/hardware/interfaces/camera/provider/2.4/default/Android.bp
+++ b/hardware/interfaces/camera/provider/2.4/default/Android.bp
@@ -164,7 +164,6 @@ cc_defaults {
 cc_binary {
     name: "android.hardware.camera.provider@2.4-service",
     defaults: ["camera_service_defaults"],
-    compile_multilib: "32",
     init_rc: ["android.hardware.camera.provider@2.4-service.rc"],
 }
 
@@ -179,7 +178,6 @@ cc_binary {
     name: "android.hardware.camera.provider@2.4-service-lazy",
     overrides: ["android.hardware.camera.provider@2.4-service"],
     defaults: ["camera_service_defaults"],
-    compile_multilib: "32",
     init_rc: ["android.hardware.camera.provider@2.4-service-lazy.rc"],
     cflags: ["-DLAZY_SERVICE"],
 }
@@ -199,7 +197,6 @@ cc_binary {
     proprietary: true,
     relative_install_path: "hw",
     srcs: ["external-service.cpp"],
-    compile_multilib: "32",
     init_rc: ["android.hardware.camera.provider@2.4-external-service.rc"],
     shared_libs: [
         "android.hardware.camera.common@1.0",
diff --git a/hardware/interfaces/camera/provider/2.5/default/Android.bp b/hardware/interfaces/camera/provider/2.5/default/Android.bp
index cd1caebe3..c30c13453 100644
--- a/hardware/interfaces/camera/provider/2.5/default/Android.bp
+++ b/hardware/interfaces/camera/provider/2.5/default/Android.bp
@@ -119,7 +119,6 @@ cc_defaults {
 cc_binary {
     name: "android.hardware.camera.provider@2.5-service",
     defaults: ["camera_service_2_5_defaults"],
-    compile_multilib: "32",
     init_rc: ["android.hardware.camera.provider@2.5-service.rc"],
 }
 
@@ -134,7 +133,6 @@ cc_binary {
     name: "android.hardware.camera.provider@2.5-service-lazy",
     overrides: ["android.hardware.camera.provider@2.5-service"],
     defaults: ["camera_service_2_5_defaults"],
-    compile_multilib: "32",
     init_rc: ["android.hardware.camera.provider@2.5-service-lazy.rc"],
     cflags: ["-DLAZY_SERVICE"],
 }
@@ -154,7 +152,6 @@ cc_binary {
     proprietary: true,
     relative_install_path: "hw",
     srcs: ["external-service.cpp"],
-    compile_multilib: "32",
     init_rc: ["android.hardware.camera.provider@2.5-external-service.rc"],
     shared_libs: [
         "android.hardware.camera.common@1.0",
diff --git a/hardware/interfaces/cas/1.0/default/Android.bp b/hardware/interfaces/cas/1.0/default/Android.bp
index aa080f458..373992556 100644
--- a/hardware/interfaces/cas/1.0/default/Android.bp
+++ b/hardware/interfaces/cas/1.0/default/Android.bp
@@ -12,8 +12,6 @@ cc_defaults {
       "TypeConvert.cpp",
     ],
 
-    compile_multilib: "32",
-
     shared_libs: [
       "android.hardware.cas@1.0",
       "android.hardware.cas.native@1.0",
diff --git a/hardware/interfaces/cas/1.1/default/Android.bp b/hardware/interfaces/cas/1.1/default/Android.bp
index 68a49cf5b..284f4d1c1 100644
--- a/hardware/interfaces/cas/1.1/default/Android.bp
+++ b/hardware/interfaces/cas/1.1/default/Android.bp
@@ -12,8 +12,6 @@ cc_defaults {
       "TypeConvert.cpp",
     ],
 
-    compile_multilib: "32",
-
     shared_libs: [
       "android.hardware.cas@1.0",
       "android.hardware.cas@1.1",
diff --git a/hardware/interfaces/cas/1.1/default/DescramblerImpl.cpp b/hardware/interfaces/cas/1.1/default/DescramblerImpl.cpp
index 36dc1a51d..5a9be9ddc 100644
--- a/hardware/interfaces/cas/1.1/default/DescramblerImpl.cpp
+++ b/hardware/interfaces/cas/1.1/default/DescramblerImpl.cpp
@@ -27,6 +27,8 @@
 #include "SharedLibrary.h"
 #include "TypeConvert.h"
 
+#pragma GCC diagnostic ignored "-Wformat"
+
 namespace android {
 using hidl::memory::V1_0::IMemory;
 

project hardware/libhardware/
diff --git a/hardware/libhardware/modules/gralloc/framebuffer.cpp b/hardware/libhardware/modules/gralloc/framebuffer.cpp
index c1717115..56bb8a74 100644
--- a/hardware/libhardware/modules/gralloc/framebuffer.cpp
+++ b/hardware/libhardware/modules/gralloc/framebuffer.cpp
@@ -46,7 +46,7 @@
 #endif
 
 // numbers of buffers for page flipping
-#define NUM_BUFFERS 2
+#define NUM_BUFFERS 1
 
 
 enum {
@@ -69,6 +69,19 @@ static int fb_setSwapInterval(struct framebuffer_device_t* dev,
     return 0;
 }
 
+static int fb_enableScreen(struct framebuffer_device_t *dev, int enable)
+{
+    private_module_t* m = reinterpret_cast<private_module_t*>(
+            dev->common.module);
+
+    if (ioctl(m->framebuffer->fd, FBIOBLANK, enable ? FB_BLANK_UNBLANK : FB_BLANK_POWERDOWN) == -1) {
+        ALOGE("FBIOBLANK(%d) failed", enable);
+        return -errno;
+    }
+
+    return 0;
+}
+
 static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer)
 {
     if (private_handle_t::validate(buffer) < 0)
@@ -221,7 +234,8 @@ int mapFrameBufferLocked(struct private_module_t* module)
             "bpp          = %d\n"
             "r            = %2u:%u\n"
             "g            = %2u:%u\n"
-            "b            = %2u:%u\n",
+            "b            = %2u:%u\n"
+            "stride       = %u\n",
             fd,
             finfo.id,
             info.xres,
@@ -231,7 +245,8 @@ int mapFrameBufferLocked(struct private_module_t* module)
             info.bits_per_pixel,
             info.red.offset, info.red.length,
             info.green.offset, info.green.length,
-            info.blue.offset, info.blue.length
+            info.blue.offset, info.blue.length,
+            finfo.line_length
     );
 
     ALOGI(   "width        = %d mm (%f dpi)\n"
@@ -312,6 +327,7 @@ int fb_device_open(hw_module_t const* module, const char* name,
         dev->device.common.close = fb_close;
         dev->device.setSwapInterval = fb_setSwapInterval;
         dev->device.post            = fb_post;
+        dev->device.enableScreen    = fb_enableScreen;
         dev->device.setUpdateRect = 0;
 
         private_module_t* m = (private_module_t*)module;
@@ -332,8 +348,6 @@ int fb_device_open(hw_module_t const* module, const char* name,
             const_cast<int&>(dev->device.minSwapInterval) = 1;
             const_cast<int&>(dev->device.maxSwapInterval) = 1;
             *device = &dev->device.common;
-        } else {
-            free(dev);
         }
     }
     return status;
diff --git a/hardware/libhardware/modules/gralloc/gralloc.cpp b/hardware/libhardware/modules/gralloc/gralloc.cpp
index 07bbfbac..144512bb 100644
--- a/hardware/libhardware/modules/gralloc/gralloc.cpp
+++ b/hardware/libhardware/modules/gralloc/gralloc.cpp
@@ -89,6 +89,10 @@ struct private_module_t HAL_MODULE_INFO_SYM = {
         .unregisterBuffer = gralloc_unregister_buffer,
         .lock = gralloc_lock,
         .unlock = gralloc_unlock,
+#if PLATFORM_SDK_VERSION >= 28
+        .validateBufferSize = NULL,
+        .getTransportSize = NULL,
+#endif
     },
     .framebuffer = 0,
     .flags = 0,
@@ -228,7 +232,7 @@ static int gralloc_alloc(alloc_device_t* dev,
             return -EINVAL;
     }
 
-    const size_t tileWidth = 2;
+    const size_t tileWidth = 16;
     const size_t tileHeight = 2;
 
     size_t stride = align(width, tileWidth);

project hardware/ril/
diff --git a/hardware/ril/rild/rild.legacy.rc b/hardware/ril/rild/rild.legacy.rc
index b27e1da..2ee3856 100644
--- a/hardware/ril/rild/rild.legacy.rc
+++ b/hardware/ril/rild/rild.legacy.rc
@@ -1,5 +1,5 @@
-service ril-daemon /vendor/bin/hw/rild
-    class main
-    user radio
-    group radio cache inet misc audio log readproc wakelock
-    capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW
+#service ril-daemon /vendor/bin/hw/rild
+#    class main
+#    user radio
+#    group radio cache inet misc audio log readproc wakelock
+#    capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW
diff --git a/hardware/ril/rild/rild.rc b/hardware/ril/rild/rild.rc
index f6beb54..44bdd64 100644
--- a/hardware/ril/rild/rild.rc
+++ b/hardware/ril/rild/rild.rc
@@ -1,5 +1,5 @@
-service vendor.ril-daemon /vendor/bin/hw/rild
-    class main
-    user radio
-    group radio cache inet misc audio log readproc wakelock
-    capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW
+#service vendor.ril-daemon /vendor/bin/hw/rild
+#    class main
+#    user radio
+#    group radio cache inet misc audio log readproc wakelock
+#    capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW

project packages/apps/Bluetooth/
diff --git a/packages/apps/Bluetooth/jni/Android.bp b/packages/apps/Bluetooth/jni/Android.bp
index 1262469db..edee2bb13 100644
--- a/packages/apps/Bluetooth/jni/Android.bp
+++ b/packages/apps/Bluetooth/jni/Android.bp
@@ -43,7 +43,4 @@ cc_library_shared {
         "-Wextra",
         "-Wno-unused-parameter",
     ],
-    sanitize: {
-        scs: true,
-    },
 }

project packages/apps/Launcher3/
diff --git a/packages/apps/Launcher3/Android.mk b/packages/apps/Launcher3/Android.mk
index 9d113d954..82b97f2ad 100644
--- a/packages/apps/Launcher3/Android.mk
+++ b/packages/apps/Launcher3/Android.mk
@@ -216,6 +216,41 @@ LOCAL_JACK_COVERAGE_INCLUDE_FILTER := com.android.launcher3.*
 
 include $(BUILD_PACKAGE)
 
+#
+# Build rule for Quickstep app without launcher.
+#
+include $(CLEAR_VARS)
+LOCAL_USE_AAPT2 := true
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_STATIC_ANDROID_LIBRARIES := Launcher3QuickStepLib
+LOCAL_PROGUARD_ENABLED := disabled
+
+ifneq (,$(wildcard frameworks/base))
+  LOCAL_PRIVATE_PLATFORM_APIS := true
+else
+  LOCAL_SDK_VERSION := system_current
+  LOCAL_MIN_SDK_VERSION := 26
+endif
+LOCAL_PACKAGE_NAME := Launcher3QuickStepNoLaunch
+LOCAL_PRIVILEGED_MODULE := true
+LOCAL_PRODUCT_MODULE := true
+LOCAL_OVERRIDES_PACKAGES := Home Launcher2 Launcher3
+LOCAL_REQUIRED_MODULES := privapp_whitelist_com.android.launcher3
+
+LOCAL_RESOURCE_DIR := \
+    $(LOCAL_PATH)/quickstep/res \
+    $(LOCAL_PATH)/quickstep/recents_ui_overrides/res
+
+LOCAL_FULL_LIBS_MANIFEST_FILES := \
+    $(LOCAL_PATH)/AndroidManifest-nohome.xml \
+    $(LOCAL_PATH)/AndroidManifest-common.xml
+
+LOCAL_MANIFEST_FILE := quickstep/AndroidManifest.xml
+LOCAL_JACK_COVERAGE_INCLUDE_FILTER := com.android.launcher3.*
+
+include $(BUILD_PACKAGE)
+
 
 #
 # Build rule for Launcher3 Go app with quickstep for Android Go devices.
diff --git a/packages/apps/Launcher3/AndroidManifest-nohome.xml b/packages/apps/Launcher3/AndroidManifest-nohome.xml
new file mode 100644
index 000000000..cfc4f154c
--- /dev/null
+++ b/packages/apps/Launcher3/AndroidManifest-nohome.xml
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!--
+/*
+**
+** Copyright 2008, The Android Open Source Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+-->
+<manifest
+    xmlns:android="http://schemas.android.com/apk/res/android"
+    package="com.android.launcher3">
+    <uses-sdk android:targetSdkVersion="29" android:minSdkVersion="25"/>
+    <!--
+    Manifest entries specific to Launcher3. This is merged with AndroidManifest-common.xml.
+    Refer comments around specific entries on how to extend individual components.
+    -->
+
+    <application
+        android:backupAgent="com.android.launcher3.LauncherBackupAgent"
+        android:fullBackupOnly="true"
+        android:fullBackupContent="@xml/backupscheme"
+        android:hardwareAccelerated="true"
+        android:icon="@drawable/ic_launcher_home"
+        android:label="@string/derived_app_name"
+        android:theme="@style/AppTheme"
+        android:largeHeap="@bool/config_largeHeap"
+        android:restoreAnyVersion="true"
+        android:supportsRtl="true" >
+
+        <!--
+        Main launcher activity. When extending only change the name, and keep all the
+        attributes and intent filters the same
+        -->
+        <activity
+            android:name="com.android.launcher3.Launcher"
+            android:launchMode="singleTask"
+            android:clearTaskOnLaunch="true"
+            android:stateNotNeeded="true"
+            android:windowSoftInputMode="adjustPan"
+            android:screenOrientation="unspecified"
+            android:configChanges="keyboard|keyboardHidden|mcc|mnc|navigation|orientation|screenSize|screenLayout|smallestScreenSize"
+            android:resizeableActivity="true"
+            android:resumeWhilePausing="true"
+            android:taskAffinity=""
+            android:enabled="true">
+            <intent-filter>
+                <action android:name="android.intent.action.MAIN" />
+                <category android:name="android.intent.category.DEFAULT" />
+                <category android:name="android.intent.category.MONKEY"/>
+                <category android:name="android.intent.category.LAUNCHER_APP" />
+            </intent-filter>
+            <meta-data
+                android:name="com.android.launcher3.grid.control"
+                android:value="${packageName}.grid_control" />
+        </activity>
+
+    </application>
+</manifest>
diff --git a/packages/apps/Launcher3/quickstep/src/com/android/quickstep/OverviewComponentObserver.java b/packages/apps/Launcher3/quickstep/src/com/android/quickstep/OverviewComponentObserver.java
index 0738affa9..81d45fa9e 100644
--- a/packages/apps/Launcher3/quickstep/src/com/android/quickstep/OverviewComponentObserver.java
+++ b/packages/apps/Launcher3/quickstep/src/com/android/quickstep/OverviewComponentObserver.java
@@ -68,7 +68,11 @@ public final class OverviewComponentObserver {
                 .addCategory(Intent.CATEGORY_HOME)
                 .setPackage(mContext.getPackageName());
         ResolveInfo info = context.getPackageManager().resolveActivity(myHomeIntent, 0);
-        mMyHomeComponent = new ComponentName(context.getPackageName(), info.activityInfo.name);
+        if(info != null) {
+            mMyHomeComponent = new ComponentName(context.getPackageName(), info.activityInfo.name);
+        } else {
+            mMyHomeComponent = null;
+        }
 
         mContext.registerReceiver(mUserPreferenceChangeReceiver,
                 new IntentFilter(ACTION_PREFERRED_ACTIVITY_CHANGED));
@@ -96,7 +100,7 @@ public final class OverviewComponentObserver {
         ComponentName overviewComponent;
         mHomeIntent = null;
 
-        if ((mSystemUiStateFlags & SYSUI_STATE_HOME_DISABLED) == 0 &&
+        if (mMyHomeComponent != null && (mSystemUiStateFlags & SYSUI_STATE_HOME_DISABLED) == 0 &&
                 (defaultHome == null || mMyHomeComponent.equals(defaultHome))) {
             // User default home is same as out home app. Use Overview integrated in Launcher.
             overviewComponent = mMyHomeComponent;

project system/bt/
diff --git a/system/bt/binder/Android.bp b/system/bt/binder/Android.bp
index 650906ce5..cff166bf5 100644
--- a/system/bt/binder/Android.bp
+++ b/system/bt/binder/Android.bp
@@ -76,9 +76,6 @@ cc_library_shared {
         "-Wextra",
         "-Wno-unused-parameter",
     ],
-    sanitize: {
-        scs: true,
-    },
 }
 
 // AIDL interface between libbluetooth-binder and framework.jar
diff --git a/system/bt/main/Android.bp b/system/bt/main/Android.bp
index f787e9e6e..8b3256215 100644
--- a/system/bt/main/Android.bp
+++ b/system/bt/main/Android.bp
@@ -98,9 +98,6 @@ cc_library_shared {
     cflags: [
         "-DBUILDCFG",
     ],
-    sanitize: {
-        scs: true,
-    },
 }
 
 cc_library_static {
diff --git a/system/bt/stack/btm/btm_ble_gap.cc b/system/bt/stack/btm/btm_ble_gap.cc
index c46acf0d3..a50b01fed 100644
--- a/system/bt/stack/btm/btm_ble_gap.cc
+++ b/system/bt/stack/btm/btm_ble_gap.cc
@@ -498,7 +498,12 @@ static void btm_ble_vendor_capability_vsc_cmpl_cback(
     BTM_TRACE_DEBUG("%s: Status = 0x%02x (0 is success)", __func__, status);
     return;
   }
-  CHECK(p_vcs_cplt_params->param_len > BTM_VSC_CHIP_CAPABILITY_RSP_LEN);
+
+  if(p_vcs_cplt_params->param_len < BTM_VSC_CHIP_CAPABILITY_RSP_LEN) {
+    BTM_TRACE_DEBUG("%s: Can't parse vendor LE capability (%d bytes)", __func__, p_vcs_cplt_params->param_len);
+    return;
+  }
+
   STREAM_TO_UINT8(btm_cb.cmn_ble_vsc_cb.adv_inst_max, p);
   STREAM_TO_UINT8(btm_cb.cmn_ble_vsc_cb.rpa_offloading, p);
   STREAM_TO_UINT16(btm_cb.cmn_ble_vsc_cb.tot_scan_results_strg, p);
diff --git a/system/bt/vendor_libs/linux/interface/bluetooth_hci.cc b/system/bt/vendor_libs/linux/interface/bluetooth_hci.cc
index 8d7e3f731..610f7c8d6 100644
--- a/system/bt/vendor_libs/linux/interface/bluetooth_hci.cc
+++ b/system/bt/vendor_libs/linux/interface/bluetooth_hci.cc
@@ -14,6 +14,10 @@
 // limitations under the License.
 //
 
+#define DRIVER_BIND_FILE        "/sys/bus/serial/drivers/hci_uart_bcm/bind"
+#define DRIVER_UNBIND_FILE      "/sys/bus/serial/drivers/hci_uart_bcm/unbind"
+#define DRIVER_BIND_TARGET      "serial0-0"
+
 #define LOG_TAG "android.hardware.bluetooth@1.0-btlinux"
 #include <errno.h>
 #include <fcntl.h>
@@ -222,18 +226,16 @@ int BluetoothHci::findRfKill() {
 
 int BluetoothHci::rfKill(int block) {
   int fd;
-  char on = (block)?'1':'0';
-  if (findRfKill() != 0) return 0;
 
-  fd = open(rfkill_state_, O_WRONLY);
+  fd = open(block ? DRIVER_BIND_FILE : DRIVER_UNBIND_FILE, O_WRONLY);
   if (fd < 0) {
-    ALOGE( "Unable to open /dev/rfkill");
+    ALOGE( "Unable to open %s", block ? DRIVER_BIND_FILE : DRIVER_UNBIND_FILE);
     return -1;
   }
   ssize_t len;
-  WRITE_NO_INTR(len = write(fd, &on, 1));
+  WRITE_NO_INTR(len = write(fd, DRIVER_BIND_TARGET, strlen(DRIVER_BIND_TARGET)));
   if (len < 0) {
-    ALOGE( "Failed to change rfkill state");
+    ALOGE( "Failed to change bluetooth state");
     ::close(fd);
     return -1;
   }

project system/core/
diff --git a/system/core/adb/daemon/usb.cpp b/system/core/adb/daemon/usb.cpp
index 1abae87c5..dc28dddcd 100644
--- a/system/core/adb/daemon/usb.cpp
+++ b/system/core/adb/daemon/usb.cpp
@@ -61,10 +61,10 @@ static std::optional<bool> gFfsAioSupported;
 // Also, each submitted operation does an allocation in the kernel of that size, so we want to
 // minimize our queue depth while still maintaining a deep enough queue to keep the USB stack fed.
 static constexpr size_t kUsbReadQueueDepth = 8;
-static constexpr size_t kUsbReadSize = 4 * PAGE_SIZE;
+static constexpr size_t kUsbReadSize = 16384;
 
 static constexpr size_t kUsbWriteQueueDepth = 8;
-static constexpr size_t kUsbWriteSize = 4 * PAGE_SIZE;
+static constexpr size_t kUsbWriteSize = 16384;
 
 static const char* to_string(enum usb_functionfs_event_type type) {
     switch (type) {
diff --git a/system/core/healthd/BatteryMonitor.cpp b/system/core/healthd/BatteryMonitor.cpp
index 06c8176e9..43123ab77 100644
--- a/system/core/healthd/BatteryMonitor.cpp
+++ b/system/core/healthd/BatteryMonitor.cpp
@@ -329,7 +329,7 @@ bool BatteryMonitor::update(void) {
                  props.chargerUsbOnline ? "u" : "",
                  props.chargerWirelessOnline ? "w" : "");
 
-        KLOG_WARNING(LOG_TAG, "%s\n", dmesgline);
+        KLOG_DEBUG(LOG_TAG, "%s\n", dmesgline);
     }
 
     healthd_mode_ops->battery_update(&props);
diff --git a/system/core/healthd/HealthServiceDefault.cpp b/system/core/healthd/HealthServiceDefault.cpp
index 89ecc2fa4..34e9e9daa 100644
--- a/system/core/healthd/HealthServiceDefault.cpp
+++ b/system/core/healthd/HealthServiceDefault.cpp
@@ -30,8 +30,8 @@ int healthd_board_battery_update(struct android::BatteryProperties*) {
     // Implementation-defined update logic goes here. An implementation
     // can make modifications to prop before broadcasting it to all callbacks.
 
-    // return 0 to log periodic polled battery status to kernel log
-    return 0;
+    // return 1 to not log periodic polled battery status to kernel log
+    return 1;
 }
 
 int main() {
diff --git a/system/core/healthd/HealthServiceHealthd.cpp b/system/core/healthd/HealthServiceHealthd.cpp
index 5fd2597d6..b407efa7c 100644
--- a/system/core/healthd/HealthServiceHealthd.cpp
+++ b/system/core/healthd/HealthServiceHealthd.cpp
@@ -72,7 +72,7 @@ void healthd_board_init(struct healthd_config* config) {
 // TODO(b/68724651): Move this function into healthd_mode_service_2_0_battery_update
 // with logthis returned.
 int healthd_board_battery_update(struct android::BatteryProperties* props) {
-    int logthis = 0;
+    int logthis = 1;
 
     if (gHealth_1_0 == nullptr) {
         return logthis;
diff --git a/system/core/healthd/charger_test.cpp b/system/core/healthd/charger_test.cpp
index a7e216196..d16f2084b 100644
--- a/system/core/healthd/charger_test.cpp
+++ b/system/core/healthd/charger_test.cpp
@@ -132,8 +132,8 @@ void healthd_board_init(struct healthd_config* config) {
 int healthd_board_battery_update(struct android::BatteryProperties*) {
     getUpdateNotifier().set(true /* updated */);
 
-    // return 0 to log periodic polled battery status to kernel log
-    return 0;
+    // return 1 to not log periodic polled battery status to kernel log
+    return 1;
 }
 
 extern int healthd_charger_main(int argc, char** argv);
diff --git a/system/core/init/Android.bp b/system/core/init/Android.bp
index 6be7290e3..edcea77e5 100644
--- a/system/core/init/Android.bp
+++ b/system/core/init/Android.bp
@@ -25,9 +25,8 @@ cc_defaults {
         "-Wall",
         "-Wextra",
         "-Wno-unused-parameter",
-        "-Werror",
         "-DALLOW_LOCAL_PROP_OVERRIDE=0",
-        "-DALLOW_PERMISSIVE_SELINUX=0",
+        "-DALLOW_PERMISSIVE_SELINUX=1",
         "-DREBOOT_BOOTLOADER_ON_PANIC=0",
         "-DWORLD_WRITABLE_KMSG=0",
         "-DDUMP_ON_UMOUNT_FAILURE=0",
@@ -229,7 +228,6 @@ cc_binary {
         "-Wall",
         "-Wextra",
         "-Wno-unused-parameter",
-        "-Werror",
     ],
     static_libs: [
         "libbase",
diff --git a/system/core/init/Android.mk b/system/core/init/Android.mk
index c4f7d34b2..0b1483612 100644
--- a/system/core/init/Android.mk
+++ b/system/core/init/Android.mk
@@ -37,7 +37,6 @@ init_cflags += \
     $(init_options) \
     -Wall -Wextra \
     -Wno-unused-parameter \
-    -Werror \
 
 # --
 
diff --git a/system/core/init/devices.cpp b/system/core/init/devices.cpp
index 159c75e03..d97972454 100644
--- a/system/core/init/devices.cpp
+++ b/system/core/init/devices.cpp
@@ -111,6 +111,26 @@ static bool FindVbdDevicePrefix(const std::string& path, std::string* result) {
     return true;
 }
 
+static bool FindLoopDevicePrefix(const std::string& path, std::string* result) {
+    result->clear();
+
+    if (!StartsWith(path, "/devices/virtual/block/loop")) return false;
+
+    /* Beginning of the prefix is the initial "loop" after "/block/" */
+    std::string::size_type start = 27;
+
+    /* End of the prefix is one path '/' later, capturing the
+       loop device ID. Example: 0 */
+    auto end = path.find('/', start);
+    if (end == std::string::npos) return false;
+
+    auto length = end - start;
+    if (length == 0) return false;
+
+    *result = path.substr(start, length);
+    return true;
+}
+
 // Given a path that may start with a virtual dm block device, populate
 // the supplied buffer with the dm module's instantiated name.
 // If it doesn't start with a virtual block device, or there is some
@@ -346,6 +366,8 @@ std::vector<std::string> DeviceHandler::GetBlockDeviceSymlinks(const Uevent& uev
         type = "pci";
     } else if (FindVbdDevicePrefix(uevent.path, &device)) {
         type = "vbd";
+    } else if (FindLoopDevicePrefix(uevent.path, &device)) {
+        type = "loop";
     } else if (FindDmDevicePartition(uevent.path, &partition)) {
         return {"/dev/block/mapper/" + partition};
     } else {
@@ -359,6 +381,7 @@ std::vector<std::string> DeviceHandler::GetBlockDeviceSymlinks(const Uevent& uev
     auto link_path = "/dev/block/" + type + "/" + device;
 
     bool is_boot_device = boot_devices_.find(device) != boot_devices_.end();
+LOG(INFO) << "found " << type << " device " << device << " is_boot_device " << (is_boot_device ? "true" : "false");
     if (!uevent.partition_name.empty()) {
         std::string partition_name_sanitized(uevent.partition_name);
         SanitizePartitionName(&partition_name_sanitized);
diff --git a/system/core/init/first_stage_mount.cpp b/system/core/init/first_stage_mount.cpp
index 3e76556ff..ee8d57628 100644
--- a/system/core/init/first_stage_mount.cpp
+++ b/system/core/init/first_stage_mount.cpp
@@ -37,6 +37,8 @@
 #include <libgsi/libgsi.h>
 #include <liblp/liblp.h>
 
+#include <linux/loop.h>
+
 #include "devices.h"
 #include "switch_root.h"
 #include "uevent.h"
@@ -136,6 +138,104 @@ class FirstStageMountVBootV2 : public FirstStageMount {
 
 // Static Functions
 // ----------------
+
+#define LOOP_SET_FD             0x4C00
+#define LOOP_SET_STATUS         0x4C02
+#define LOOP_SET_BLOCK_SIZE     0x4C09
+
+#define LOOP_DEVICE_NAME        "loop0"
+#define LOOP_BACKING_FILE       "/apfs/nand"
+
+#define APFS_MOUNT_POINT        "/apfs"
+#define APFS_DEVICE_NAME        "nvme0n1p1"
+#define APFS_MAX_VOL            16
+
+static int early_create_block_dev(const char *name, char *res)
+{
+    char buf[256];
+    unsigned major, minor;
+    FILE *fp;
+
+    sprintf(buf, "/sys/class/block/%s/dev", name);
+    fp = fopen(buf, "r");
+    if(!fp) {
+        LOG(ERROR) << "Could not find block device " << name;
+        return -1;
+    }
+    fgets(buf, sizeof(buf), fp);
+    fclose(fp);
+    major = strtoul(buf, NULL, 0);
+    minor = strtoul(strchr(buf, ':') + 1, NULL, 0);
+    LOG(INFO) << "Early block device " << name << ": " << major << ":" << minor;
+
+    mkdir("/dev/block", 0755);
+    sprintf(res, "/dev/block/%s", name);
+    mknod(res, S_IFBLK | 0755, makedev(major, minor));
+    return 0;
+}
+
+static int mount_apfs_loop() {
+    int lfd, bimg, vol;
+    unsigned long blocksize = 4096;
+    char buf[256], opt[32];
+    struct loop_info info = { };
+    struct stat statbuf;
+
+    if(early_create_block_dev(APFS_DEVICE_NAME, buf))
+        return -1;
+    mkdir(APFS_MOUNT_POINT, 0755);
+    for(vol=APFS_MAX_VOL-1; vol>=2; vol--) {
+        sprintf(opt, "vol=%d", vol);
+        if (mount(buf, APFS_MOUNT_POINT, "apfs", MS_RDONLY | MS_NODEV | MS_NOSUID, opt)) {
+            continue;
+        }
+        if (!stat(LOOP_BACKING_FILE, &statbuf)) {
+            LOG(INFO) << "Found APFS volume " << vol;
+            break;
+        }
+        umount(APFS_MOUNT_POINT);
+    }
+    if(vol >= APFS_MAX_VOL) {
+        LOG(ERROR) << "Could not find an APFS volume with NAND";
+        return -1;
+    }
+
+    if(early_create_block_dev(LOOP_DEVICE_NAME, buf))
+        return -1;
+    lfd = open(buf, O_RDWR);
+    if (lfd == -1) {
+        LOG(ERROR) << "Could not open loop device";
+        return -1;
+    }
+
+    bimg = open(LOOP_BACKING_FILE, O_RDONLY);
+    if (bimg < 0) {
+        LOG(ERROR) << "Could not open loop backing file";
+        return -1;
+    }
+
+    if (ioctl(lfd, LOOP_SET_FD, bimg) == -1) {
+        LOG(ERROR) << "Failed to set backing file FD on loop: " << strerror(errno);
+        return -1;
+    }
+
+    if (ioctl(lfd, LOOP_SET_BLOCK_SIZE, blocksize) == -1) {
+        LOG(ERROR) << "Failed to set blocksize on loop";
+        return 1;
+    }
+
+    strncpy(info.lo_name, LOOP_BACKING_FILE, LO_NAME_SIZE);
+    info.lo_flags = LO_FLAGS_READ_ONLY | LO_FLAGS_PARTSCAN;
+    if (ioctl(lfd, LOOP_SET_STATUS, &info) == -1) {
+        LOG(ERROR) << "Failed to start loop: " << strerror(errno);
+        return 1;
+    }
+
+    close(lfd);
+
+    return 0;
+}
+
 static inline bool IsDtVbmetaCompatible(const Fstab& fstab) {
     if (std::any_of(fstab.begin(), fstab.end(),
                     [](const auto& entry) { return entry.fs_mgr_flags.avb; })) {
@@ -242,11 +342,18 @@ bool FirstStageMount::DoFirstStageMount() {
         return true;
     }
 
+    if(mount_apfs_loop()) {
+        LOG(ERROR) << "Could not mount root device on APFS";
+        return true;
+    }
+
     if (!InitDevices()) return false;
 
     if (!CreateLogicalPartitions()) return false;
 
+LOG(INFO) << "before MountPartitions!";
     if (!MountPartitions()) return false;
+LOG(INFO) << "after MountPartitions!";
 
     return true;
 }
@@ -516,6 +623,7 @@ bool FirstStageMount::TrySwitchSystemAsRoot() {
             return false;
         }
         SwitchRoot("/system");
+LOG(INFO) << "SwitchRoot to System succeeded";
     } else {
         PLOG(ERROR) << "Failed to mount /system";
         return false;
@@ -530,6 +638,7 @@ bool FirstStageMount::MountPartitions() {
     if (!SkipMountingPartitions(&fstab_)) return false;
 
     for (auto current = fstab_.begin(); current != fstab_.end();) {
+LOG(INFO) << "MountPartitions looking at " << current->mount_point;
         // We've already mounted /system above.
         if (current->mount_point == "/system") {
             ++current;
@@ -552,9 +661,11 @@ bool FirstStageMount::MountPartitions() {
         current = end;
     }
 
+LOG(INFO) << "MountPartitions done base mounts";
     // If we don't see /system or / in the fstab, then we need to create an root entry for
     // overlayfs.
     if (!GetEntryForMountPoint(&fstab_, "/system") && !GetEntryForMountPoint(&fstab_, "/")) {
+LOG(INFO) << "MountPartitions trying to overlayfs";
         FstabEntry root_entry;
         if (GetRootEntry(&root_entry)) {
             fstab_.emplace_back(std::move(root_entry));
@@ -563,7 +674,9 @@ bool FirstStageMount::MountPartitions() {
 
     // heads up for instantiating required device(s) for overlayfs logic
     const auto devices = fs_mgr_overlayfs_required_devices(&fstab_);
+LOG(INFO) << "MountPartitions overlayfs logic";
     for (auto const& device : devices) {
+LOG(INFO) << "MountPartitions looking again at " << device;
         if (android::base::StartsWith(device, "/dev/block/by-name/")) {
             required_devices_partition_names_.emplace(basename(device.c_str()));
             auto uevent_callback = [this](const Uevent& uevent) { return UeventCallback(uevent); };
@@ -581,8 +694,10 @@ bool FirstStageMount::MountPartitions() {
         }
     }
 
+LOG(INFO) << "MountPartitions calling overlayfs mount all";
     fs_mgr_overlayfs_mount_all(&fstab_);
 
+LOG(INFO) << "MountPartitions done";
     return true;
 }
 
diff --git a/system/core/init/subcontext.cpp b/system/core/init/subcontext.cpp
index 092c51ceb..bcd5925a3 100644
--- a/system/core/init/subcontext.cpp
+++ b/system/core/init/subcontext.cpp
@@ -258,6 +258,9 @@ void Subcontext::Fork() {
         auto child_fd_string = std::to_string(child_fd);
         const char* args[] = {init_path.c_str(), "subcontext", context_.c_str(),
                               child_fd_string.c_str(), nullptr};
+
+        LOG(INFO) << "Starting subcontext init " << init_path;
+
         execv(init_path.data(), const_cast<char**>(args));
 
         PLOG(FATAL) << "Could not execv subcontext init";
diff --git a/system/core/init/switch_root.cpp b/system/core/init/switch_root.cpp
index 575b67f38..a3c6d201c 100644
--- a/system/core/init/switch_root.cpp
+++ b/system/core/init/switch_root.cpp
@@ -75,10 +75,15 @@ void SwitchRoot(const std::string& new_root) {
     LOG(INFO) << "Switching root to '" << new_root << "'";
 
     for (const auto& mount_path : mounts) {
+LOG(INFO) << "Moving mount of " << mount_path;
         auto new_mount_path = new_root + mount_path;
+LOG(INFO) << "to " << new_mount_path;
         mkdir(new_mount_path.c_str(), 0755);
         if (mount(mount_path.c_str(), new_mount_path.c_str(), nullptr, MS_MOVE, nullptr) != 0) {
-            PLOG(FATAL) << "Unable to move mount at '" << mount_path << "'";
+            LOG(ERROR) << "Unable to move mount at '" << mount_path << "'";
+            if (mount(mount_path.c_str(), new_mount_path.c_str(), nullptr, MS_BIND, nullptr) != 0) {
+                PLOG(FATAL) << "Unable to bind mount at '" << mount_path << "'";
+            }
         }
     }
 
@@ -86,6 +91,7 @@ void SwitchRoot(const std::string& new_root) {
         PLOG(FATAL) << "Could not chdir to new_root, '" << new_root << "'";
     }
 
+LOG(INFO) << "moving root mount";
     if (mount(new_root.c_str(), "/", nullptr, MS_MOVE, nullptr) != 0) {
         PLOG(FATAL) << "Unable to move root mount to new_root, '" << new_root << "'";
     }
diff --git a/system/core/libmemunreachable/Allocator.cpp b/system/core/libmemunreachable/Allocator.cpp
index 1eb7e98c5..74cdb9465 100644
--- a/system/core/libmemunreachable/Allocator.cpp
+++ b/system/core/libmemunreachable/Allocator.cpp
@@ -54,7 +54,7 @@ constexpr unsigned int div_round_up(unsigned int x, unsigned int y) {
   return (x + y - 1) / y;
 }
 
-static constexpr size_t kPageSize = 4096;
+static constexpr size_t kPageSize = 0x4000;
 static constexpr size_t kChunkSize = 256 * 1024;
 static constexpr size_t kUsableChunkSize = kChunkSize - kPageSize;
 static constexpr size_t kMaxBucketAllocationSize = kChunkSize / 4;
diff --git a/system/core/libprocessgroup/setup/cgroup_map_write.cpp b/system/core/libprocessgroup/setup/cgroup_map_write.cpp
index 17ea06e09..16c56f9d4 100644
--- a/system/core/libprocessgroup/setup/cgroup_map_write.cpp
+++ b/system/core/libprocessgroup/setup/cgroup_map_write.cpp
@@ -290,7 +290,7 @@ bool CgroupSetup() {
 
     if (getpid() != 1) {
         LOG(ERROR) << "Cgroup setup can be done only by init process";
-        return false;
+//        return false;
     }
 
     // Make sure we do this only one time. No need for std::call_once because
diff --git a/system/core/lmkd/lmkd.c b/system/core/lmkd/lmkd.c
index c2ee061e9..bb782d800 100644
--- a/system/core/lmkd/lmkd.c
+++ b/system/core/lmkd/lmkd.c
@@ -1008,7 +1008,7 @@ static void memory_stat_parse_line(char* line, struct memory_stat* mem_st) {
 
 static int memory_stat_from_cgroup(struct memory_stat* mem_st, int pid, uid_t uid) {
     FILE *fp;
-    char buf[PATH_MAX];
+    char buf[PAGE_SIZE];
 
     snprintf(buf, sizeof(buf), MEMCG_PROCESS_MEMORY_STAT_PATH, uid, pid);
 
